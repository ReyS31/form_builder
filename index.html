<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FlowBuilder Pro - Process Analysis</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        :root {
            /* Refined, calmer palette */
            --bg-primary: #0c0d10;
            --bg-secondary: #12141a;
            --bg-tertiary: #1a1d24;
            --bg-elevated: #22262f;
            --bg-hover: #2a2f3a;
            
            --border-subtle: rgba(255,255,255,0.06);
            --border-default: rgba(255,255,255,0.1);
            --border-strong: rgba(255,255,255,0.15);
            
            --text-primary: #e8ecf2;
            --text-secondary: #9ca3af;
            --text-muted: #6b7280;
            --text-faint: #4b5563;
            
            --accent: #6366f1;
            --accent-hover: #818cf8;
            --accent-bg: rgba(99, 102, 241, 0.12);
            
            --green: #10b981;
            --green-dim: rgba(16, 185, 129, 0.12);
            --orange: #f59e0b;
            --orange-dim: rgba(245, 158, 11, 0.12);
            --red: #ef4444;
            --red-dim: rgba(239, 68, 68, 0.12);
            --purple: #a855f7;
            --purple-dim: rgba(168, 85, 247, 0.12);
            --purple-bg: rgba(168, 85, 247, 0.12);
            --cyan: #06b6d4;
            --cyan-dim: rgba(6, 182, 212, 0.12);
            
            --radius-sm: 6px;
            --radius-md: 10px;
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.2);
            --shadow-md: 0 4px 12px rgba(0,0,0,0.3);
            --transition: 0.2s ease;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Inter', -apple-system, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
            font-size: 13px;
            -webkit-font-smoothing: antialiased;
        }
        .app { display: flex; flex-direction: column; height: 100vh; }
        
        /* ===== HEADER - Minimal ===== */
        .header {
            height: 48px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-subtle);
            display: flex;
            align-items: center;
            padding: 0 12px;
            gap: 8px;
            flex-shrink: 0;
        }
        .logo {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            margin-left: -10px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: background var(--transition);
        }
        .logo:hover { background: var(--bg-hover); }
        .logo-icon {
            width: 26px;
            height: 26px;
            background: linear-gradient(135deg, var(--accent), var(--purple));
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .logo-icon svg { width: 14px; height: 14px; color: white; }
        .logo-text { font-weight: 600; font-size: 13px; }
        .logo-back { color: var(--text-muted); margin-right: 2px; }
        
        .header-divider { width: 1px; height: 20px; background: var(--border-subtle); margin: 0 4px; }
        
        /* Flow name - inline editable */
        .flow-title-btn {
            padding: 6px 10px;
            font-size: 13px;
            font-weight: 500;
            background: transparent;
            border: 1px solid transparent;
            border-radius: var(--radius-sm);
            color: var(--text-primary);
            cursor: pointer;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            transition: all var(--transition);
        }
        .flow-title-btn:hover { background: var(--bg-tertiary); border-color: var(--border-subtle); }
        
        /* Environment badge */
        .env-badge-header {
            padding: 4px 8px;
            font-size: 10px;
            font-weight: 500;
            border-radius: 4px;
            display: none;
        }
        .env-badge-header.show { display: inline-flex; }
        .env-badge-header.exhibitor { background: rgba(34,197,94,0.15); color: #22c55e; }
        .env-badge-header.organizer { background: rgba(59,130,246,0.15); color: #3b82f6; }
        .env-badge-header.ea { background: rgba(249,115,22,0.15); color: #f97316; }
        .env-badge-header.valverde { background: rgba(168,85,247,0.15); color: #a855f7; }
        .env-badge-header.other { background: var(--bg-tertiary); color: var(--text-muted); }
        
        .header-spacer { flex: 1; }
        .header-actions { display: flex; align-items: center; gap: 4px; }
        
        /* View toggle in header */
        .view-toggle-header { display: flex; align-items: center; background: var(--bg-tertiary); border-radius: var(--radius-sm); padding: 2px; gap: 2px; }
        .view-btn-sm { display: flex; align-items: center; justify-content: center; width: 28px; height: 26px; border: none; background: transparent; color: var(--text-muted); border-radius: 4px; cursor: pointer; transition: all var(--transition); }
        .view-btn-sm:hover { background: var(--bg-hover); color: var(--text-primary); }
        .view-btn-sm.active { background: var(--bg-secondary); color: var(--text-primary); box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .view-btn-sm .dot { width: 8px; height: 8px; border-radius: 50%; }
        .view-btn-sm .dot.current { background: var(--orange); }
        .view-btn-sm .dot.proposed { background: var(--green); }
        .view-btn-sm svg { width: 14px; height: 14px; }
        
        /* Mode toggle - simplified */
        .mode-toggle {
            display: flex;
            background: var(--bg-tertiary);
            border-radius: var(--radius-sm);
            padding: 2px;
            gap: 2px;
        }
        .mode-btn {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 5px 10px;
            font-size: 11px;
            font-weight: 500;
            background: transparent;
            border: none;
            border-radius: 4px;
            color: var(--text-muted);
            cursor: pointer;
            transition: all var(--transition);
        }
        .mode-btn svg { width: 14px; height: 14px; flex-shrink: 0; }
        .mode-btn:hover { color: var(--text-secondary); background: var(--bg-hover); }
        .mode-btn.active { background: var(--bg-secondary); color: var(--text-primary); box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .mode-divider { width: 1px; height: 20px; background: var(--border-subtle); margin: 0 4px; }
        .dev-mode-btn.active { background: var(--purple-bg); color: var(--purple); }
        .dev-mode-btn:hover { background: var(--purple-bg); color: var(--purple); }
        
        /* Icon buttons */
        .icon-btn {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: transparent;
            border: none;
            color: var(--text-muted);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all var(--transition);
        }
        .icon-btn:hover { background: var(--bg-tertiary); color: var(--text-primary); }
        .icon-btn svg { width: 16px; height: 16px; }
        .icon-btn.active { color: var(--accent); background: var(--accent-bg); }
        
        .btn { 
            font-family: inherit;
            font-size: 12px;
            font-weight: 500;
            padding: 7px 12px;
            border-radius: var(--radius-sm);
            border: 1px solid var(--border-subtle);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 5px;
            transition: all var(--transition);
        }
        .btn:hover { background: var(--bg-elevated); border-color: var(--border-default); }
        .btn-primary { background: var(--accent); border-color: var(--accent); color: white; }
        .btn-primary:hover { background: var(--accent-hover); }
        .btn svg { width: 12px; height: 12px; }
        .btn-icon { padding: 6px; }
        .btn.danger { color: var(--red); }
        .btn.danger:hover { background: var(--red-dim); border-color: var(--red); }

        /* ===== MAIN LAYOUT ===== */
        .main { display: flex; flex: 1; overflow: hidden; }

        /* ===== LEFT SIDEBAR - Collapsible ===== */
        .sidebar-left {
            width: 240px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-subtle);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            transition: width var(--transition), margin var(--transition);
        }
        .sidebar-left.collapsed { width: 0; margin-left: -1px; overflow: hidden; }
        
        .sidebar-header {
            padding: 10px 12px;
            border-bottom: 1px solid var(--border-subtle);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .sidebar-search {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 7px 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-sm);
            transition: border-color var(--transition);
        }
        .sidebar-search:focus-within { border-color: var(--accent); }
        .sidebar-search svg { width: 13px; height: 13px; color: var(--text-muted); }
        .sidebar-search input {
            flex: 1;
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 12px;
            outline: none;
        }
        .sidebar-search input::placeholder { color: var(--text-muted); }
        
        /* Block list */
        .block-list { flex: 1; overflow-y: auto; padding: 8px; }
        .block-list::-webkit-scrollbar { width: 4px; }
        .block-list::-webkit-scrollbar-thumb { background: var(--border-default); border-radius: 2px; }
        
        .block-list-pane-label {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            padding: 10px 8px 6px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .block-list-pane-label::before {
            content: '';
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--orange);
        }
        .block-list-pane-label.proposed::before { background: var(--green); }
        
        .block-list-item {
            padding: 10px 12px;
            margin-bottom: 4px;
            background: var(--bg-tertiary);
            border-radius: var(--radius-sm);
            cursor: pointer;
            border-left: 3px solid transparent;
            transition: all var(--transition);
        }
        .block-list-item:hover { background: var(--bg-hover); }
        .block-list-item.selected { background: var(--accent-bg); border-left-color: var(--accent); }
        .block-list-item.has-issue { border-left-color: var(--red); }
        .block-list-item.has-fix { border-left-color: var(--green); }
        .block-list-item-name {
            font-size: 12px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 2px;
        }
        .block-list-item-meta { font-size: 10px; color: var(--text-muted); }
        
        /* Validation section */
        .validation-section { padding: 12px; border-top: 1px solid var(--border-subtle); }
        .validation-list { max-height: 100px; overflow-y: auto; }
        .validation-item {
            display: flex;
            align-items: flex-start;
            gap: 6px;
            padding: 6px 8px;
            margin-bottom: 3px;
            background: var(--bg-tertiary);
            border-radius: var(--radius-sm);
            font-size: 10px;
            cursor: pointer;
            transition: background var(--transition);
        }
        .validation-item:hover { background: var(--bg-hover); }
        .validation-item svg { width: 12px; height: 12px; flex-shrink: 0; margin-top: 1px; }
        .validation-item.error svg { color: var(--red); }
        .validation-item.warning svg { color: var(--orange); }
        .validation-item.success svg { color: var(--green); }

        /* ===== CANVAS WRAPPER ===== */
        .canvas-wrapper { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
        
        /* View toggle - clean pills */
        .view-toggle {
            display: flex;
            justify-content: center;
            gap: 4px;
            padding: 8px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-subtle);
        }
        .view-btn {
            padding: 7px 14px;
            font-size: 11px;
            font-weight: 500;
            background: transparent;
            border: none;
            border-radius: var(--radius-sm);
            color: var(--text-muted);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all var(--transition);
        }
        .view-btn:hover { background: var(--bg-tertiary); color: var(--text-secondary); }
        .view-btn.active { background: var(--bg-elevated); color: var(--text-primary); }
        .view-btn svg { width: 14px; height: 14px; }
        .view-btn .dot { width: 8px; height: 8px; border-radius: 50%; }
        .view-btn .dot.current { background: var(--orange); }
        .view-btn .dot.proposed { background: var(--green); }
        
        .canvas-split { display: flex; flex: 1; overflow: hidden; }
        .canvas-split.view-current #proposedPane { display: none; }
        .canvas-split.view-current #currentPane { flex: 1; }
        .canvas-split.view-proposed #currentPane { display: none; }
        .canvas-split.view-proposed #proposedPane { flex: 1; }
        
        .canvas-pane { flex: 1; display: flex; flex-direction: column; overflow: hidden; position: relative; }
        .canvas-pane:first-child { border-right: 1px solid var(--border-subtle); }
        
        /* Pane header - minimal, hover reveals actions */
        .pane-header {
            height: 36px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-subtle);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 12px;
            flex-shrink: 0;
        }
        .pane-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .pane-indicator { width: 6px; height: 6px; border-radius: 50%; }
        .pane-indicator.current { background: var(--orange); }
        .pane-indicator.proposed { background: var(--green); }
        
        .pane-actions { display: flex; gap: 4px; }
        .pane-btn {
            font-family: inherit;
            font-size: 10px;
            font-weight: 500;
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid var(--border-subtle);
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: all var(--transition);
        }
        .pane-btn:hover { background: var(--bg-hover); color: var(--text-primary); }
        .pane-btn.primary { background: var(--accent); border-color: var(--accent); color: white; }
        .pane-btn.primary:hover { background: var(--accent-hover); }
        .pane-btn svg { width: 10px; height: 10px; }

        /* Canvas */
        .canvas-area { flex: 1; position: relative; overflow: hidden; background: var(--bg-primary); }
        .canvas-container { position: absolute; inset: 0; overflow: hidden; }
        .canvas {
            position: absolute;
            width: 6000px;
            height: 6000px;
            background-image: radial-gradient(circle, var(--border-subtle) 1px, transparent 1px);
            background-size: 24px 24px;
            transform-origin: 0 0;
        }
        .canvas-svg {
            position: absolute;
            inset: 0;
            width: 6000px;
            height: 6000px;
            pointer-events: none;
            overflow: visible;
            z-index: 5;
        }
        
        /* Canvas empty state */
        .canvas-instructions {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            pointer-events: none;
            opacity: 0;
            transition: opacity var(--transition);
        }
        .canvas-instructions.show { opacity: 1; }
        .canvas-instructions svg { width: 40px; height: 40px; margin-bottom: 12px; opacity: 0.3; }
        .canvas-instructions p { font-size: 12px; text-align: center; line-height: 1.6; }
        
        /* Zoom controls - floating, subtle */
        .zoom-controls {
            position: absolute;
            bottom: 12px;
            left: 12px;
            display: flex;
            align-items: center;
            gap: 2px;
            padding: 4px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-sm);
            box-shadow: var(--shadow-md);
            opacity: 0.7;
            transition: opacity var(--transition);
            z-index: 50;
        }
        .zoom-controls:hover { opacity: 1; }
        .zoom-btn {
            width: 26px;
            height: 26px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            border-radius: 4px;
            cursor: pointer;
            transition: all var(--transition);
        }
        .zoom-btn:hover { background: var(--bg-tertiary); color: var(--text-primary); }
        .zoom-btn svg { width: 12px; height: 12px; }
        .zoom-level { font-size: 10px; color: var(--text-muted); min-width: 32px; text-align: center; }

        /* ===== BLOCKS - Cleaner ===== */
        .block {
            position: absolute;
            width: 240px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-default);
            border-radius: var(--radius-md);
            cursor: move;
            user-select: none;
            z-index: 10;
            box-shadow: var(--shadow-sm);
            transition: border-color var(--transition), box-shadow var(--transition);
        }
        .block:hover { border-color: var(--border-strong); box-shadow: var(--shadow-md); z-index: 15; }
        .block.selected { border-color: var(--accent); box-shadow: 0 0 0 3px var(--accent-bg); z-index: 20; }
        .block.issue-error { border-left: 4px solid var(--red); }
        .block.issue-warning { border-left: 4px solid var(--orange); }
        .block.change-fix { border-left: 4px solid var(--green); }
        .block.change-new { border-left: 4px solid var(--cyan); border-style: dashed; border-left-style: solid; }
        .block.change-removed { opacity: 0.5; border-left: 4px solid var(--red); border-style: dashed; border-left-style: solid; }
        .block.linked { box-shadow: 0 0 0 2px var(--purple), 0 0 8px rgba(168,85,247,0.2); }
        .block.multi-selected { outline: 2px solid var(--cyan); outline-offset: 2px; }
        .block.search-highlight { outline: 2px solid var(--accent); outline-offset: 3px; animation: pulse-outline 1.5s ease infinite; }
        @keyframes pulse-outline { 0%,100% { outline-offset: 3px; } 50% { outline-offset: 5px; } }
        
        .block-header {
            padding: 10px 12px;
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }
        .block-icon {
            width: 28px;
            height: 28px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        .block-icon svg { width: 14px; height: 14px; color: var(--text-secondary); }
        .block-info { flex: 1; min-width: 0; }
        .block-title {
            font-size: 12px;
            font-weight: 600;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            margin-bottom: 2px;
        }
        .block-description {
            font-size: 11px;
            color: var(--text-muted);
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        .block-description.empty { font-style: italic; color: var(--text-faint); }
        
        .block-badges { display: flex; gap: 3px; flex-shrink: 0; }
        .block-badge {
            font-size: 8px;
            font-weight: 600;
            text-transform: uppercase;
            padding: 2px 5px;
            border-radius: 3px;
        }
        .block-badge.issue { background: var(--red-dim); color: var(--red); }
        .block-badge.warning { background: var(--orange-dim); color: var(--orange); }
        .block-badge.fix { background: var(--green-dim); color: var(--green); }
        .block-badge.new { background: var(--cyan-dim); color: var(--cyan); }
        .block-badge.linked { background: var(--purple-dim); color: var(--purple); }
        
        .block-annotation {
            margin: 0 12px 10px;
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 10px;
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        .block-annotation.issue { background: var(--red-dim); color: #fca5a5; border-left: 2px solid var(--red); }
        .block-annotation.fix { background: var(--green-dim); color: #86efac; border-left: 2px solid var(--green); }
        
        .block-footer {
            padding: 6px 12px;
            border-top: 1px solid var(--border-subtle);
            display: flex;
            gap: 8px;
            font-size: 9px;
            color: var(--text-muted);
        }
        .block-meta-item { display: flex; align-items: center; gap: 3px; }
        .block-meta-item svg { width: 9px; height: 9px; }

        /* Ports */
        .port-in, .port-out {
            position: absolute;
            width: 12px;
            height: 12px;
            background: var(--bg-secondary);
            border: 2px solid var(--border-default);
            border-radius: 50%;
            cursor: pointer;
            z-index: 10;
            transition: all var(--transition);
        }
        .port-in { left: 50%; top: -6px; transform: translateX(-50%); }
        .port-in:hover, .port-out:hover { background: var(--accent); border-color: var(--accent); transform: translateX(-50%) scale(1.3); }
        .port-out:hover { transform: scale(1.3); }
        .port-in.connect-target, .port-out.connect-source { background: var(--accent); border-color: var(--accent); animation: pulse 1s infinite; }
        @keyframes pulse { 0%,100% { box-shadow: 0 0 0 0 rgba(99,102,241,0.4); } 50% { box-shadow: 0 0 0 6px rgba(99,102,241,0); } }
        .block-outputs { position: absolute; bottom: -6px; left: 0; right: 0; display: flex; justify-content: center; gap: 16px; }
        .block-outputs .port-out { position: relative; transform: none; }
        .add-output {
            position: absolute;
            bottom: -6px;
            right: 16px;
            width: 12px;
            height: 12px;
            background: var(--bg-tertiary);
            border: 2px dashed var(--border-default);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }
        .add-output:hover { border-color: var(--accent); border-style: solid; background: var(--accent); }
        .add-output svg { width: 8px; height: 8px; color: var(--text-muted); }
        .add-output:hover svg { color: white; }
        .connecting-mode .block:not(.connect-target-block) { opacity: 0.4; }
        .connecting-mode .connect-target-block { opacity: 1; box-shadow: 0 0 0 2px var(--accent); }

        /* Connections */
        .connection { fill: none; stroke: var(--border-default); stroke-width: 2; stroke-linecap: round; pointer-events: none; }
        .connection-group:hover .connection { stroke: var(--accent); stroke-width: 2.5; }
        .connection-label { font-size: 10px; fill: var(--text-muted); pointer-events: all; cursor: pointer; }
        .connection-label:hover { fill: var(--accent); }
        .connection-label-bg { fill: var(--bg-primary); }
        .connection-arrow { fill: var(--border-default); }
        .connection-group:hover .connection-arrow { fill: var(--accent); }
        .connection-waypoint { fill: var(--bg-primary); stroke: var(--accent); stroke-width: 2; cursor: move; }
        .connection-waypoint:hover { fill: var(--accent); }
        .temp-connection { stroke: var(--accent); stroke-width: 2; stroke-dasharray: 6 4; fill: none; opacity: 0.7; }

        /* ===== RIGHT PANEL - Accordion style ===== */
        .panel {
            width: 300px;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-subtle);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            transition: width var(--transition), margin var(--transition);
        }
        .panel.collapsed { width: 0; margin-right: -1px; overflow: hidden; }
        .panel-header-bar { display: flex; align-items: center; justify-content: space-between; border-bottom: 1px solid var(--border-subtle); padding-right: 8px; }
        .panel-header-bar .panel-tabs { border-bottom: none; }
        
        .panel-header {
            padding: 14px 16px;
            border-bottom: 1px solid var(--border-subtle);
        }
        .panel-title-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 2px; }
        .panel-block-name { font-size: 13px; font-weight: 600; }
        .panel-block-type { font-size: 11px; color: var(--text-muted); }
        
        .panel-tabs { display: flex; gap: 2px; padding: 8px 12px; border-bottom: 1px solid var(--border-subtle); }
        .panel-tab {
            flex: 1;
            padding: 7px;
            font-size: 11px;
            font-weight: 500;
            text-align: center;
            background: transparent;
            border: none;
            border-radius: 4px;
            color: var(--text-muted);
            cursor: pointer;
            transition: all var(--transition);
        }
        .panel-tab:hover { background: var(--bg-tertiary); color: var(--text-secondary); }
        .panel-tab.active { background: var(--bg-elevated); color: var(--text-primary); }
        
        .panel-content { flex: 1; overflow-y: auto; padding: 12px; }
        .panel-content::-webkit-scrollbar { width: 4px; }
        .panel-content::-webkit-scrollbar-thumb { background: var(--border-default); border-radius: 2px; }
        
        /* Form elements */
        .form-group { margin-bottom: 14px; }
        .form-label { display: block; font-size: 11px; font-weight: 500; color: var(--text-secondary); margin-bottom: 5px; }
        .form-row { display: flex; gap: 8px; }
        .form-row > * { flex: 1; }
        .form-input, .form-select {
            width: 100%;
            padding: 8px 10px;
            font-family: inherit;
            font-size: 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-sm);
            color: var(--text-primary);
            outline: none;
            transition: border-color var(--transition);
        }
        .form-input:focus, .form-select:focus { border-color: var(--accent); }
        .form-input::placeholder { color: var(--text-muted); }
        textarea.form-input { resize: vertical; min-height: 70px; line-height: 1.5; }
        .form-hint { font-size: 10px; color: var(--text-faint); margin-top: 4px; }

        /* Section dividers - cleaner */
        .section-divider { margin: 14px 0; padding-top: 14px; border-top: 1px solid var(--border-subtle); }
        .section-title {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            color: var(--text-muted);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .section-title .dot { width: 5px; height: 5px; border-radius: 50%; }

        /* Option grids */
        .option-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
        .option-item {
            padding: 10px 8px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-sm);
            cursor: pointer;
            text-align: center;
            transition: all var(--transition);
        }
        .option-item:hover { border-color: var(--border-default); }
        .option-item.selected { border-color: var(--accent); background: var(--accent-bg); }
        .option-item.selected.error { border-color: var(--red); background: var(--red-dim); }
        .option-item.selected.warning { border-color: var(--orange); background: var(--orange-dim); }
        .option-item.selected.fix { border-color: var(--green); background: var(--green-dim); }
        .option-item-icon { font-size: 18px; margin-bottom: 3px; }
        .option-item-icon svg { width: 18px; height: 18px; }
        .option-item-label { font-size: 10px; font-weight: 500; color: var(--text-secondary); }

        .type-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; }
        .type-option {
            padding: 8px 4px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-sm);
            cursor: pointer;
            text-align: center;
            transition: all var(--transition);
        }
        .type-option:hover { border-color: var(--border-default); }
        .type-option.selected { border-color: var(--accent); background: var(--accent-bg); }
        .type-option-icon { width: 22px; height: 22px; margin: 0 auto 3px; border-radius: 4px; display: flex; align-items: center; justify-content: center; }
        .type-option-icon svg { width: 12px; height: 12px; color: white; }
        .type-option-name { font-size: 9px; font-weight: 500; }

        .link-selector { padding: 10px; background: var(--bg-tertiary); border-radius: var(--radius-sm); border: 1px solid var(--border-subtle); }
        .link-selector-label { font-size: 10px; color: var(--text-muted); margin-bottom: 8px; }
        .link-selector-current { display: flex; align-items: center; justify-content: space-between; padding: 8px; background: var(--bg-elevated); border-radius: 4px; }
        .link-selector-current span { font-size: 11px; }
        .link-selector-btn { font-size: 10px; color: var(--accent); background: none; border: none; cursor: pointer; }
        .link-selector-list { max-height: 100px; overflow-y: auto; margin-top: 8px; }
        .link-selector-item { padding: 8px; margin-bottom: 3px; background: var(--bg-elevated); border-radius: 4px; cursor: pointer; font-size: 11px; transition: background var(--transition); }
        .link-selector-item:hover { background: var(--bg-hover); }

        /* Comments */
        .comments-list { max-height: 150px; overflow-y: auto; margin-bottom: 10px; }
        .comment-item { padding: 10px; margin-bottom: 6px; background: var(--bg-tertiary); border-radius: var(--radius-sm); border-left: 2px solid var(--border-default); }
        .comment-header { display: flex; justify-content: space-between; margin-bottom: 4px; }
        .comment-author { font-size: 11px; font-weight: 600; }
        .comment-date { font-size: 10px; color: var(--text-muted); }
        .comment-text { font-size: 11px; color: var(--text-secondary); line-height: 1.5; }
        .comment-input-row { display: flex; gap: 6px; }
        .comment-input-row .form-input { flex: 1; }

        /* Attachments section */
        .attachments-section { margin-top: 14px; padding-top: 14px; border-top: 1px solid var(--border-subtle); }
        .attachments-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; }
        .attachments-title { font-size: 10px; font-weight: 600; text-transform: uppercase; color: var(--text-muted); }
        .attachment-add-btn { padding: 4px 8px; font-size: 10px; background: var(--bg-tertiary); border: 1px solid var(--border-subtle); border-radius: 4px; color: var(--text-secondary); cursor: pointer; }
        .attachment-add-btn:hover { background: var(--bg-hover); color: var(--text-primary); }
        .attachments-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 6px; }
        .attachment-item { position: relative; aspect-ratio: 1; border-radius: 4px; overflow: hidden; border: 1px solid var(--border-subtle); cursor: pointer; }
        .attachment-item img { width: 100%; height: 100%; object-fit: cover; }
        .attachment-item:hover .attachment-overlay { opacity: 1; }
        .attachment-overlay { position: absolute; inset: 0; background: rgba(0,0,0,0.6); display: flex; align-items: center; justify-content: center; gap: 6px; opacity: 0; transition: opacity var(--transition); }
        .attachment-btn { padding: 4px; background: var(--bg-secondary); border-radius: 3px; border: none; cursor: pointer; color: var(--text-primary); }
        .attachment-btn:hover { background: var(--accent); }
        .attachment-btn.danger:hover { background: var(--red); }
        .attachment-placeholder { display: flex; align-items: center; justify-content: center; aspect-ratio: 1; border: 2px dashed var(--border-subtle); border-radius: 4px; color: var(--text-muted); font-size: 10px; cursor: pointer; }
        .attachment-placeholder:hover { border-color: var(--accent); color: var(--accent); }

        /* Cross-flow links */
        .crossflow-link { display: flex; align-items: center; gap: 8px; padding: 8px 10px; background: var(--bg-tertiary); border-radius: 4px; margin-bottom: 6px; font-size: 11px; }
        .crossflow-link-icon { color: var(--accent); }
        .crossflow-link-name { flex: 1; color: var(--text-primary); cursor: pointer; }
        .crossflow-link-name:hover { text-decoration: underline; }
        .crossflow-link-remove { padding: 2px; color: var(--text-muted); cursor: pointer; background: none; border: none; }
        .crossflow-link-remove:hover { color: var(--red); }
        
        /* ===== NEW UX STYLES ===== */
        
        /* Logo styling */
        .logo { display: flex; align-items: center; gap: 10px; padding: 6px 10px; margin-left: -10px; border-radius: var(--radius-sm); cursor: pointer; transition: background var(--transition); }
        .logo:hover { background: var(--bg-hover); }
        .logo-icon { width: 32px; height: 32px; background: linear-gradient(135deg, var(--accent), var(--purple)); border-radius: var(--radius-sm); display: flex; align-items: center; justify-content: center; flex-shrink: 0; }
        .logo-icon svg { color: white; }
        .logo-text { font-size: 14px; font-weight: 600; letter-spacing: -0.01em; }
        
        /* Header flow section */
        .header-flow { flex: 1; display: flex; align-items: center; justify-content: center; gap: 10px; }
        .flow-title-btn { display: flex; align-items: center; gap: 6px; padding: 8px 14px; font-size: 13px; font-weight: 500; background: transparent; border: 1px solid transparent; border-radius: var(--radius-sm); color: var(--text-primary); cursor: pointer; max-width: 280px; transition: all var(--transition); }
        .flow-title-btn:hover { background: var(--bg-tertiary); border-color: var(--border-subtle); }
        .flow-title-btn span { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        
        /* Environment badge */
        .env-badge { padding: 4px 10px; font-size: 11px; font-weight: 500; border-radius: 12px; display: none; }
        .env-badge.show { display: inline-flex; }
        .env-badge.exhibitor { background: var(--green-dim); color: var(--green); }
        .env-badge.organizer { background: rgba(59,130,246,0.12); color: #3b82f6; }
        .env-badge.ea { background: var(--orange-dim); color: var(--orange); }
        .env-badge.valverde { background: var(--purple-dim); color: var(--purple); }
        .env-badge.other { background: var(--bg-tertiary); color: var(--text-muted); }
        
        /* Icon button */
        .icon-btn { width: 34px; height: 34px; display: flex; align-items: center; justify-content: center; background: transparent; border: none; color: var(--text-muted); border-radius: var(--radius-sm); cursor: pointer; transition: all var(--transition); }
        .icon-btn:hover { background: var(--bg-tertiary); color: var(--text-primary); }
        .icon-btn:disabled { opacity: 0.4; cursor: not-allowed; }
        .icon-btn:disabled:hover { background: transparent; color: var(--text-muted); }
        .icon-btn svg { width: 18px; height: 18px; }
        .icon-btn.active { background: var(--accent-bg); color: var(--accent); }
        
        /* User avatar */
        .user-avatar { width: 32px; height: 32px; border-radius: 50%; cursor: pointer; transition: opacity var(--transition); border: 2px solid var(--border-subtle); }
        .user-avatar:hover { opacity: 0.8; }
        
        /* Sidebar header */
        .sidebar-header { padding: 12px; border-bottom: 1px solid var(--border-subtle); }
        .sidebar-search { display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-subtle); border-radius: var(--radius-sm); transition: border-color var(--transition); }
        .sidebar-search:focus-within { border-color: var(--accent); }
        .sidebar-search svg { width: 14px; height: 14px; color: var(--text-muted); flex-shrink: 0; }
        .sidebar-search input { flex: 1; background: none; border: none; color: var(--text-primary); font-size: 12px; outline: none; }
        .sidebar-search input::placeholder { color: var(--text-muted); }
        
        /* Block list container */
        .block-list-container { flex: 1; overflow: hidden; display: flex; flex-direction: column; }
        
        /* Sidebar accordion */
        .sidebar-accordion { border-top: 1px solid var(--border-subtle); }
        .accordion-header { display: flex; align-items: center; justify-content: space-between; padding: 10px 12px; cursor: pointer; transition: background var(--transition); }
        .accordion-header:hover { background: var(--bg-hover); }
        .accordion-title { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.04em; color: var(--text-muted); }
        .accordion-chevron { width: 14px; height: 14px; color: var(--text-faint); transition: transform var(--transition); }
        .sidebar-accordion.open .accordion-chevron { transform: rotate(180deg); }
        .accordion-body { max-height: 0; overflow: hidden; transition: max-height 0.3s ease; }
        .sidebar-accordion.open .accordion-body { max-height: 200px; }
        .accordion-content { padding: 0 12px 12px; }
        
        /* Validation badge */
        .validation-badge { font-size: 10px; font-weight: 600; padding: 2px 6px; border-radius: 8px; background: var(--red-dim); color: var(--red); margin-left: auto; margin-right: 8px; display: none; }
        .validation-badge.show { display: inline-block; }
        .validation-badge.warning { background: var(--orange-dim); color: var(--orange); }
        .validation-badge.success { background: var(--green-dim); color: var(--green); }
        
        /* Panel accordion */
        .panel-accordion { border: 1px solid var(--border-subtle); border-radius: var(--radius-sm); margin-bottom: 12px; overflow: hidden; }
        .panel-accordion-header { display: flex; align-items: center; justify-content: space-between; padding: 10px 12px; background: var(--bg-tertiary); cursor: pointer; transition: background var(--transition); }
        .panel-accordion-header:hover { background: var(--bg-hover); }
        .panel-accordion-title { font-size: 11px; font-weight: 600; color: var(--text-primary); }
        .panel-accordion-chevron { width: 14px; height: 14px; color: var(--text-muted); transition: transform var(--transition); }
        .panel-accordion.open .panel-accordion-chevron { transform: rotate(180deg); }
        .panel-accordion-body { max-height: 0; overflow: hidden; transition: max-height 0.3s ease; }
        .panel-accordion.open .panel-accordion-body { max-height: 400px; }
        .panel-accordion-content { padding: 12px; }
        
        /* Panel header improvements */
        .panel-header-section { padding: 14px 16px; border-bottom: 1px solid var(--border-subtle); }
        .panel-header-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 2px; }
        .panel-block-name { font-size: 13px; font-weight: 600; }
        .panel-block-type { font-size: 11px; color: var(--text-muted); }
        
        /* Pane header improvements */
        .pane-indicator { width: 6px; height: 6px; border-radius: 50%; }
        .pane-indicator.current { background: var(--orange); }
        .pane-indicator.proposed { background: var(--green); }
        .pane-actions { display: flex; gap: 4px; }
        .pane-btn { font-family: inherit; font-size: 10px; font-weight: 500; padding: 5px 10px; border-radius: 4px; border: 1px solid var(--border-subtle); background: var(--bg-tertiary); color: var(--text-secondary); cursor: pointer; display: flex; align-items: center; gap: 4px; transition: all var(--transition); }
        .pane-btn:hover { background: var(--bg-hover); color: var(--text-primary); }
        .pane-btn.primary { background: var(--accent); border-color: var(--accent); color: white; }
        .pane-btn.primary:hover { background: var(--accent-hover); }
        .pane-btn svg { width: 11px; height: 11px; }

        .canvas-area { flex: 1; position: relative; overflow: hidden; }
        .canvas-container { position: absolute; inset: 0; overflow: hidden; }
        .canvas { position: absolute; width: 6000px; height: 6000px; background-image: radial-gradient(circle, var(--border-subtle) 1px, transparent 1px); background-size: 24px 24px; transform-origin: 0 0; }
        .canvas-svg { position: absolute; inset: 0; width: 6000px; height: 6000px; pointer-events: none; overflow: visible; z-index: 20; }
        
        .connection { fill: none; stroke: var(--border-default); stroke-width: 2; stroke-linecap: round; pointer-events: none; filter: drop-shadow(0 1px 2px rgba(0,0,0,0.15)); }
        .connection:hover { stroke: var(--accent); stroke-width: 3; }
        .connection-label { font-size: 10px; fill: var(--text-secondary); pointer-events: all; cursor: pointer; user-select: none; }
        .connection-label:hover { fill: var(--accent); }
        .connection-label-bg { fill: var(--bg-primary); }
        .connection-arrow { fill: var(--border-default); }
        .connection:hover + .connection-arrow, .connection-group:hover .connection-arrow { fill: var(--accent); }
        .connection-group:hover .connection { stroke: var(--accent); stroke-width: 3; }
        .connection-group:hover .connection-label { fill: var(--accent); }
        .connection-waypoint { fill: var(--bg-primary); stroke: var(--accent); stroke-width: 2; cursor: move; }
        .connection-waypoint:hover { fill: var(--accent); stroke-width: 3; }
        .connection-add-hint { fill: var(--accent); font-size: 20px; cursor: pointer; opacity: 0.5; }
        .connection-add-hint:hover { opacity: 1; }
        .port-label { position: absolute; font-size: 8px; color: var(--text-muted); white-space: nowrap; pointer-events: none; }
        .port-label-out { bottom: -18px; left: 50%; transform: translateX(-50%); }
        .port-label-in { top: -18px; left: 50%; transform: translateX(-50%); }
        .connection:hover { stroke: var(--accent); stroke-width: 3; }
        .temp-connection { stroke: var(--accent); stroke-width: 2; stroke-dasharray: 6 4; fill: none; opacity: 0.7; }

        .block { position: absolute; width: 260px; background: var(--bg-secondary); border: 2px solid var(--border-subtle); border-radius: 10px; cursor: move; user-select: none; z-index: 10; }
        .block:hover { border-color: var(--border-default); z-index: 20; }
        .block.selected { border-color: var(--accent); box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2); z-index: 30; }
        .block.issue-error { border-left: 4px solid var(--red); }
        .block.issue-warning { border-left: 4px solid var(--orange); }
        .block.change-fix { border-left: 4px solid var(--green); }
        .block.change-new { border-left: 4px solid var(--cyan); border-style: dashed; border-left-style: solid; }
        .block.change-removed { opacity: 0.5; border-left: 4px solid var(--red); border-style: dashed; border-left-style: solid; }
        .block.linked { box-shadow: 0 0 0 2px var(--purple), 0 0 10px rgba(168, 85, 247, 0.3); }
        
        .block-header { padding: 8px 10px; border-bottom: 1px solid var(--border-subtle); display: flex; align-items: center; gap: 6px; }
        .block-icon { width: 24px; height: 24px; background: var(--bg-tertiary); border-radius: 5px; display: flex; align-items: center; justify-content: center; flex-shrink: 0; }
        .block-icon svg { width: 12px; height: 12px; color: var(--text-secondary); }
        .block-title { font-size: 12px; font-weight: 600; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .block-badges { display: flex; gap: 2px; flex-shrink: 0; }
        .block-badge { font-size: 7px; font-weight: 600; text-transform: uppercase; padding: 2px 4px; border-radius: 3px; }
        .block-badge.issue { background: var(--red-dim); color: var(--red); }
        .block-badge.warning { background: var(--orange-dim); color: var(--orange); }
        .block-badge.fix { background: var(--green-dim); color: var(--green); }
        .block-badge.new { background: var(--cyan-dim); color: var(--cyan); }
        .block-badge.linked { background: var(--purple-dim); color: var(--purple); }
        .block-badge.status { background: var(--bg-tertiary); color: var(--text-muted); }
        
        .block-body { padding: 8px 10px; }
        .block-description { font-size: 11px; color: var(--text-secondary); line-height: 1.4; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
        .block-description.empty { color: var(--text-muted); font-style: italic; }
        
        .block-annotation { margin-top: 6px; padding: 6px 8px; border-radius: 5px; font-size: 10px; line-height: 1.3; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
        .block-annotation.issue { background: var(--red-dim); color: #fca5a5; border-left: 2px solid var(--red); }
        .block-annotation.warning { background: var(--orange-dim); color: #fdba74; border-left: 2px solid var(--orange); }
        .block-annotation.fix { background: var(--green-dim); color: #86efac; border-left: 2px solid var(--green); }

        .block-meta { margin-top: 6px; display: flex; flex-wrap: wrap; gap: 6px; font-size: 9px; color: var(--text-muted); }
        .block-meta-item { display: flex; align-items: center; gap: 2px; }
        .block-meta-item svg { width: 9px; height: 9px; }

        .port-in, .port-out { position: absolute; width: 14px; height: 14px; background: var(--bg-secondary); border: 2px solid var(--border-default); border-radius: 50%; cursor: pointer; z-index: 10; }
        .port-in::before, .port-out::before { content: ''; position: absolute; top: -8px; left: -8px; right: -8px; bottom: -8px; border-radius: 50%; }
        .port-in { left: 50%; top: -7px; transform: translateX(-50%); }
        .port-in:hover { background: var(--accent); border-color: var(--accent); transform: translateX(-50%) scale(1.2); }
        .port-out:hover { background: var(--accent); border-color: var(--accent); transform: scale(1.2); }
        .port-in.connect-target, .port-out.connect-source { background: var(--accent); border-color: var(--accent); animation: pulse 1s infinite; }
        @keyframes pulse { 0%, 100% { box-shadow: 0 0 0 0 rgba(99, 102, 241, 0.4); } 50% { box-shadow: 0 0 0 6px rgba(99, 102, 241, 0); } }
        .block-outputs { position: absolute; bottom: -7px; left: 0; right: 0; display: flex; justify-content: center; gap: 16px; }
        .block-outputs .port-out { position: relative; right: auto; top: auto; transform: none; }
        .block-outputs .port-out:hover { transform: scale(1.2); }
        .add-output { position: absolute; bottom: -7px; right: 16px; width: 14px; height: 14px; background: var(--bg-tertiary); border: 2px dashed var(--border-default); border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; z-index: 10; }
        .add-output:hover { border-color: var(--accent); border-style: solid; background: var(--accent); }
        .add-output svg { width: 8px; height: 8px; color: var(--text-muted); }
        .add-output:hover svg { color: white; }
        .connecting-mode .block:not(.connect-target-block) { opacity: 0.5; }
        .connecting-mode .connect-target-block { opacity: 1; box-shadow: 0 0 0 2px var(--accent); }
        
        /* Helper/Note blocks */
        .block.helper-block { width: 200px; background: var(--bg-tertiary); border: 2px dashed var(--border-default); border-radius: 8px; }
        .block.helper-block .block-header { background: transparent; border-bottom: none; padding: 6px 8px; }
        .block.helper-block .block-icon { background: var(--purple-bg); }
        .block.helper-block .block-icon svg { color: var(--purple); }
        .block.helper-block .block-title { color: var(--purple); font-size: 10px; text-transform: uppercase; letter-spacing: 0.5px; }
        .block.helper-block .block-body { padding: 0 8px 8px; }
        .block.helper-block .block-description { color: var(--text-secondary); font-size: 11px; -webkit-line-clamp: 5; }
        .block.helper-block .port-in, .block.helper-block .port-out, .block.helper-block .block-outputs, .block.helper-block .add-output { display: none; }
        
        /* Actor type stripes */
        .block.actor-user { border-left: 4px solid #0ea5e9; }
        .block.actor-user .block-header { background: linear-gradient(90deg, rgba(14, 165, 233, 0.08) 0%, transparent 100%); }
        .block.actor-system { border-left: 4px solid #a855f7; }
        .block.actor-system .block-header { background: linear-gradient(90deg, rgba(168, 85, 247, 0.08) 0%, transparent 100%); }
        .block.actor-admin { border-left: 4px solid #f59e0b; }
        .block.actor-admin .block-header { background: linear-gradient(90deg, rgba(245, 158, 11, 0.08) 0%, transparent 100%); }
        
        .actor-indicator { display: flex; align-items: center; gap: 3px; font-size: 8px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; margin-right: auto; padding: 2px 5px; border-radius: 3px; }
        .actor-indicator.user { background: rgba(14, 165, 233, 0.15); color: #0ea5e9; }
        .actor-indicator.system { background: rgba(168, 85, 247, 0.15); color: #a855f7; }
        .actor-indicator.admin { background: rgba(245, 158, 11, 0.15); color: #f59e0b; }
        .actor-indicator svg { width: 9px; height: 9px; }
        
        /* Actor legend */
        .actor-legend { display: flex; gap: 12px; padding: 4px 8px; font-size: 9px; color: var(--text-muted); background: var(--bg-tertiary); border-radius: 4px; }
        .actor-legend-item { display: flex; align-items: center; gap: 4px; }
        .actor-legend-dot { width: 8px; height: 8px; border-radius: 2px; }
        .actor-legend-dot.user { background: #0ea5e9; }
        .actor-legend-dot.system { background: #a855f7; }
        .actor-legend-dot.admin { background: #f59e0b; }
        
        /* Actor selector in panel */
        .actor-selector { display: flex; gap: 6px; }
        .actor-option { flex: 1; display: flex; align-items: center; justify-content: center; gap: 6px; padding: 8px; background: var(--bg-tertiary); border: 2px solid transparent; border-radius: var(--radius-sm); cursor: pointer; transition: all var(--transition); }
        .actor-option:hover { background: var(--bg-hover); }
        .actor-option.selected { border-color: var(--accent); background: var(--accent-bg); }
        .actor-option.user.selected { border-color: #0ea5e9; background: rgba(14, 165, 233, 0.12); }
        .actor-option.system.selected { border-color: #a855f7; background: rgba(168, 85, 247, 0.12); }
        .actor-option.admin.selected { border-color: #f59e0b; background: rgba(245, 158, 11, 0.12); }
        .actor-option-icon { width: 20px; height: 20px; border-radius: 4px; display: flex; align-items: center; justify-content: center; }
        .actor-option.user .actor-option-icon { background: rgba(14, 165, 233, 0.2); color: #0ea5e9; }
        .actor-option.system .actor-option-icon { background: rgba(168, 85, 247, 0.2); color: #a855f7; }
        .actor-option.admin .actor-option-icon { background: rgba(245, 158, 11, 0.2); color: #f59e0b; }
        .actor-option-icon svg { width: 12px; height: 12px; }
        .actor-option-label { font-size: 11px; font-weight: 500; color: var(--text-secondary); }
        .actor-option.selected .actor-option-label { color: var(--text-primary); }
        
        /* Inline edit overlay */
        .inline-edit-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: var(--bg-secondary); border-radius: 8px; z-index: 100; padding: 8px; display: flex; flex-direction: column; gap: 6px; }
        .inline-edit-input { width: 100%; padding: 6px 8px; background: var(--bg-primary); border: 1px solid var(--border-default); border-radius: 5px; color: var(--text-primary); font-size: 12px; font-family: inherit; }
        .inline-edit-input:focus { outline: none; border-color: var(--accent); }
        .inline-edit-input.title-input { font-weight: 600; }
        .inline-edit-textarea { resize: none; min-height: 40px; }
        .inline-edit-types { display: flex; flex-wrap: wrap; gap: 4px; margin-top: 2px; }
        .inline-edit-type { width: 28px; height: 28px; border-radius: 5px; border: 2px solid transparent; background: var(--bg-tertiary); display: flex; align-items: center; justify-content: center; cursor: pointer; }
        .inline-edit-type:hover { border-color: var(--border-default); }
        .inline-edit-type.selected { border-color: var(--accent); background: var(--accent-bg); }
        .inline-edit-type svg { width: 14px; height: 14px; }
        .inline-edit-actions { display: flex; gap: 6px; margin-top: auto; }
        .inline-edit-btn { flex: 1; padding: 6px; border: none; border-radius: 5px; font-size: 11px; font-weight: 500; cursor: pointer; }
        .inline-edit-btn.save { background: var(--accent); color: white; }
        .inline-edit-btn.cancel { background: var(--bg-tertiary); color: var(--text-secondary); }

        .panel { width: 320px; background: var(--bg-secondary); border-left: 1px solid var(--border-subtle); display: flex; flex-direction: column; flex-shrink: 0; }
        .panel-tabs { display: flex; border-bottom: 1px solid var(--border-subtle); }
        .panel-tab { flex: 1; padding: 10px; font-size: 10px; font-weight: 600; text-transform: uppercase; color: var(--text-muted); background: none; border: none; cursor: pointer; border-bottom: 2px solid transparent; }
        .panel-tab:hover { color: var(--text-secondary); }
        .panel-tab.active { color: var(--accent); border-bottom-color: var(--accent); }
        .panel-content { flex: 1; overflow-y: auto; padding: 12px; }
        .panel-content::-webkit-scrollbar { width: 4px; }
        .panel-content::-webkit-scrollbar-thumb { background: var(--border-subtle); border-radius: 2px; }
        
        .form-group { margin-bottom: 12px; }
        .form-label { display: block; font-size: 10px; font-weight: 500; color: var(--text-secondary); margin-bottom: 4px; }
        .form-row { display: flex; gap: 6px; }
        .form-row > * { flex: 1; }
        .form-input, .form-select { width: 100%; padding: 6px 8px; font-family: inherit; font-size: 12px; background: var(--bg-tertiary); border: 1px solid var(--border-subtle); border-radius: 5px; color: var(--text-primary); outline: none; }
        .form-input:focus, .form-select:focus { border-color: var(--accent); }
        textarea.form-input { resize: vertical; min-height: 60px; line-height: 1.4; }

        .section-divider { margin: 12px 0; padding-top: 12px; border-top: 1px solid var(--border-subtle); }
        .section-title { font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-muted); margin-bottom: 8px; display: flex; align-items: center; gap: 5px; }
        .section-title .dot { width: 5px; height: 5px; border-radius: 50%; }

        .option-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; }
        .option-item { padding: 8px 6px; border-radius: 5px; border: 1px solid var(--border-subtle); background: var(--bg-tertiary); cursor: pointer; text-align: center; }
        .option-item:hover { border-color: var(--border-default); }
        .option-item.selected { border-color: var(--accent); background: rgba(59, 130, 246, 0.1); }
        .option-item.selected.error { border-color: var(--red); background: var(--red-dim); }
        .option-item.selected.warning { border-color: var(--orange); background: var(--orange-dim); }
        .option-item.selected.fix { border-color: var(--green); background: var(--green-dim); }
        .option-item.selected.new { border-color: var(--cyan); background: var(--cyan-dim); }
        .option-item-icon { font-size: 16px; margin-bottom: 2px; }
        .option-item-icon svg { width: 18px; height: 18px; }
        .option-item-label { font-size: 9px; font-weight: 500; color: var(--text-secondary); }

        .link-selector { padding: 8px; background: var(--bg-tertiary); border-radius: 5px; border: 1px solid var(--border-subtle); }
        .link-selector-label { font-size: 10px; color: var(--text-muted); margin-bottom: 6px; }
        .link-selector-current { display: flex; align-items: center; justify-content: space-between; padding: 6px; background: var(--bg-elevated); border-radius: 4px; }
        .link-selector-current span { font-size: 11px; }
        .link-selector-btn { font-size: 10px; color: var(--accent); background: none; border: none; cursor: pointer; }
        .link-selector-list { max-height: 120px; overflow-y: auto; margin-top: 6px; }
        .link-selector-item { padding: 6px; margin-bottom: 3px; background: var(--bg-elevated); border-radius: 3px; cursor: pointer; font-size: 11px; }
        .link-selector-item:hover { background: var(--border-subtle); }

        .type-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; }
        .type-option { padding: 8px 4px; background: var(--bg-tertiary); border: 1px solid var(--border-subtle); border-radius: 5px; cursor: pointer; text-align: center; }
        .type-option:hover { border-color: var(--border-default); }
        .type-option.selected { border-color: var(--accent); background: rgba(59, 130, 246, 0.1); }
        .type-option-icon { width: 24px; height: 24px; margin: 0 auto 3px; border-radius: 5px; display: flex; align-items: center; justify-content: center; }
        .type-option-icon svg { width: 12px; height: 12px; color: white; }
        .type-option-name { font-size: 8px; font-weight: 500; }

        .comments-list { max-height: 150px; overflow-y: auto; margin-bottom: 8px; }
        .comment-item { padding: 8px; margin-bottom: 6px; background: var(--bg-tertiary); border-radius: 5px; border-left: 2px solid var(--border-default); }
        .comment-header { display: flex; justify-content: space-between; margin-bottom: 3px; }
        .comment-author { font-size: 10px; font-weight: 600; }
        .comment-date { font-size: 9px; color: var(--text-muted); }
        .comment-text { font-size: 11px; color: var(--text-secondary); line-height: 1.4; }
        .comment-input-row { display: flex; gap: 5px; }
        .comment-input-row .form-input { flex: 1; }

        .zoom-controls { position: absolute; bottom: 12px; left: 12px; display: flex; align-items: center; gap: 2px; background: var(--bg-secondary); border: 1px solid var(--border-subtle); border-radius: var(--radius-sm); padding: 3px; z-index: 50; opacity: 0.7; transition: opacity var(--transition); }
        .zoom-controls:hover { opacity: 1; }
        .actor-legend { position: absolute; bottom: 12px; right: 12px; z-index: 50; opacity: 0.8; }
        .zoom-btn { width: 24px; height: 24px; border: none; background: transparent; color: var(--text-secondary); border-radius: 3px; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .zoom-btn:hover { background: var(--bg-tertiary); color: var(--text-primary); }
        .zoom-btn svg { width: 12px; height: 12px; }
        .zoom-level { font-size: 9px; font-weight: 500; color: var(--text-secondary); padding: 0 4px; min-width: 32px; text-align: center; }

        .canvas-instructions { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: var(--text-muted); pointer-events: none; z-index: 5; }
        .canvas-instructions.hidden { display: none; }
        .canvas-instructions svg { width: 36px; height: 36px; margin-bottom: 8px; opacity: 0.3; }
        .canvas-instructions p { font-size: 11px; line-height: 1.4; }

        .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.7); display: none; align-items: center; justify-content: center; z-index: 10000; backdrop-filter: blur(4px); }
        .modal-overlay.show { display: flex; }
        .modal { background: var(--bg-secondary); border: 1px solid var(--border-subtle); border-radius: 10px; width: 460px; max-height: 80vh; display: flex; flex-direction: column; box-shadow: 0 20px 60px rgba(0,0,0,0.5); }
        .modal.lg { width: 640px; }
        .modal.xl { width: 800px; max-height: 85vh; }
        .help-content { padding: 0; }
        .help-tabs { display: flex; gap: 0; border-bottom: 1px solid var(--border-subtle); margin: -16px -16px 16px -16px; padding: 0 16px; }
        .help-tab { padding: 12px 20px; background: none; border: none; color: var(--text-muted); cursor: pointer; font-size: 13px; font-weight: 500; border-bottom: 2px solid transparent; margin-bottom: -1px; }
        .help-tab:hover { color: var(--text-primary); }
        .help-tab.active { color: var(--accent); border-bottom-color: var(--accent); }
        .help-panel { display: none; max-height: 60vh; overflow-y: auto; padding-right: 8px; }
        .help-panel.active { display: block; }
        .help-panel h3 { font-size: 14px; font-weight: 600; color: var(--text-primary); margin: 20px 0 10px 0; }
        .help-panel h3:first-child { margin-top: 0; }
        .help-panel p { font-size: 13px; color: var(--text-secondary); line-height: 1.6; margin: 0 0 12px 0; }
        .help-panel ul, .help-panel ol { font-size: 13px; color: var(--text-secondary); line-height: 1.8; margin: 0 0 12px 0; padding-left: 20px; }
        .help-panel li { margin-bottom: 4px; }
        .help-table { width: 100%; border-collapse: collapse; font-size: 12px; margin: 12px 0; }
        .help-table td { padding: 8px 12px; border: 1px solid var(--border-subtle); vertical-align: top; }
        .help-table td:first-child { width: 140px; background: var(--bg-tertiary); font-weight: 500; white-space: nowrap; }
        .help-code { background: var(--bg-tertiary); border: 1px solid var(--border-subtle); border-radius: 6px; padding: 12px; font-family: 'SF Mono', Monaco, monospace; font-size: 11px; line-height: 1.5; overflow-x: auto; white-space: pre; color: var(--text-secondary); margin: 12px 0; }
        .help-prompt { background: var(--bg-tertiary); border-radius: 8px; padding: 16px; margin: 12px 0; }
        .modal-header { padding: 14px 16px; border-bottom: 1px solid var(--border-subtle); display: flex; align-items: center; justify-content: space-between; }
        .modal-title { font-size: 14px; font-weight: 600; }
        .modal-close { background: none; border: none; color: var(--text-muted); cursor: pointer; padding: 4px; border-radius: 4px; }
        .modal-close:hover { color: var(--text-primary); background: var(--bg-tertiary); }
        .modal-body { padding: 16px; overflow-y: auto; flex: 1; }
        .modal-footer { padding: 12px 16px; border-top: 1px solid var(--border-subtle); display: flex; justify-content: flex-end; gap: 6px; }

        .flow-list { display: flex; flex-direction: column; gap: 5px; }
        .flow-item { display: flex; align-items: center; gap: 10px; padding: 10px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-subtle); border-radius: 6px; cursor: pointer; }
        .flow-item:hover { border-color: var(--border-default); background: var(--bg-elevated); }
        .flow-item.active { border-color: var(--accent); background: rgba(59, 130, 246, 0.1); }
        .flow-item-info { flex: 1; min-width: 0; }
        .flow-item-name { font-size: 12px; font-weight: 500; margin-bottom: 2px; }
        .flow-item-meta { font-size: 10px; color: var(--text-muted); }
        .flow-item-actions { display: flex; gap: 3px; opacity: 0; }
        .flow-item:hover .flow-item-actions { opacity: 1; }
        .flow-item-btn { background: none; border: none; color: var(--text-muted); cursor: pointer; padding: 3px; border-radius: 3px; }
        .flow-item-btn:hover { color: var(--text-primary); background: var(--bg-tertiary); }
        .flow-item-btn.danger:hover { color: var(--red); }

        .template-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .template-item { padding: 12px; background: var(--bg-tertiary); border: 1px solid var(--border-subtle); border-radius: 6px; cursor: pointer; }
        .template-item:hover { border-color: var(--border-default); background: var(--bg-elevated); }
        .template-item-icon { font-size: 20px; margin-bottom: 6px; }
        .template-item-name { font-size: 12px; font-weight: 500; margin-bottom: 2px; }
        .template-item-desc { font-size: 10px; color: var(--text-muted); }

        .export-options { display: flex; flex-direction: column; gap: 8px; }
        .export-option { display: flex; align-items: center; gap: 10px; padding: 12px; background: var(--bg-tertiary); border: 1px solid var(--border-subtle); border-radius: 6px; cursor: pointer; }
        .export-option:hover { border-color: var(--border-default); background: var(--bg-elevated); }
        .export-option-icon { width: 36px; height: 36px; background: var(--bg-elevated); border-radius: 6px; display: flex; align-items: center; justify-content: center; }
        .export-option-icon svg { width: 18px; height: 18px; color: var(--accent); }
        .export-option-info { flex: 1; }
        .export-option-name { font-size: 13px; font-weight: 500; margin-bottom: 2px; }
        .export-option-desc { font-size: 11px; color: var(--text-muted); }

        .summary-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px; margin-bottom: 12px; }
        .summary-stat { padding: 8px; background: var(--bg-tertiary); border-radius: 5px; text-align: center; }
        .summary-stat-value { font-size: 16px; font-weight: 700; margin-bottom: 1px; }
        .summary-stat-value.issues { color: var(--red); }
        .summary-stat-value.warnings { color: var(--orange); }
        .summary-stat-value.fixes { color: var(--green); }
        .summary-stat-value.new { color: var(--cyan); }
        .summary-stat-label { font-size: 8px; color: var(--text-muted); text-transform: uppercase; }

        .toast-container { position: fixed; bottom: 16px; right: 16px; z-index: 20000; }
        .toast { background: var(--bg-secondary); border: 1px solid var(--border-subtle); border-radius: 6px; padding: 10px 14px; margin-top: 6px; display: flex; align-items: center; gap: 8px; min-width: 200px; animation: slideIn 0.2s ease; box-shadow: 0 8px 30px rgba(0,0,0,0.3); }
        @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        .toast.success { border-left: 3px solid var(--green); }
        .toast.error { border-left: 3px solid var(--red); }
        .toast svg { width: 14px; height: 14px; flex-shrink: 0; }
        .toast.success svg { color: var(--green); }
        .toast.error svg { color: var(--red); }
        .toast span { font-size: 12px; }

        @media print { .header, .sidebar-left, .panel, .zoom-controls, .pane-actions { display: none !important; } }
        .hidden { display: none !important; }
        
        .diff-section { margin-bottom: 16px; }
        .diff-section-title { font-size: 11px; font-weight: 600; color: var(--text-muted); margin-bottom: 8px; display: flex; align-items: center; gap: 6px; }
        .diff-section-title .count { background: var(--bg-elevated); padding: 2px 6px; border-radius: 10px; font-size: 10px; }
        .diff-item { display: flex; align-items: center; gap: 10px; padding: 8px 10px; background: var(--bg-tertiary); border-radius: 5px; margin-bottom: 4px; font-size: 11px; }
        .diff-item.added { border-left: 3px solid var(--green); background: var(--green-dim); }
        .diff-item.removed { border-left: 3px solid var(--red); background: var(--red-dim); }
        .diff-item.changed { border-left: 3px solid var(--orange); background: var(--orange-dim); }
        .diff-item-icon { font-size: 14px; }
        .diff-item-name { font-weight: 500; flex: 1; }
        .diff-item-detail { font-size: 10px; color: var(--text-muted); }
        .diff-summary { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 16px; padding: 12px; background: var(--bg-tertiary); border-radius: 6px; }
        .diff-stat { text-align: center; }
        .diff-stat-value { font-size: 20px; font-weight: 700; }
        .diff-stat-value.added { color: var(--green); }
        .diff-stat-value.changed { color: var(--orange); }
        .diff-stat-value.removed { color: var(--red); }
        .diff-stat-label { font-size: 9px; color: var(--text-muted); text-transform: uppercase; }
        .import-info { padding: 12px; background: var(--bg-tertiary); border-radius: 6px; margin-bottom: 16px; }
        .import-info-row { display: flex; justify-content: space-between; font-size: 11px; margin-bottom: 4px; }
        .import-info-row:last-child { margin-bottom: 0; }
        .import-info-label { color: var(--text-muted); }
        .flow-picker-list { max-height: 300px; overflow-y: auto; }
        .flow-picker-item { padding: 12px; background: var(--bg-tertiary); border-radius: 6px; margin-bottom: 8px; cursor: pointer; transition: all 0.15s; }
        .flow-picker-item:hover { background: var(--bg-elevated); transform: translateX(4px); }
        .flow-picker-name { font-weight: 600; font-size: 13px; margin-bottom: 4px; }
        .flow-picker-meta { font-size: 11px; color: var(--text-muted); }
        .btn-merge { background: var(--purple); border-color: var(--purple); }
        .btn-merge:hover { background: #9333ea; }
        
        .form-hint { font-size: 9px; color: var(--text-muted); margin-top: 4px; line-height: 1.3; }
        
        .google-auth { display: flex; align-items: center; }
        .google-user { display: flex; align-items: center; gap: 8px; padding: 4px 8px; background: var(--bg-tertiary); border-radius: 6px; }
        .google-user img { width: 20px; height: 20px; border-radius: 50%; }
        .google-user span { font-size: 11px; font-weight: 500; max-width: 100px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .btn-icon { background: none; border: none; color: var(--text-muted); cursor: pointer; padding: 2px; border-radius: 3px; display: flex; align-items: center; }
        .btn-icon:hover { color: var(--text-primary); background: var(--bg-elevated); }
        
        .storage-toggle { display: flex; gap: 4px; margin-bottom: 12px; padding: 3px; background: var(--bg-tertiary); border-radius: 6px; }
        .storage-btn { flex: 1; font-family: inherit; font-size: 11px; font-weight: 500; padding: 6px 10px; border: none; background: transparent; color: var(--text-secondary); border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 5px; }
        .storage-btn:hover { color: var(--text-primary); }
        .storage-btn.active { background: var(--bg-elevated); color: var(--text-primary); box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
        .storage-btn svg { width: 14px; height: 14px; }
        .storage-btn.drive svg { color: #4285f4; }
        
        .drive-status { padding: 12px; background: var(--bg-tertiary); border-radius: 6px; margin-bottom: 12px; text-align: center; }
        .drive-status-icon { font-size: 24px; margin-bottom: 6px; }
        .drive-status-text { font-size: 12px; color: var(--text-secondary); margin-bottom: 8px; }
        .drive-folder { display: flex; align-items: center; gap: 6px; padding: 8px 10px; background: var(--bg-elevated); border-radius: 5px; font-size: 11px; margin-top: 8px; }
        .drive-folder svg { color: #4285f4; }
        
        .flow-item .drive-badge { font-size: 8px; background: rgba(66, 133, 244, 0.15); color: #4285f4; padding: 2px 5px; border-radius: 3px; margin-left: 6px; }
        .saving-indicator { display: none; align-items: center; gap: 6px; font-size: 10px; color: var(--text-muted); }
        .saving-indicator.active { display: flex; }
        .saving-indicator .spinner { width: 12px; height: 12px; border: 2px solid var(--border-subtle); border-top-color: var(--accent); border-radius: 50%; animation: spin 0.8s linear infinite; }
        
        /* Blocking save overlay */
        .save-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 10000; display: none; align-items: center; justify-content: center; flex-direction: column; gap: 16px; }
        .save-overlay.active { display: flex; }
        .save-overlay-spinner { width: 48px; height: 48px; border: 4px solid var(--border-subtle); border-top-color: var(--accent); border-radius: 50%; animation: spin 1s linear infinite; }
        .save-overlay-text { color: white; font-size: 16px; font-weight: 500; }
        .save-overlay-subtext { color: var(--text-muted); font-size: 13px; }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        /* Login Screen */
        .login-screen { position: fixed; inset: 0; background: var(--bg-primary); display: flex; align-items: center; justify-content: center; z-index: 15000; }
        .login-screen.hidden { display: none; }
        .login-box { text-align: center; max-width: 400px; padding: 40px; }
        .login-logo { font-size: 32px; font-weight: 700; margin-bottom: 8px; background: linear-gradient(135deg, var(--accent), var(--purple)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .login-subtitle { color: var(--text-muted); font-size: 14px; margin-bottom: 32px; }
        .login-btn { display: inline-flex; align-items: center; gap: 12px; padding: 14px 28px; font-family: inherit; font-size: 14px; font-weight: 500; background: white; color: #333; border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s; box-shadow: 0 2px 8px rgba(0,0,0,0.2); }
        .login-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 16px rgba(0,0,0,0.3); }
        .login-btn svg { width: 20px; height: 20px; }
        .login-error { margin-top: 20px; padding: 12px 16px; background: var(--red-dim); border: 1px solid var(--red); border-radius: 6px; color: var(--red); font-size: 12px; display: none; }
        .login-error.show { display: block; }
        .login-footer { margin-top: 40px; font-size: 11px; color: var(--text-muted); }
        .login-loading { display: none; flex-direction: column; align-items: center; gap: 12px; }
        .login-loading.show { display: flex; }
        .login-loading .spinner { width: 32px; height: 32px; border: 3px solid var(--border-subtle); border-top-color: var(--accent); border-radius: 50%; animation: spin 0.8s linear infinite; }
        .login-content { }
        .login-content.hidden { display: none; }
        
        /* Dashboard Screen */
        .dashboard-screen { position: fixed; inset: 0; background: var(--bg-primary); z-index: 9000; overflow-y: auto; display: none; }
        .dashboard-screen.show { display: block; }
        .dashboard-header { padding: 20px 30px; border-bottom: 1px solid var(--border-subtle); display: flex; align-items: center; justify-content: space-between; background: var(--bg-secondary); position: sticky; top: 0; z-index: 10; }
        .dashboard-logo { font-size: 24px; font-weight: 700; background: linear-gradient(135deg, var(--accent), var(--purple)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .dashboard-actions { display: flex; gap: 10px; }
        .dashboard-content { padding: 30px; max-width: 1600px; margin: 0 auto; }
        
        /* Metrics Grid */
        .metrics-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 16px; margin-bottom: 30px; }
        .metric-card { background: var(--bg-secondary); border: 1px solid var(--border-subtle); border-radius: 12px; padding: 20px; }
        .metric-card.accent { border-color: var(--accent); background: linear-gradient(135deg, rgba(59,130,246,0.1), rgba(139,92,246,0.05)); }
        .metric-value { font-size: 36px; font-weight: 700; margin-bottom: 4px; }
        .metric-value.blue { color: var(--accent); }
        .metric-value.green { color: var(--green); }
        .metric-value.orange { color: var(--orange); }
        .metric-value.red { color: var(--red); }
        .metric-value.purple { color: var(--purple); }
        .metric-label { font-size: 12px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; }
        .metric-sublabel { font-size: 11px; color: var(--text-muted); margin-top: 8px; }
        
        /* Environment Sections */
        .env-section { margin-bottom: 30px; }
        .env-header { display: flex; align-items: center; gap: 12px; margin-bottom: 16px; padding-bottom: 12px; border-bottom: 2px solid var(--border-subtle); }
        .env-badge { padding: 6px 14px; border-radius: 20px; font-size: 12px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; }
        .env-badge.exhibitor { background: var(--green-dim); color: var(--green); }
        .env-badge.organizer { background: var(--accent-bg); color: var(--accent); }
        .env-badge.ea { background: var(--orange-dim); color: var(--orange); }
        .env-badge.valverde { background: var(--purple-dim); color: var(--purple); }
        .env-badge.other { background: var(--bg-tertiary); color: var(--text-secondary); }
        .env-title { font-size: 18px; font-weight: 600; }
        .env-count { font-size: 12px; color: var(--text-muted); }
        
        /* Flow Map Grid */
        .flow-map { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 16px; }
        .flow-card { background: var(--bg-secondary); border: 1px solid var(--border-subtle); border-radius: 10px; padding: 16px; cursor: pointer; transition: all 0.2s; position: relative; }
        .flow-card:hover { border-color: var(--accent); transform: translateY(-2px); box-shadow: 0 8px 24px rgba(0,0,0,0.3); }
        .flow-card-header { display: flex; align-items: flex-start; justify-content: space-between; margin-bottom: 10px; }
        .flow-card-name { font-size: 14px; font-weight: 600; color: var(--text-primary); line-height: 1.3; }
        .flow-card-env { font-size: 9px; padding: 3px 8px; border-radius: 10px; font-weight: 500; }
        .flow-card-status { font-size: 9px; padding: 3px 8px; border-radius: 10px; font-weight: 500; margin-top: 6px; display: inline-block; }
        .flow-card-status.draft { background: var(--bg-tertiary); color: var(--text-muted); }
        .flow-card-status.documenting { background: var(--orange-bg); color: var(--orange); }
        .flow-card-status.ready-dev { background: var(--accent-bg); color: var(--accent); }
        .flow-card-status.in-dev { background: var(--purple-bg); color: var(--purple); }
        .flow-card-status.ready-review { background: var(--yellow-bg); color: var(--yellow); }
        .flow-card-status.approved { background: var(--green-bg); color: var(--green); }
        
        /* Editing indicator on flow cards */
        .flow-card-editing { border-color: var(--orange) !important; }
        .flow-card-editing-indicator { display: flex; align-items: center; gap: 6px; font-size: 10px; color: var(--orange); margin-top: 8px; padding: 6px 8px; background: var(--orange-bg); border-radius: 6px; }
        .flow-card-editing-indicator svg { width: 12px; height: 12px; flex-shrink: 0; }
        .flow-card-editing-indicator .editing-user { font-weight: 600; }
        .flow-card-editing-indicator .editing-time { color: var(--text-muted); }
        
        /* Conflict warning modal */
        .conflict-warning { background: var(--orange-bg); border: 1px solid var(--orange); border-radius: 8px; padding: 16px; margin-bottom: 16px; }
        .conflict-warning-title { display: flex; align-items: center; gap: 8px; font-weight: 600; color: var(--orange); margin-bottom: 8px; }
        .conflict-warning-title svg { width: 20px; height: 20px; }
        .conflict-warning-text { font-size: 13px; color: var(--text-secondary); line-height: 1.5; }
        .conflict-warning-user { font-weight: 600; color: var(--text-primary); }
        .conflict-actions { display: flex; gap: 12px; margin-top: 16px; }
        .conflict-actions .btn { flex: 1; }
        
        /* Flow status selector in header */
        .flow-status-select { font-size: 11px; padding: 4px 8px; border-radius: 6px; background: var(--bg-tertiary); border: 1px solid var(--border-subtle); color: var(--text-primary); cursor: pointer; margin-left: 8px; }
        .flow-status-select:hover { border-color: var(--accent); }
        .flow-status-select.draft { border-color: var(--text-muted); }
        .flow-status-select.documenting { border-color: var(--orange); background: var(--orange-bg); }
        .flow-status-select.ready-dev { border-color: var(--accent); background: var(--accent-bg); }
        .flow-status-select.in-dev { border-color: var(--purple); background: var(--purple-bg); }
        .flow-status-select.ready-review { border-color: var(--yellow); background: var(--yellow-bg); }
        .flow-status-select.approved { border-color: var(--green); background: var(--green-bg); }
        .flow-card-desc { font-size: 11px; color: var(--text-muted); margin-bottom: 12px; line-height: 1.4; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
        .flow-card-stats { display: flex; gap: 12px; font-size: 11px; }
        .flow-card-stat { display: flex; align-items: center; gap: 4px; color: var(--text-secondary); }
        .flow-card-stat.issues { color: var(--red); }
        .flow-card-stat.fixes { color: var(--green); }
        .flow-card-stat svg { width: 12px; height: 12px; }
        .flow-card-date { font-size: 10px; color: var(--text-muted); margin-top: 10px; padding-top: 10px; border-top: 1px solid var(--border-subtle); }
        .flow-card-badges { display: flex; gap: 6px; margin-top: 10px; flex-wrap: wrap; }
        .flow-card-badge { font-size: 9px; padding: 2px 6px; border-radius: 4px; background: var(--bg-tertiary); color: var(--text-muted); }
        
        /* Add Flow Card */
        .flow-card.add-new { border-style: dashed; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 140px; color: var(--text-muted); }
        .flow-card.add-new:hover { color: var(--accent); border-color: var(--accent); background: var(--accent-bg); }
        .flow-card.add-new svg { width: 32px; height: 32px; margin-bottom: 8px; }
        .flow-card.add-new span { font-size: 13px; font-weight: 500; }
        
        /* Empty State */
        .env-empty { padding: 30px; text-align: center; color: var(--text-muted); font-size: 13px; background: var(--bg-tertiary); border-radius: 8px; border: 1px dashed var(--border-default); }
        
        /* Flow Settings Modal */
        .flow-settings-grid { display: grid; gap: 16px; }
        .flow-settings-row { display: grid; grid-template-columns: 100px 1fr; align-items: start; gap: 12px; }
        .flow-settings-row label { font-size: 12px; color: var(--text-secondary); padding-top: 8px; }
        
        /* Attachments */
        .attachments-section { margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border-subtle); }
        .attachments-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; }
        .attachments-title { font-size: 11px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; }
        .attachment-add-btn { padding: 4px 8px; font-size: 10px; background: var(--bg-tertiary); border: 1px solid var(--border-subtle); border-radius: 4px; color: var(--text-secondary); cursor: pointer; }
        .attachment-add-btn:hover { background: var(--bg-elevated); color: var(--text-primary); }
        .attachments-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 8px; }
        .attachment-item { position: relative; aspect-ratio: 1; border-radius: 6px; overflow: hidden; border: 1px solid var(--border-subtle); cursor: pointer; }
        .attachment-item img { width: 100%; height: 100%; object-fit: cover; }
        .attachment-item:hover .attachment-overlay { opacity: 1; }
        .attachment-overlay { position: absolute; inset: 0; background: rgba(0,0,0,0.6); display: flex; align-items: center; justify-content: center; gap: 8px; opacity: 0; transition: opacity 0.2s; }
        .attachment-btn { padding: 4px; background: var(--bg-secondary); border-radius: 4px; border: none; cursor: pointer; color: var(--text-primary); }
        .attachment-btn:hover { background: var(--accent); }
        .attachment-btn.danger:hover { background: var(--red); }
        .attachment-placeholder { display: flex; align-items: center; justify-content: center; aspect-ratio: 1; border: 2px dashed var(--border-subtle); border-radius: 6px; color: var(--text-muted); font-size: 10px; cursor: pointer; }
        .attachment-placeholder:hover { border-color: var(--accent); color: var(--accent); }
        
        /* Cross-flow links */
        .crossflow-section { margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border-subtle); }
        .crossflow-link { display: flex; align-items: center; gap: 8px; padding: 6px 8px; background: var(--bg-tertiary); border-radius: 4px; margin-bottom: 6px; font-size: 11px; }
        .crossflow-link-icon { color: var(--accent); }
        .crossflow-link-name { flex: 1; color: var(--text-primary); cursor: pointer; }
        .crossflow-link-name:hover { text-decoration: underline; }
        .crossflow-link-remove { padding: 2px; color: var(--text-muted); cursor: pointer; }
        .crossflow-link-remove:hover { color: var(--red); }
        
        /* Block list drag */
        .block-list-item.dragging { opacity: 0.5; background: var(--accent-bg); }
        .block-list-item.drag-over { border-top: 2px solid var(--accent); }
        
        /* Auto-layout button */
        .auto-layout-btn { padding: 4px 8px; font-size: 10px; background: var(--bg-tertiary); border: 1px solid var(--border-subtle); border-radius: 4px; color: var(--text-secondary); cursor: pointer; display: flex; align-items: center; gap: 4px; }
        .auto-layout-btn:hover { background: var(--accent); color: white; border-color: var(--accent); }
        
        /* Flow card actions */
        .flow-card-actions { position: absolute; top: 8px; right: 8px; display: flex; gap: 4px; opacity: 0; transition: opacity 0.2s; }
        
        /* ===== PROJECT BRIEFS ===== */
        .dashboard-section { margin-bottom: 40px; }
        .dashboard-section-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid var(--border-subtle); }
        .dashboard-section-title { font-size: 16px; font-weight: 600; color: var(--text-primary); display: flex; align-items: center; gap: 8px; }
        .dashboard-section-title svg { width: 20px; height: 20px; color: var(--accent); }
        .dashboard-section-count { font-size: 12px; color: var(--text-muted); background: var(--bg-tertiary); padding: 2px 8px; border-radius: 10px; }
        
        /* Brief Cards */
        .brief-card { background: var(--bg-secondary); border: 1px solid var(--border-subtle); border-radius: 10px; padding: 16px; cursor: pointer; transition: all 0.2s; position: relative; border-left: 3px solid var(--purple); }
        .brief-card:hover { border-color: var(--purple); transform: translateY(-2px); box-shadow: 0 8px 24px rgba(0,0,0,0.3); }
        .brief-card-header { display: flex; align-items: flex-start; justify-content: space-between; margin-bottom: 8px; }
        .brief-card-name { font-size: 14px; font-weight: 600; color: var(--text-primary); line-height: 1.3; }
        .brief-card-status { font-size: 9px; padding: 3px 8px; border-radius: 10px; font-weight: 500; text-transform: uppercase; }
        .brief-card-status.draft { background: var(--bg-tertiary); color: var(--text-muted); }
        .brief-card-status.agreed { background: var(--green-bg); color: var(--green); }
        .brief-card-status.in-progress { background: var(--accent-bg); color: var(--accent); }
        .brief-card-status.validating { background: var(--orange-bg); color: var(--orange); }
        .brief-card-status.complete { background: var(--purple-bg); color: var(--purple); }
        .brief-card-problem { font-size: 11px; color: var(--text-muted); margin-bottom: 10px; line-height: 1.4; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
        .brief-card-meta { display: flex; gap: 12px; font-size: 10px; color: var(--text-muted); flex-wrap: wrap; }
        .brief-card-meta-item { display: flex; align-items: center; gap: 4px; }
        .brief-card-meta-item svg { width: 12px; height: 12px; }
        .brief-card-flows { margin-top: 10px; padding-top: 10px; border-top: 1px solid var(--border-subtle); }
        .brief-card-flows-label { font-size: 9px; color: var(--text-muted); text-transform: uppercase; margin-bottom: 6px; }
        .brief-card-flow-links { display: flex; flex-wrap: wrap; gap: 4px; }
        .brief-card-flow-link { font-size: 10px; padding: 2px 6px; background: var(--bg-tertiary); border-radius: 4px; color: var(--text-secondary); }
        
        .brief-card.add-new { border-style: dashed; border-left-width: 1px; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 120px; color: var(--text-muted); }
        .brief-card.add-new:hover { color: var(--purple); border-color: var(--purple); background: var(--purple-bg); }
        .brief-card.add-new svg { width: 28px; height: 28px; margin-bottom: 8px; }
        .brief-card.add-new span { font-size: 12px; font-weight: 500; }
        
        /* Brief Modal */
        .brief-editor { display: grid; gap: 16px; }
        .brief-section { background: var(--bg-tertiary); border-radius: 8px; padding: 12px; }
        .brief-section-header { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; font-size: 11px; font-weight: 600; color: var(--text-secondary); text-transform: uppercase; }
        .brief-section-header svg { width: 14px; height: 14px; }
        .brief-participants { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px; }
        .brief-participant { display: flex; align-items: center; gap: 4px; padding: 4px 10px; background: var(--bg-secondary); border-radius: 15px; font-size: 11px; }
        .brief-participant-role { font-size: 9px; color: var(--text-muted); }
        .brief-participant-remove { cursor: pointer; color: var(--text-muted); margin-left: 4px; }
        .brief-participant-remove:hover { color: var(--red); }
        .brief-criteria-list { display: flex; flex-direction: column; gap: 6px; }
        .brief-criteria-item { display: flex; align-items: flex-start; gap: 8px; padding: 8px; background: var(--bg-secondary); border-radius: 6px; }
        .brief-criteria-checkbox { width: 16px; height: 16px; border: 2px solid var(--border-default); border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; flex-shrink: 0; margin-top: 2px; }
        .brief-criteria-checkbox.checked { background: var(--green); border-color: var(--green); }
        .brief-criteria-checkbox svg { width: 10px; height: 10px; color: white; display: none; }
        .brief-criteria-checkbox.checked svg { display: block; }
        .brief-criteria-text { flex: 1; font-size: 12px; color: var(--text-primary); }
        .brief-criteria-text.checked { text-decoration: line-through; color: var(--text-muted); }
        .brief-criteria-remove { color: var(--text-muted); cursor: pointer; }
        .brief-criteria-remove:hover { color: var(--red); }
        .brief-linked-flows { display: flex; flex-direction: column; gap: 6px; }
        .brief-linked-flow { display: flex; align-items: center; gap: 8px; padding: 8px 10px; background: var(--bg-secondary); border-radius: 6px; cursor: pointer; }
        .brief-linked-flow:hover { background: var(--bg-hover); }
        .brief-linked-flow-dot { width: 8px; height: 8px; border-radius: 50%; }
        .brief-linked-flow-name { flex: 1; font-size: 12px; color: var(--text-primary); }
        .brief-linked-flow-unlink { color: var(--text-muted); font-size: 10px; }
        .brief-linked-flow-unlink:hover { color: var(--red); }
        .brief-add-btn { display: flex; align-items: center; gap: 6px; padding: 8px 12px; background: var(--bg-secondary); border: 1px dashed var(--border-default); border-radius: 6px; color: var(--text-muted); font-size: 11px; cursor: pointer; transition: all 0.2s; }
        .brief-add-btn:hover { border-color: var(--accent); color: var(--accent); background: var(--accent-bg); }
        .brief-add-btn svg { width: 12px; height: 12px; }
        
        /* Brief Reference in Flow Sidebar - Expanded */
        .brief-reference { background: linear-gradient(135deg, var(--purple-bg), var(--bg-tertiary)); border: 1px solid var(--purple); border-radius: 8px; padding: 12px; }
        .brief-reference-header { display: flex; align-items: center; gap: 6px; font-size: 11px; font-weight: 600; color: var(--purple); margin-bottom: 8px; }
        .brief-reference-header svg { width: 14px; height: 14px; }
        .brief-reference-name { font-size: 13px; font-weight: 600; color: var(--text-primary); margin-bottom: 8px; cursor: pointer; }
        .brief-reference-name:hover { text-decoration: underline; }
        .brief-reference-status { font-size: 9px; padding: 2px 6px; border-radius: 8px; font-weight: 500; display: inline-block; margin-bottom: 10px; }
        .brief-reference-status.draft { background: var(--bg-tertiary); color: var(--text-muted); }
        .brief-reference-status.agreed { background: var(--green-bg); color: var(--green); }
        .brief-reference-status.in-progress { background: var(--accent-bg); color: var(--accent); }
        .brief-reference-status.validating { background: var(--orange-bg); color: var(--orange); }
        .brief-reference-status.complete { background: var(--purple-bg); color: var(--purple); }
        .brief-reference-section { margin-bottom: 10px; }
        .brief-reference-section-title { font-size: 9px; font-weight: 600; color: var(--text-muted); text-transform: uppercase; margin-bottom: 4px; }
        .brief-reference-section-content { font-size: 11px; color: var(--text-secondary); line-height: 1.4; }
        .brief-reference-solution { white-space: pre-wrap; }
        .brief-reference-criteria { font-size: 10px; color: var(--text-muted); margin-bottom: 4px; }
        .brief-reference-progress { height: 4px; background: var(--bg-secondary); border-radius: 2px; margin-bottom: 8px; overflow: hidden; }
        .brief-reference-progress-bar { height: 100%; background: var(--green); border-radius: 2px; transition: width 0.3s; }
        .brief-criteria-mini { display: flex; flex-direction: column; gap: 4px; max-height: 150px; overflow-y: auto; }
        .brief-criteria-mini-item { display: flex; align-items: flex-start; gap: 6px; font-size: 10px; padding: 4px 6px; background: var(--bg-secondary); border-radius: 4px; }
        .brief-criteria-mini-check { width: 12px; height: 12px; border: 1.5px solid var(--border-default); border-radius: 3px; flex-shrink: 0; margin-top: 1px; display: flex; align-items: center; justify-content: center; cursor: pointer; }
        .brief-criteria-mini-check.checked { background: var(--green); border-color: var(--green); }
        .brief-criteria-mini-check svg { width: 8px; height: 8px; color: white; display: none; }
        .brief-criteria-mini-check.checked svg { display: block; }
        .brief-criteria-mini-text { color: var(--text-secondary); line-height: 1.3; }
        .brief-criteria-mini-text.checked { text-decoration: line-through; color: var(--text-muted); }
        .brief-reference-edit { margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--border-subtle); }
        .brief-reference-edit-btn { font-size: 10px; color: var(--purple); cursor: pointer; display: flex; align-items: center; gap: 4px; }
        .brief-reference-edit-btn:hover { text-decoration: underline; }
        .brief-reference-edit-btn svg { width: 12px; height: 12px; }
        .flow-card:hover .flow-card-actions { opacity: 1; }
        .flow-card-action { padding: 4px; background: var(--bg-secondary); border: 1px solid var(--border-subtle); border-radius: 4px; cursor: pointer; color: var(--text-muted); }
        .flow-card-action:hover { background: var(--accent); color: white; border-color: var(--accent); }
        .flow-card-action.danger:hover { background: var(--red); border-color: var(--red); }
        
        /* Image viewer modal */
        .image-viewer { position: fixed; inset: 0; background: rgba(0,0,0,0.9); display: none; align-items: center; justify-content: center; z-index: 20000; cursor: zoom-out; }
        .image-viewer.show { display: flex; }
        .image-viewer img { max-width: 90vw; max-height: 90vh; object-fit: contain; }
        
        /* Block Search */
        .block-search-container { display: flex; align-items: center; gap: 6px; padding: 4px 10px; background: var(--bg-tertiary); border: 1px solid var(--border-subtle); border-radius: 6px; }
        .block-search-container svg { color: var(--text-muted); flex-shrink: 0; }
        .block-search-input { background: transparent; border: none; outline: none; color: var(--text-primary); font-size: 12px; width: 150px; }
        .block-search-input::placeholder { color: var(--text-muted); }
        
        /* Multi-select */
        .block.multi-selected { outline: 2px solid var(--cyan); outline-offset: 2px; }
        .selection-box { position: absolute; border: 1px dashed var(--accent); background: rgba(59, 130, 246, 0.1); pointer-events: none; z-index: 100; }
        
        /* Block highlight from search */
        .block.search-highlight { animation: searchPulse 1s ease 2; }
        @keyframes searchPulse { 0%, 100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0); } 50% { box-shadow: 0 0 0 8px rgba(59, 130, 246, 0.4); } }
        
        /* Attachments */
        .block-attachments { display: flex; gap: 4px; flex-wrap: wrap; margin-top: 6px; }
        .block-attachment { width: 32px; height: 32px; border-radius: 4px; overflow: hidden; border: 1px solid var(--border-subtle); cursor: pointer; position: relative; }
        .block-attachment img { width: 100%; height: 100%; object-fit: cover; }
        .block-attachment:hover .attachment-remove { opacity: 1; }
        .attachment-remove { position: absolute; top: -4px; right: -4px; width: 14px; height: 14px; background: var(--red); border-radius: 50%; display: flex; align-items: center; justify-content: center; opacity: 0; transition: opacity 0.15s; cursor: pointer; }
        .attachment-remove svg { width: 8px; height: 8px; color: white; }
        .attachment-add { display: flex; align-items: center; justify-content: center; background: var(--bg-tertiary); color: var(--text-muted); }
        .attachment-add:hover { background: var(--bg-elevated); color: var(--accent); }
        
        /* Attachment preview modal */
        .attachment-preview { position: fixed; inset: 0; background: rgba(0,0,0,0.9); z-index: 20000; display: none; align-items: center; justify-content: center; cursor: zoom-out; }
        .attachment-preview.show { display: flex; }
        .attachment-preview img { max-width: 90%; max-height: 90%; object-fit: contain; border-radius: 8px; }
        
        /* Cross-flow links */
        .cross-flow-link { display: flex; align-items: center; gap: 6px; padding: 6px 10px; background: var(--bg-tertiary); border-radius: 6px; font-size: 11px; cursor: pointer; transition: all 0.15s; }
        .cross-flow-link:hover { background: var(--bg-elevated); }
        .cross-flow-link svg { width: 12px; height: 12px; color: var(--accent); }
        
        /* Auto-layout button */
        .auto-layout-btn { position: absolute; bottom: 10px; left: 10px; z-index: 10; }
        
        /* Sortable blocks in sidebar */
        .block-list-item.dragging { opacity: 0.5; }
        .block-list-item.drag-over { border-top: 2px solid var(--accent); }
        
        /* Button icon style */
        .btn-icon { padding: 6px; min-width: auto; }
        .btn-icon svg { margin: 0; }
</style>
</head>
<body>
    <!-- Login Screen - blocks app until authenticated -->
    <div class="login-screen" id="loginScreen">
        <div class="login-box">
            <div class="login-logo">FlowBuilder Pro</div>
            <div class="login-subtitle">Process Analysis & Documentation Tool</div>
            <div class="login-content" id="loginContent">
                <button class="login-btn" id="loginBtn">
                    <svg viewBox="0 0 24 24"><path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/><path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg>
                    Sign in with Google
                </button>
                <div class="login-error" id="loginError">Access denied. You are not authorized to use this app.</div>
            </div>
            <div class="login-loading" id="loginLoading">
                <div class="spinner"></div>
                <span class="login-loading-text" style="color: var(--text-muted); font-size: 14px;">Signing in...</span>
                <div class="login-loading-progress" style="display: none; width: 200px; margin-top: 12px;">
                    <div style="height: 4px; background: var(--border-subtle); border-radius: 2px; overflow: hidden;">
                        <div class="login-progress-bar" style="height: 100%; background: var(--accent); width: 0%; transition: width 0.3s ease;"></div>
                    </div>
                    <div class="login-loading-detail" style="margin-top: 8px; font-size: 11px; color: var(--text-muted); text-align: center;"></div>
                </div>
            </div>
            <div class="login-footer">Only authorized team members can access this tool.</div>
        </div>
    </div>
    
    <!-- Dashboard Screen -->
    <div class="dashboard-screen" id="dashboardScreen">
        <div class="dashboard-header">
            <div class="dashboard-logo">FlowBuilder Pro</div>
            <div style="flex:1; display:flex; justify-content:center;">
                <input type="text" class="form-input" id="dashboardSearch" placeholder="Search briefs & flows..." style="max-width:400px; width:100%;" />
            </div>
            <div class="dashboard-actions">
                <button class="btn" id="importDashBtn"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>Import Flow</button>
                <button class="btn" id="importBriefDashBtn" style="border-color:var(--purple);color:var(--purple);"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>Import Brief</button>
                <button class="btn" id="newBriefDashBtn" style="border-color:var(--purple);color:var(--purple);"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="12" y1="11" x2="12" y2="17"/><line x1="9" y1="14" x2="15" y2="14"/></svg>New Brief</button>
                <button class="btn btn-primary" id="newFlowDashBtn"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>New Flow</button>
                <button class="btn" id="refreshDashBtn"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14"><polyline points="23 4 23 10 17 10"/><path d="M20.49 15a9 9 0 11-2.12-9.36L23 10"/></svg>Refresh</button>
            </div>
        </div>
        <div class="dashboard-content">
            <div class="metrics-grid" id="metricsGrid"></div>
            <div id="flowMapContainer"></div>
        </div>
    </div>
    
    <div class="app" id="mainApp" style="display:none;">
        <header class="header">
            <div class="logo" id="backToDashboard" style="cursor:pointer;" title="Back to Dashboard">
                <div class="logo-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" width="16" height="16"><path d="M12 3L4 9v12h16V9l-8-6z"/><path d="M9 14l2 2 4-4"/></svg></div>
                <span class="logo-text">FlowBuilder</span>
            </div>
            <div class="header-divider"></div>
            
            <!-- Mode toggle -->
            <div class="mode-toggle" id="modeToggle">
                <button class="mode-btn active" id="sketchModeBtn" title="Sketch: Quick flow capture">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/></svg>
                    Sketch
                </button>
                <button class="mode-btn" id="configureModeBtn" title="Configure: Add types and connections">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M12 1v4M12 19v4M4.22 4.22l2.83 2.83M16.95 16.95l2.83 2.83M1 12h4M19 12h4M4.22 19.78l2.83-2.83M16.95 7.05l2.83-2.83"/></svg>
                    Configure
                </button>
                <button class="mode-btn" id="detailModeBtn" title="Detail: Full documentation">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><path d="M14 2v6h6"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/></svg>
                    Detail
                </button>
                <div class="mode-divider"></div>
                <button class="mode-btn dev-mode-btn" id="devModeBtn" title="Dev Mode: Show all fields at once">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg>
                    Dev
                </button>
            </div>
            <div class="header-divider"></div>
            
            <!-- Flow info - centered -->
            <div class="header-flow">
                <button class="flow-title-btn" id="flowSelector" title="Click to change flow">
                    <span id="currentFlowName">Select analysis...</span>
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="12" height="12"><polyline points="6 9 12 15 18 9"/></svg>
                </button>
                <span class="env-badge" id="envBadge"></span>
                <select class="form-input flow-status-select" id="flowStatusSelector" style="display:none;">
                    <option value="draft"> Draft</option>
                    <option value="documenting"> Documenting</option>
                    <option value="ready-dev"> Ready for Dev</option>
                    <option value="in-dev"> In Development</option>
                    <option value="ready-review"> Ready for Review</option>
                    <option value="approved"> Approved</option>
                </select>
            </div>
            
            <div class="header-spacer"></div>
            
            <!-- Simplified actions -->
            <div class="header-actions">
                <button class="icon-btn" id="toggleSidebarBtn" title="Toggle Sidebar (left)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><line x1="9" y1="3" x2="9" y2="21"/></svg></button>
                <button class="icon-btn" id="togglePanelHeaderBtn" title="Toggle Panel (right)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><line x1="15" y1="3" x2="15" y2="21"/></svg></button>
                <div class="header-divider"></div>
                <button class="icon-btn" id="undoBtn" title="Undo (Ctrl+Z)" disabled><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 10h10a5 5 0 015 5v2"/><polyline points="3 10 7 6"/><polyline points="3 10 7 14"/></svg></button>
                <button class="icon-btn" id="redoBtn" title="Redo (Ctrl+Y)" disabled><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 10H11a5 5 0 00-5 5v2"/><polyline points="21 10 17 6"/><polyline points="21 10 17 14"/></svg></button>
                <div class="header-divider"></div>
                <button class="icon-btn" id="flowSettingsBtn" title="Flow Settings" style="display:none;"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 010 2.83 2 2 0 01-2.83 0l-.06-.06a1.65 1.65 0 00-1.82-.33 1.65 1.65 0 00-1 1.51V21a2 2 0 01-2 2 2 2 0 01-2-2v-.09A1.65 1.65 0 009 19.4a1.65 1.65 0 00-1.82.33l-.06.06a2 2 0 01-2.83 0 2 2 0 010-2.83l.06-.06a1.65 1.65 0 00.33-1.82 1.65 1.65 0 00-1.51-1H3a2 2 0 01-2-2 2 2 0 012-2h.09A1.65 1.65 0 004.6 9a1.65 1.65 0 00-.33-1.82l-.06-.06a2 2 0 010-2.83 2 2 0 012.83 0l.06.06a1.65 1.65 0 001.82.33H9a1.65 1.65 0 001-1.51V3a2 2 0 012-2 2 2 0 012 2v.09a1.65 1.65 0 001 1.51 1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 0 2 2 0 010 2.83l-.06.06a1.65 1.65 0 00-.33 1.82V9a1.65 1.65 0 001.51 1H21a2 2 0 012 2 2 2 0 01-2 2h-.09a1.65 1.65 0 00-1.51 1z"/></svg></button>
                <button class="icon-btn" id="duplicateFlowBtn" title="Duplicate Flow" style="display:none;"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"/></svg></button>
                <button class="icon-btn" id="exportBtn" title="Export"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg></button>
                <button class="icon-btn" id="helpBtn" title="Help & Shortcuts"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 015.83 1c0 2-3 3-3 3"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg></button>
                <div class="header-divider"></div>
                <div class="view-toggle-header">
                    <button class="view-btn-sm" id="viewCurrentBtn" title="Current State Only"><span class="dot current"></span></button>
                    <button class="view-btn-sm active" id="viewSplitBtn" title="Split View"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14"><rect x="3" y="3" width="18" height="18" rx="2"/><line x1="12" y1="3" x2="12" y2="21"/></svg></button>
                    <button class="view-btn-sm" id="viewProposedBtn" title="Proposed State Only"><span class="dot proposed"></span></button>
                </div>
                <div class="header-divider"></div>
                <button class="btn btn-primary" id="saveBtn"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21H5a2 2 0 01-2-2V5a2 2 0 012-2h11l5 5v11a2 2 0 01-2 2z"/></svg>Save</button>
                <div class="google-auth" id="googleAuth">
                    <img class="user-avatar" id="googleUserPhoto" title="Account" />
                </div>
            </div>
            <!-- Hidden elements for compatibility -->
            <select class="form-input" id="flowEnvSelector" style="display:none;">
                <option value="exhibitor">Exhibitor</option>
                <option value="organizer">Organizer</option>
                <option value="ea">EA Exhibitions</option>
                <option value="valverde">Valverde</option>
                <option value="other">Other</option>
            </select>
            <input type="hidden" id="blockSearchInput" />
        </header>
        <main class="main">
            <aside class="sidebar-left" id="sidebarLeft">
                <!-- Brief Reference -->
                <div id="briefReference" style="padding:12px;display:none;border-bottom:1px solid var(--border-subtle);"></div>
                
                <!-- Search header -->
                <div class="sidebar-header">
                    <div class="sidebar-search">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><path d="M21 21l-4.35-4.35"/></svg>
                        <input type="text" id="searchInput" placeholder="Search steps... (Ctrl+F)" />
                    </div>
                </div>
                
                <!-- Block list - main content -->
                <div class="block-list-container">
                    <div class="block-list" id="blockList"></div>
                </div>
                
                <!-- Accordion: Validation -->
                <div class="sidebar-accordion" id="validationAccordion">
                    <div class="accordion-header">
                        <span class="accordion-title">Validation</span>
                        <span class="validation-badge" id="validationBadge"></span>
                        <svg class="accordion-chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg>
                    </div>
                    <div class="accordion-body">
                        <div class="accordion-content">
                            <div class="validation-list" id="validationList"></div>
                        </div>
                    </div>
                </div>
            </aside>
            
            <div class="canvas-wrapper">
                <div class="canvas-split" id="canvasSplit">
                <div class="canvas-pane" id="currentPane">
                    <div class="pane-header">
                        <div class="pane-title"><span class="pane-indicator current"></span>Current State</div>
                        <div class="pane-actions">
                            <button class="pane-btn" id="addCurrentHelperBtn" title="Add helper text annotation"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15a2 2 0 01-2 2H7l-4 4V5a2 2 0 012-2h14a2 2 0 012 2z"/></svg>Note</button>
                            <button class="pane-btn primary" id="addCurrentBlockBtn"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>Add Step</button>
                        </div>
                    </div>
                    <div class="canvas-area" id="currentCanvasArea">
                        <div class="canvas-container"><div class="canvas" id="currentCanvas"><svg class="canvas-svg" id="currentConnectionsSvg"></svg><div id="currentBlocksContainer"></div></div></div>
                        <div class="canvas-instructions" id="currentInstructions"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="3" y="3" width="18" height="18" rx="2"/><path d="M12 8v8M8 12h8"/></svg><p>Add steps to document<br/>the current process</p></div>
                        <div class="zoom-controls">
                                <button class="zoom-btn" data-action="out" title="Zoom Out"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><line x1="8" y1="11" x2="14" y2="11"/></svg></button>
                                <span class="zoom-level" id="currentZoomLevel">100%</span>
                                <button class="zoom-btn" data-action="in" title="Zoom In"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/></svg></button>
                                <button class="zoom-btn" data-action="fit" title="Fit to View"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M8 3H5a2 2 0 00-2 2v3m18 0V5a2 2 0 00-2-2h-3m0 18h3a2 2 0 002-2v-3M3 16v3a2 2 0 002 2h3"/></svg></button>
                                <button class="zoom-btn" data-action="snap-grid" title="Snap all to Grid"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 3v18h18"/><circle cx="9" cy="9" r="2"/><circle cx="15" cy="15" r="2"/><circle cx="9" cy="15" r="2"/><circle cx="15" cy="9" r="2"/></svg></button>
                                <button class="zoom-btn" data-action="auto-layout" title="Auto-layout"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/></svg></button>
                            </div>
                            <div class="actor-legend">
                                <div class="actor-legend-item"><div class="actor-legend-dot user"></div>User</div>
                                <div class="actor-legend-item"><div class="actor-legend-dot system"></div>System</div>
                            </div>
                    </div>
                </div>
                <div class="canvas-pane" id="proposedPane">
                    <div class="pane-header">
                        <div class="pane-title"><span class="pane-indicator proposed"></span>Proposed State</div>
                        <div class="pane-actions">
                            <button class="pane-btn" id="promoteToCurrentBtn" title="Promote: Replace current state with proposed"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 19V5M5 12l7-7 7 7"/></svg></button>
                            <button class="pane-btn" id="copyFromCurrentBtn" title="Copy all blocks from current state"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"/></svg>Copy</button>
                            <button class="pane-btn" id="addProposedHelperBtn" title="Add helper text annotation"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15a2 2 0 01-2 2H7l-4 4V5a2 2 0 012-2h14a2 2 0 012 2z"/></svg>Note</button>
                            <button class="pane-btn primary" id="addProposedBlockBtn"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>Add Step</button>
                        </div>
                    </div>
                    <div class="canvas-area" id="proposedCanvasArea">
                        <div class="canvas-container"><div class="canvas" id="proposedCanvas"><svg class="canvas-svg" id="proposedConnectionsSvg"></svg><div id="proposedBlocksContainer"></div></div></div>
                        <div class="canvas-instructions" id="proposedInstructions"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="3" y="3" width="18" height="18" rx="2"/><path d="M12 8v8M8 12h8"/></svg><p>Copy from current or build<br/>the improved process</p></div>
                        <div class="zoom-controls">
                                <button class="zoom-btn" data-action="out" title="Zoom Out"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><line x1="8" y1="11" x2="14" y2="11"/></svg></button>
                                <span class="zoom-level" id="proposedZoomLevel">100%</span>
                                <button class="zoom-btn" data-action="in" title="Zoom In"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/></svg></button>
                                <button class="zoom-btn" data-action="fit" title="Fit to View"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M8 3H5a2 2 0 00-2 2v3m18 0V5a2 2 0 00-2-2h-3m0 18h3a2 2 0 002-2v-3M3 16v3a2 2 0 002 2h3"/></svg></button>
                                <button class="zoom-btn" data-action="snap-grid" title="Snap all to Grid"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 3v18h18"/><circle cx="9" cy="9" r="2"/><circle cx="15" cy="15" r="2"/><circle cx="9" cy="15" r="2"/><circle cx="15" cy="9" r="2"/></svg></button>
                                <button class="zoom-btn" data-action="auto-layout" title="Auto-layout"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/></svg></button>
                            </div>
                            <div class="actor-legend">
                                <div class="actor-legend-item"><div class="actor-legend-dot user"></div>User</div>
                                <div class="actor-legend-item"><div class="actor-legend-dot system"></div>System</div>
                            </div>
                    </div>
                </div>
                </div>
            </div>
            <aside class="panel" id="panel">
                <div class="panel-header-bar">
                    <div class="panel-tabs">
                        <button class="panel-tab active" data-tab="details">Details</button>
                        <button class="panel-tab" data-tab="comments">Comments</button>
                        <button class="panel-tab" data-tab="history">History</button>
                    </div>
                    <button class="icon-btn" id="togglePanelBtn" title="Toggle Panel"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><line x1="15" y1="3" x2="15" y2="21"/></svg></button>
                </div>
                <div class="panel-content" id="panelContent"></div>
            </aside>
        </main>
    </div>
    <div class="modal-overlay" id="flowModal"><div class="modal"><div class="modal-header"><span class="modal-title">Process Analyses</span><button class="modal-close" id="closeFlowModal"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button></div><div class="modal-body"><div id="localFlowsSection"><div class="form-group"><label class="form-label">Create New</label><div class="form-row" style="gap:8px;"><input type="text" class="form-input" id="newFlowName" placeholder="Process name..." style="flex:2;" /><select class="form-input" id="newFlowEnv" style="flex:1;"><option value="exhibitor"> Exhibitor</option><option value="organizer"> Organizer</option><option value="ea"> EA Exhibitions</option><option value="valverde"> Valverde</option><option value="other"> Other</option></select><button class="btn btn-primary" id="createFlowBtn" style="flex-shrink:0;">Create</button></div></div><div class="section-divider"><div class="section-title">Templates</div><div class="template-grid" id="templateGrid"></div></div><div class="section-divider"><div class="section-title">Recent (Google Drive)</div><div class="flow-list" id="flowList"></div></div></div></div><div class="modal-footer"><span class="saving-indicator" id="savingIndicator"><span class="spinner"></span>Saving...</span><button class="btn" id="importFlowBtn"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>Import</button></div></div></div>
    <div class="modal-overlay" id="exportModal"><div class="modal lg"><div class="modal-header"><span class="modal-title">Export Analysis</span><button class="modal-close" id="closeExportModal"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button></div><div class="modal-body">
        <div class="section-title">PDF Export</div>
        <div class="export-options">
            <div class="export-option" data-export="pdf-current"><div class="export-option-icon" style="background:var(--orange-bg);"><svg viewBox="0 0 24 24" fill="none" stroke="var(--orange)" stroke-width="2"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/></svg></div><div class="export-option-info"><div class="export-option-name">Current State (PDF)</div><div class="export-option-desc">Export the AS-IS process flow</div></div></div>
            <div class="export-option" data-export="pdf-proposed"><div class="export-option-icon" style="background:var(--green-bg);"><svg viewBox="0 0 24 24" fill="none" stroke="var(--green)" stroke-width="2"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/></svg></div><div class="export-option-info"><div class="export-option-name">Proposed State (PDF)</div><div class="export-option-desc">Export the TO-BE process flow</div></div></div>
            <div class="export-option" data-export="pdf-comparison"><div class="export-option-icon" style="background:var(--accent-bg);"><svg viewBox="0 0 24 24" fill="none" stroke="var(--accent)" stroke-width="2"><rect x="2" y="3" width="8" height="18" rx="1"/><rect x="14" y="3" width="8" height="18" rx="1"/></svg></div><div class="export-option-info"><div class="export-option-name">Comparison (PDF)</div><div class="export-option-desc">Both flows side by side with change summary</div></div></div>
        </div>
        <div class="section-divider"><div class="section-title">Data Export</div></div>
        <div class="export-options">
            <div class="export-option" data-export="json"><div class="export-option-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/></svg></div><div class="export-option-info"><div class="export-option-name">JSON Data</div><div class="export-option-desc">Full data export for backup or import</div></div></div>
            <div class="export-option" data-export="report"><div class="export-option-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/></svg></div><div class="export-option-info"><div class="export-option-name">Change Report (HTML)</div><div class="export-option-desc">Detailed report of all issues and fixes</div></div></div>
            <div class="export-option" data-export="summary"><div class="export-option-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><line x1="3" y1="9" x2="21" y2="9"/><line x1="9" y1="21" x2="9" y2="9"/></svg></div><div class="export-option-info"><div class="export-option-name">Executive Summary</div><div class="export-option-desc">High-level overview for stakeholders</div></div></div>
        </div>
        <div class="section-divider"><div class="section-title">Visual Export (PNG)</div></div>
        <div class="export-options">
            <div class="export-option" data-export="png-current"><div class="export-option-icon" style="background:var(--orange-bg);"><svg viewBox="0 0 24 24" fill="none" stroke="var(--orange)" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><path d="M21 15l-5-5L5 21"/></svg></div><div class="export-option-info"><div class="export-option-name">Current Flow (PNG)</div><div class="export-option-desc">Visual snapshot of the AS-IS flow canvas</div></div></div>
            <div class="export-option" data-export="png-proposed"><div class="export-option-icon" style="background:var(--green-bg);"><svg viewBox="0 0 24 24" fill="none" stroke="var(--green)" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><path d="M21 15l-5-5L5 21"/></svg></div><div class="export-option-info"><div class="export-option-name">Proposed Flow (PNG)</div><div class="export-option-desc">Visual snapshot of the TO-BE flow canvas</div></div></div>
            <div class="export-option" data-export="png-both"><div class="export-option-icon" style="background:var(--accent-bg);"><svg viewBox="0 0 24 24" fill="none" stroke="var(--accent)" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><path d="M21 15l-5-5L5 21"/></svg></div><div class="export-option-info"><div class="export-option-name">Both Flows (PNG)</div><div class="export-option-desc">Side-by-side visual of both canvases</div></div></div>
        </div>
    </div></div></div>
    <div class="modal-overlay" id="validationModal"><div class="modal lg"><div class="modal-header"><span class="modal-title">Validation Results</span><button class="modal-close" id="closeValidationModal"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button></div><div class="modal-body" id="validationModalBody"></div></div></div>
    <div class="modal-overlay" id="importModal"><div class="modal lg"><div class="modal-header"><span class="modal-title">Import Analysis</span><button class="modal-close" id="closeImportModal"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button></div><div class="modal-body" id="importModalBody"></div><div class="modal-footer" id="importModalFooter"></div></div></div>
    <div class="modal-overlay" id="helpModal"><div class="modal xl"><div class="modal-header"><span class="modal-title">FlowBuilder Pro - User Guide</span><button class="modal-close" id="closeHelpModal"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button></div><div class="modal-body help-content">
        <div class="help-tabs">
            <button class="help-tab active" data-help="guide">User Guide</button>
            <button class="help-tab" data-help="import">Import Format</button>
            <button class="help-tab" data-help="ai">AI Prompt (Flow)</button>
            <button class="help-tab" data-help="aiBrief">AI Prompt (Brief)</button>
        </div>
        <div class="help-panel active" id="helpGuide">
            <h3> What is FlowBuilder Pro?</h3>
            <p>FlowBuilder Pro helps you document and improve business processes. It uses a split-screen view to compare the <strong>Current State</strong> (AS-IS) with a <strong>Proposed State</strong> (TO-BE), making it easy to identify issues and plan improvements.</p>
            
            <h3> Getting Started</h3>
            <ol>
                <li><strong>Create a new analysis</strong> - Click the flow name in the header  Enter a name  Create</li>
                <li><strong>Add steps</strong> - Click "Add Step" in either pane, or use a template</li>
                <li><strong>Connect steps</strong> - Click an output port (bottom of block)  Click a target block</li>
                <li><strong>Mark issues</strong> - Select a step  In the panel, choose Issue or Warning</li>
                <li><strong>Save</strong> - Click Save or press Ctrl+S (auto-saves to Google Drive)</li>
            </ol>
            
            <h3> Views</h3>
            <table class="help-table">
                <tr><td><strong>Split View</strong></td><td>See Current and Proposed side-by-side (default)</td></tr>
                <tr><td><strong>Current Only</strong></td><td>Focus on documenting the current process</td></tr>
                <tr><td><strong>Proposed Only</strong></td><td>Focus on designing improvements</td></tr>
            </table>
            <p>Use the view toggle buttons above the canvas to switch.</p>
            
            <h3> Connections</h3>
            <table class="help-table">
                <tr><td><strong>Create</strong></td><td>Click output port  Click target block or its input port</td></tr>
                <tr><td><strong>Cancel</strong></td><td>Press Escape or click empty canvas</td></tr>
                <tr><td><strong>Add label</strong></td><td>Click the "+" on a connection line</td></tr>
                <tr><td><strong>Add bend</strong></td><td>Click the  symbol on a connection segment</td></tr>
                <tr><td><strong>Move bend</strong></td><td>Drag the waypoint circle</td></tr>
                <tr><td><strong>Remove bend</strong></td><td>Double-click the waypoint circle</td></tr>
                <tr><td><strong>Delete connection</strong></td><td>Right-click on the connection line</td></tr>
            </table>
            
            <h3> Output Ports</h3>
            <table class="help-table">
                <tr><td><strong>Add port</strong></td><td>Click the dashed + circle on the block</td></tr>
                <tr><td><strong>Delete port</strong></td><td>Right-click on an output port (removes port and its connections)</td></tr>
            </table>
            <p>Decision blocks typically need 2+ output ports for different branches (Yes/No, Success/Error).</p>
            
            <h3> Navigation</h3>
            <table class="help-table">
                <tr><td><strong>Pan</strong></td><td>Click and drag on empty canvas</td></tr>
                <tr><td><strong>Zoom</strong></td><td>Scroll wheel (zooms to cursor position)</td></tr>
                <tr><td><strong>Zoom buttons</strong></td><td>Use +/- buttons in bottom-left of canvas</td></tr>
                <tr><td><strong>Fit all</strong></td><td>Click the fit button () to see all blocks</td></tr>
            </table>
            
            <h3> Editing Steps</h3>
            <p>Click any step to select it. The right panel shows:</p>
            <ul>
                <li><strong>Details tab</strong> - Name, description, type, owner, time estimate</li>
                <li><strong>Comments tab</strong> - Add timestamped notes</li>
                <li><strong>Technical tab</strong> - Preconditions, validation rules, error handling</li>
            </ul>
            
            <h3> Step Types</h3>
            <p>Set a type for visual distinction: Action, Decision, API, Email, Form, Data, Delay, Webhook</p>
            
            <h3> Issue Tracking (Current pane only)</h3>
            <ul>
                <li><strong>Issue</strong> (red) - A problem that needs fixing</li>
                <li><strong>Warning</strong> (orange) - A potential concern</li>
            </ul>
            
            <h3> Fix Tracking (Proposed pane only)</h3>
            <ul>
                <li><strong>Fix</strong> - Resolves an issue from current state</li>
                <li><strong>New</strong> - A newly added step</li>
                <li><strong>Modified</strong> - Changed from current</li>
                <li><strong>Removed</strong> - Step will be removed</li>
            </ul>
            <p>Link fixes to issues to maintain traceability!</p>
            
            <h3> Workflow Actions</h3>
            <table class="help-table">
                <tr><td><strong>Copy from Current</strong></td><td>Copies all steps to Proposed pane as a starting point</td></tr>
                <tr><td><strong>Promote</strong></td><td>Replaces Current with Proposed (when changes are implemented)</td></tr>
            </table>
            
            <h3> Export Options</h3>
            <table class="help-table">
                <tr><td><strong>Current PDF</strong></td><td>Export AS-IS flow with all step details</td></tr>
                <tr><td><strong>Proposed PDF</strong></td><td>Export TO-BE flow with all step details</td></tr>
                <tr><td><strong>Comparison PDF</strong></td><td>Side-by-side view with change summary</td></tr>
                <tr><td><strong>Current PNG</strong></td><td>Visual snapshot of the AS-IS flow canvas</td></tr>
                <tr><td><strong>Proposed PNG</strong></td><td>Visual snapshot of the TO-BE flow canvas</td></tr>
                <tr><td><strong>Both PNG</strong></td><td>Side-by-side visual of both canvases</td></tr>
                <tr><td><strong>JSON</strong></td><td>Full data backup for re-import</td></tr>
                <tr><td><strong>HTML Report</strong></td><td>Detailed issues and fixes report</td></tr>
            </table>
            
            <h3> Keyboard Shortcuts</h3>
            <table class="help-table">
                <tr><td><strong>Ctrl+Z</strong></td><td>Undo</td></tr>
                <tr><td><strong>Ctrl+Y</strong></td><td>Redo (also Ctrl+Shift+Z)</td></tr>
                <tr><td><strong>Ctrl+S</strong></td><td>Save</td></tr>
                <tr><td><strong>Ctrl+F</strong></td><td>Search blocks</td></tr>
                <tr><td><strong>Ctrl+A</strong></td><td>Select all blocks in active pane</td></tr>
                <tr><td><strong>Shift+Click</strong></td><td>Multi-select blocks</td></tr>
                <tr><td><strong>Delete</strong></td><td>Delete selected block(s)</td></tr>
                <tr><td><strong>Escape</strong></td><td>Cancel / Close / Clear selection</td></tr>
            </table>
            
            <h3> Advanced Features</h3>
            <table class="help-table">
                <tr><td><strong>Double-Click Edit</strong></td><td>Double-click any block to quickly edit name, description, and type inline.</td></tr>
                <tr><td><strong>Helper Notes</strong></td><td>Use the "Note" button to add informational text blocks that don't connect to the flow.</td></tr>
                <tr><td><strong>Search Blocks</strong></td><td>Use the search bar or Ctrl+F to find blocks. Enter to cycle through matches.</td></tr>
                <tr><td><strong>Multi-Select</strong></td><td>Shift+Click to select multiple blocks. Move or delete them together.</td></tr>
                <tr><td><strong>Auto-Layout</strong></td><td>Click the grid icon in zoom controls to automatically arrange blocks.</td></tr>
                <tr><td><strong>Duplicate Flow</strong></td><td>Use the copy icon in the header to duplicate the current flow.</td></tr>
                <tr><td><strong>Cross-Flow Links</strong></td><td>Link related flows together in the panel's "Related Flows" section.</td></tr>
                <tr><td><strong>Attachments</strong></td><td>Add screenshots or images to any block via the Attachments section.</td></tr>
                <tr><td><strong>Block Reordering</strong></td><td>Drag blocks in the sidebar list to reorder them.</td></tr>
            </table>
        </div>
        
        <div class="help-panel" id="helpImport">
            <h3> Import Formats</h3>
            <p>FlowBuilder Pro accepts <strong>JSON</strong> and <strong>Markdown</strong> files.</p>
            
            <h3>JSON Format</h3>
            <pre class="help-code">{
  "name": "Process Name",
  "description": "Optional description",
  "environment": "other",
  "current": {
    "blocks": [
      {
        "id": "block_1",
        "name": "Step Name",
        "description": "What this step does",
        "x": 96, "y": 96,
        "outputs": 1,
        "stepType": "action",
        "actor": "user",
        "issueType": "error",
        "issueText": "Problem description",
        "owner": "Team/Person",
        "timeEstimate": "5 min",
        "systems": "CRM, API",
        "priority": "high"
      }
    ],
    "connections": [
      {
        "id": "conn_1",
        "from": "block_1",
        "to": "block_2",
        "portIndex": 0,
        "label": "Yes"
      }
    ]
  },
  "proposed": {
    "blocks": [...],
    "connections": [...]
  },
  "issueFixLinks": [
    {"issueId": "block_1", "fixId": "block_1"}
  ]
}</pre>
            
            <h3>Block Properties</h3>
            <table class="help-table">
                <tr><td><strong>id</strong></td><td>Unique identifier (e.g., "block_1") - <em>required</em></td></tr>
                <tr><td><strong>name</strong></td><td>Step title - <em>required</em></td></tr>
                <tr><td><strong>description</strong></td><td>What happens in this step</td></tr>
                <tr><td><strong>x, y</strong></td><td>Position on canvas (auto-snaps to 24px grid)</td></tr>
                <tr><td><strong>outputs</strong></td><td>Number of output ports (default: 1, use 2+ for decisions)</td></tr>
                <tr><td><strong>isHelper</strong></td><td>true for note blocks (no connections)</td></tr>
                <tr><td><strong>stepType</strong></td><td>action, decision, api, email, form, data, delay, webhook</td></tr>
                <tr><td><strong>actor</strong></td><td>"user", "system", "admin" (who performs this step)</td></tr>
                <tr><td><strong>issueType</strong></td><td>"error" or "warning" (current pane only)</td></tr>
                <tr><td><strong>issueText</strong></td><td>Description of the problem</td></tr>
                <tr><td><strong>changeType</strong></td><td>"fix", "new", "modified", "removed" (proposed pane only)</td></tr>
                <tr><td><strong>fixText</strong></td><td>Description of the fix</td></tr>
                <tr><td><strong>status</strong></td><td>"todo", "in-progress", "done", "blocked"</td></tr>
                <tr><td><strong>owner</strong></td><td>Responsible person/team</td></tr>
                <tr><td><strong>timeEstimate</strong></td><td>Duration (e.g., "5 min", "2 hours")</td></tr>
                <tr><td><strong>systems</strong></td><td>Related systems (e.g., "CRM, Database")</td></tr>
                <tr><td><strong>priority</strong></td><td>"low", "medium", "high", "critical"</td></tr>
                <tr><td><strong>preconditions</strong></td><td>What must be true before this step (detail mode)</td></tr>
                <tr><td><strong>validation</strong></td><td>Validation rules for this step (detail mode)</td></tr>
                <tr><td><strong>errorPath</strong></td><td>What happens on error (detail mode)</td></tr>
                <tr><td><strong>systemLink</strong></td><td>URL link to related system (detail mode)</td></tr>
                <tr><td><strong>comments</strong></td><td>Array of {text, author, date} comment objects</td></tr>
                <tr><td><strong>attachments</strong></td><td>Array of {id, name, data} image attachments</td></tr>
            </table>
            
            <h3>Connection Properties</h3>
            <table class="help-table">
                <tr><td><strong>id</strong></td><td>Unique identifier</td></tr>
                <tr><td><strong>from</strong></td><td>Source block ID - <em>required</em></td></tr>
                <tr><td><strong>to</strong></td><td>Target block ID - <em>required</em></td></tr>
                <tr><td><strong>portIndex</strong></td><td>Which output port (0 = first, default: 0)</td></tr>
                <tr><td><strong>label</strong></td><td>Connection label (e.g., "Yes", "No")</td></tr>
                <tr><td><strong>waypoints</strong></td><td>Array of {x, y} bend points (optional)</td></tr>
            </table>
            
            <h3>Flow Properties</h3>
            <table class="help-table">
                <tr><td><strong>name</strong></td><td>Flow name - <em>required</em></td></tr>
                <tr><td><strong>description</strong></td><td>Flow description</td></tr>
                <tr><td><strong>environment</strong></td><td>"exhibitor", "organizer", "ea", "valverde", "other"</td></tr>
                <tr><td><strong>issueFixLinks</strong></td><td>Array linking issues to fixes: [{issueId, fixId}]</td></tr>
            </table>
            
            <h3>Multiple Flows</h3>
            <p>You can import an array of flows: <code>[{flow1}, {flow2}, ...]</code></p>
            <p>FlowBuilder will let you pick which flow(s) to import.</p>
            
            <h3>Minimal Import</h3>
            <p>Only <code>id</code> and <code>name</code> are required for blocks. All other properties have sensible defaults and will be auto-populated on import.</p>
        </div>
        
        <div class="help-panel" id="helpAi">
            <h3> AI Prompt for Converting Process Documentation to Flow</h3>
            <p>Copy this prompt and give it to an AI along with your process documentation. The output will work with auto-layout.</p>
            
            <div class="help-prompt">
                <button class="btn btn-primary" id="copyAiPromptBtn" style="margin-bottom:12px;"> Copy Flow Prompt</button>
                <pre class="help-code" id="aiPromptText">Convert the following process documentation into FlowBuilder Pro JSON format.

INSTRUCTIONS:
1. Create a JSON object with this structure:
{
  "id": "flow_[timestamp]",
  "name": "Process Name",
  "description": "Description of the flow",
  "environment": "exhibitor",
  "flowStatus": "draft",
  "current": { "blocks": [], "connections": [] },
  "proposed": { "blocks": [], "connections": [] },
  "issueFixLinks": []
}

2. For each step in the CURRENT process (as-is), create a block in current.blocks:
{
  "id": "block_N",           // Unique ID like "block_1", "block_2", etc.
  "name": "Step Name",       // Short title (max 30 chars)
  "description": "Details",  // What happens in this step
  "x": 96,                   // X position (96 for main column, 432 for branches)
  "y": 96 + (N-1) * 168,     // Y position (168px spacing, start at 96)
  "outputs": 1,              // Number of outgoing connections (2+ for decisions)
  "stepType": "action",      // One of: action, decision, api, email, form, data, delay, webhook
  "issueType": null,         // "error" or "warning" if there's a problem (or null)
  "issueText": "",           // Description of the problem
  "owner": "",               // Person/team/system responsible
  "timeEstimate": "",        // Duration like "5 min", "Instant", "1-24 hours"
  "systems": ""              // Related systems like "CRM, Database"
}

3. For PROPOSED improvements, create blocks in proposed.blocks with additional fields:
{
  "id": "block_pN",          // Use "block_p1", "block_p2" etc. for proposed blocks
  ...all fields above...,
  "changeType": "fix",       // One of: "fix", "new", "improved", "removed", or null
  "fixText": "",             // Description of what's being fixed/improved
  "status": null             // One of: "todo", "in-progress", "done", "blocked", or null
}

4. For each connection between steps, create a connection object:
{
  "id": "conn_N",            // For current: "conn_1", "conn_2". For proposed: "conn_p1", "conn_p2"
  "from": "block_X",         // Source block ID
  "to": "block_Y",           // Target block ID  
  "portIndex": 0,            // Output port: 0 for first/Yes/Success, 1 for second/No/Failure
  "label": ""                // Optional label like "Success", "Blocked", "Gives Up"
}

5. To link issues in current to fixes in proposed, add to issueFixLinks:
[
  { "issueId": "block_2", "fixId": "block_p2" }
]

LAYOUT RULES:
- Main flow column: x=96
- Branch/alternate path: x=432 (offset by 336px)
- Vertical spacing: 168px between steps (y = 96, 264, 432, 600, 768, 936, 1104, ...)
- Decision blocks should have outputs: 2 (or more) for each branch
- Use portIndex 0 for "Yes/Success" path, portIndex 1 for "No/Failure" path
- After import, use auto-layout button to clean up positioning

STEP TYPES:
- action: Manual task or activity
- decision: Yes/No or branching logic (set outputs: 2+)
- api: API call or integration
- email: Sending email or communication
- form: User input/form submission
- data: Database/data operation
- delay: Waiting period
- webhook: External notification

ISSUE TYPES (current pane only):
- "error": A critical problem that needs fixing (shown in red)
- "warning": A potential concern (shown in orange)
- null: No issue

CHANGE TYPES (proposed pane only):
- "fix": Resolves an issue from current state
- "new": A newly added step
- "improved": Enhanced from current (shows as fix visually)
- "removed": Step will be removed
- null: Unchanged step

OUTPUT FORMAT:
Return ONLY valid JSON. No markdown, no explanations, no code blocks.
Ensure all block IDs referenced in connections exist.
Use double quotes for all strings.
Use null (not "null") for empty optional fields.

PROCESS TO CONVERT:
[Paste your process documentation here]</pre>
            </div>
            
            <h3> Import Instructions</h3>
            <ol>
                <li>Copy the AI's JSON output (make sure it's pure JSON, no markdown)</li>
                <li>Click <strong>Import Flow</strong> button in the dashboard or use File  Import</li>
                <li>Paste the JSON or select a .json file</li>
                <li>Review the import preview and click Import</li>
                <li>Click the <strong>Auto-Layout</strong> button (grid icon in zoom controls) to arrange blocks</li>
            </ol>
            
            <h3> Tips for AI Conversion</h3>
            <ul>
                <li>Provide clear, structured documentation (numbered steps work best)</li>
                <li>Mention any known problems - AI will mark them as issues with issueType and issueText</li>
                <li>Describe desired improvements - AI will create proposed blocks with changeType and fixText</li>
                <li>Specify decision points clearly - AI will create proper branches with labeled connections</li>
                <li>Include system names and responsible parties - AI will populate owner and systems fields</li>
                <li>After import, always run auto-layout to clean up the visual arrangement</li>
            </ul>
            
            <h3>Example: Current vs Proposed Analysis</h3>
            <pre class="help-code">{
  "id": "flow_1737100000001",
  "name": "Order Processing",
  "description": "E-commerce order flow with payment issue analysis",
  "environment": "exhibitor",
  "flowStatus": "draft",
  "current": {
    "blocks": [
      {"id":"block_1","name":"Place Order","description":"Customer submits order","x":96,"y":96,"outputs":1,"stepType":"form","issueType":null,"issueText":"","owner":"User","timeEstimate":"2 min","systems":"Website"},
      {"id":"block_2","name":"Validate Payment","description":"System validates via Stripe","x":96,"y":264,"outputs":2,"stepType":"api","issueType":"error","issueText":"15% timeout failures causing lost sales","owner":"Payment Service","timeEstimate":"3-5 sec","systems":"Stripe API"},
      {"id":"block_3","name":"Create Order","description":"Order saved to database","x":96,"y":432,"outputs":1,"stepType":"data","issueType":null,"issueText":"","owner":"System","timeEstimate":"Instant","systems":"Database"},
      {"id":"block_4","name":"Payment Failed","description":"User sees generic error with no guidance","x":432,"y":432,"outputs":0,"stepType":"action","issueType":"warning","issueText":"Poor UX: No retry option shown","owner":"UI","timeEstimate":"","systems":""}
    ],
    "connections": [
      {"id":"conn_1","from":"block_1","to":"block_2","portIndex":0,"label":""},
      {"id":"conn_2","from":"block_2","to":"block_3","portIndex":0,"label":"Success"},
      {"id":"conn_3","from":"block_2","to":"block_4","portIndex":1,"label":"Failed"}
    ]
  },
  "proposed": {
    "blocks": [
      {"id":"block_p1","name":"Place Order","description":"Customer submits order","x":96,"y":96,"outputs":1,"stepType":"form","changeType":null,"fixText":"","status":null,"owner":"User","timeEstimate":"2 min","systems":"Website"},
      {"id":"block_p2","name":"Validate Payment","description":"Validate with retry logic and exponential backoff","x":96,"y":264,"outputs":2,"stepType":"api","changeType":"improved","fixText":"Added 3x retry with exponential backoff, reducing failures to <2%","status":"todo","owner":"Payment Service","timeEstimate":"3-15 sec","systems":"Stripe API"},
      {"id":"block_p3","name":"Create Order","description":"Order saved to database","x":96,"y":432,"outputs":1,"stepType":"data","changeType":null,"fixText":"","status":null,"owner":"System","timeEstimate":"Instant","systems":"Database"},
      {"id":"block_p4","name":"Show Retry Option","description":"Clear error message with retry button and alternative payment methods","x":432,"y":432,"outputs":1,"stepType":"action","changeType":"new","fixText":"User-friendly error with actionable options","status":"todo","owner":"UI","timeEstimate":"","systems":""},
      {"id":"block_p5","name":"User Retries","description":"User can click retry or choose different payment","x":432,"y":600,"outputs":0,"stepType":"form","changeType":"new","fixText":"Self-service recovery path","status":"todo","owner":"User","timeEstimate":"30 sec","systems":""}
    ],
    "connections": [
      {"id":"conn_p1","from":"block_p1","to":"block_p2","portIndex":0,"label":""},
      {"id":"conn_p2","from":"block_p2","to":"block_p3","portIndex":0,"label":"Success"},
      {"id":"conn_p3","from":"block_p2","to":"block_p4","portIndex":1,"label":"Failed"},
      {"id":"conn_p4","from":"block_p4","to":"block_p5","portIndex":0,"label":""}
    ]
  },
  "issueFixLinks": [
    {"issueId":"block_2","fixId":"block_p2"},
    {"issueId":"block_4","fixId":"block_p4"}
  ]
}</pre>
        </div>
        
        <div class="help-panel" id="helpAiBrief">
            <h3> AI Prompt for Creating Analysis Briefs</h3>
            <p>Use this prompt to create a structured brief that defines the scope of your process analysis before building flows.</p>
            
            <div class="help-prompt">
                <button class="btn btn-primary" id="copyBriefPromptBtn" style="margin-bottom:12px;"> Copy Brief Prompt</button>
                <pre class="help-code" id="briefPromptText">Create a FlowBuilder Pro Analysis Brief in JSON format from the following requirements.

INSTRUCTIONS:
Create a JSON object with this structure:
{
  "id": "brief_[timestamp]",
  "name": "Analysis Brief Name",
  "description": "High-level description of what's being analyzed",
  "environment": "exhibitor",
  "status": "draft",
  "priority": "medium",
  "goals": [
    "Goal 1: What improvement are we trying to achieve?",
    "Goal 2: Another measurable objective"
  ],
  "scope": {
    "inScope": ["Process area 1", "Process area 2"],
    "outOfScope": ["What we're NOT analyzing"]
  },
  "stakeholders": [
    {"name": "Person/Team Name", "role": "Role description", "contact": "email@example.com"}
  ],
  "currentPainPoints": [
    {"issue": "Problem description", "impact": "Business impact", "severity": "high"}
  ],
  "successMetrics": [
    {"metric": "Metric name", "current": "Current value", "target": "Target value"}
  ],
  "constraints": ["Constraint 1", "Constraint 2"],
  "timeline": {
    "analysisStart": "YYYY-MM-DD",
    "analysisEnd": "YYYY-MM-DD",
    "implementationTarget": "YYYY-MM-DD"
  },
  "relatedFlows": [],
  "notes": "Additional context or notes",
  "createdAt": "[ISO timestamp]",
  "updatedAt": "[ISO timestamp]"
}

FIELD GUIDELINES:

environment: One of "exhibitor", "organizer", "ea", "valverde", "other"

status: One of "draft", "in-review", "approved", "in-progress", "completed"

priority: One of "low", "medium", "high", "critical"

currentPainPoints.severity: One of "low", "medium", "high", "critical"

goals: List 2-5 measurable improvement objectives

scope.inScope: What processes/areas ARE being analyzed
scope.outOfScope: What is explicitly NOT part of this analysis (prevents scope creep)

successMetrics: Define how we'll measure improvement
- current: baseline measurement
- target: goal measurement

OUTPUT FORMAT:
Return ONLY valid JSON. No markdown, no explanations, no code blocks.
Use double quotes for all strings.
Use ISO format for dates: "YYYY-MM-DD" or "YYYY-MM-DDTHH:mm:ss.sssZ"

ANALYSIS REQUIREMENTS:
[Paste your analysis requirements here]</pre>
            </div>
            
            <h3> Brief Import Instructions</h3>
            <ol>
                <li>Copy the AI's JSON output</li>
                <li>Click <strong>Import Brief</strong> button in the dashboard</li>
                <li>Paste the JSON or select a .json file</li>
                <li>The brief will appear in your Briefs section</li>
                <li>You can then create flows that link to this brief</li>
            </ol>
            
            <h3> Tips for Brief Creation</h3>
            <ul>
                <li>Start with clear goals - what improvement are you trying to measure?</li>
                <li>Define scope explicitly to prevent analysis creep</li>
                <li>Include success metrics with current/target values for measurable outcomes</li>
                <li>List stakeholders who need to be involved or informed</li>
                <li>Document current pain points with their business impact</li>
                <li>Set realistic timelines for analysis and implementation</li>
            </ul>
            
            <h3>Example Brief</h3>
            <pre class="help-code">{
  "id": "brief_1737100000001",
  "name": "Exhibitor Sign-In Connection Issues",
  "description": "Analysis of the sign-in connection status indicator and firewall blocking issues",
  "environment": "exhibitor",
  "status": "draft",
  "priority": "high",
  "goals": [
    "Reduce support tickets related to connection issues by 80%",
    "Enable self-service resolution for firewall-blocked users",
    "Improve user understanding of connection status"
  ],
  "scope": {
    "inScope": ["Sign-in page", "Connection status indicator", "Port checking logic", "Error messaging"],
    "outOfScope": ["Authentication flow", "Password reset", "Account creation"]
  },
  "stakeholders": [
    {"name": "Support Team", "role": "Handles connection-related tickets", "contact": "support@toddoo.com"},
    {"name": "Frontend Dev", "role": "Implements UI changes", "contact": "dev@toddoo.com"}
  ],
  "currentPainPoints": [
    {"issue": "No visual feedback during connection check", "impact": "Users think system is frozen", "severity": "high"},
    {"issue": "No guidance when all ports blocked", "impact": "Creates unnecessary support tickets", "severity": "critical"},
    {"issue": "Users blame Toddoo instead of their firewall", "impact": "Reputation damage", "severity": "medium"}
  ],
  "successMetrics": [
    {"metric": "Connection-related support tickets per week", "current": "15", "target": "3"},
    {"metric": "Average time to resolve firewall issues", "current": "4 hours", "target": "10 minutes"},
    {"metric": "User self-service resolution rate", "current": "0%", "target": "90%"}
  ],
  "constraints": ["Must work on all supported browsers", "Cannot require backend changes in Phase 1"],
  "timeline": {
    "analysisStart": "2025-01-15",
    "analysisEnd": "2025-01-20",
    "implementationTarget": "2025-02-01"
  },
  "relatedFlows": [],
  "notes": "Based on support ticket analysis showing 40% of sign-in issues are firewall-related",
  "createdAt": "2025-01-17T10:00:00.000Z",
  "updatedAt": "2025-01-17T10:00:00.000Z"
}</pre>
        </div>
    </div></div></div>
    <input type="file" id="importFileInput" accept=".json,.md,.markdown,.txt" style="display:none;" />
    <input type="file" id="importBriefInput" accept=".json" style="display:none;" />
    <input type="file" id="attachmentFileInput" accept="image/*" multiple style="display:none;" />
    
    <!-- Flow Settings Modal -->
    <div class="modal-overlay" id="flowSettingsModal"><div class="modal"><div class="modal-header"><span class="modal-title">Flow Settings</span><button class="modal-close" id="closeFlowSettingsModal"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button></div><div class="modal-body">
        <div class="flow-settings-grid">
            <div class="form-group">
                <label class="form-label">Flow Name</label>
                <input type="text" class="form-input" id="flowSettingsName" placeholder="Flow name..." />
            </div>
            <div class="form-group">
                <label class="form-label">Description</label>
                <textarea class="form-input" id="flowSettingsDesc" rows="3" placeholder="Describe what this flow documents..."></textarea>
            </div>
            <div class="form-group">
                <label class="form-label">Environment</label>
                <select class="form-input" id="flowSettingsEnv">
                    <option value="exhibitor"> Exhibitor</option>
                    <option value="organizer"> Organizer</option>
                    <option value="ea"> EA Exhibitions</option>
                    <option value="valverde"> Valverde</option>
                    <option value="other"> Other</option>
                </select>
            </div>
            <div class="form-group">
                <label class="form-label">Status</label>
                <select class="form-input" id="flowSettingsStatus">
                    <option value="draft"> Draft - Just started</option>
                    <option value="documenting"> Documenting - Still working on it</option>
                    <option value="ready-dev"> Ready for Dev - Programmer can start</option>
                    <option value="in-dev"> In Development - Being built</option>
                    <option value="ready-review"> Ready for Review - Done, needs checking</option>
                    <option value="approved"> Approved - Verified correct</option>
                </select>
            </div>
            <div class="section-divider"><div class="section-title">Cross-Flow Links</div></div>
            <div id="crossFlowLinksContainer"></div>
            <button class="btn" id="addCrossFlowLinkBtn" style="margin-top:8px;"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="12" height="12"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>Add Link to Another Flow</button>
            <div class="section-divider"><div class="section-title">Metadata</div></div>
            <div style="font-size:11px;color:var(--text-muted);">
                <div style="margin-bottom:4px;">Created: <span id="flowSettingsCreated">-</span></div>
                <div style="margin-bottom:4px;">Updated: <span id="flowSettingsUpdated">-</span></div>
                <div>ID: <span id="flowSettingsId" style="font-family:monospace;">-</span></div>
            </div>
        </div>
    </div><div class="modal-footer">
        <button class="btn danger" id="deleteFlowSettingsBtn">Delete Flow</button>
        <div style="flex:1;"></div>
        <button class="btn" id="flowSettingsCancelBtn">Cancel</button>
        <button class="btn btn-primary" id="saveFlowSettingsBtn">Save Changes</button>
    </div></div></div>
    
    <!-- Cross-flow Link Modal -->
    <div class="modal-overlay" id="crossflowModal"><div class="modal"><div class="modal-header"><span class="modal-title">Link to Another Flow</span><button class="modal-close" id="closeCrossflowModal"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button></div><div class="modal-body">
        <div class="form-group">
            <label class="form-label">Select Flow to Link</label>
            <select class="form-input" id="crossflowSelect"></select>
        </div>
        <div class="form-group">
            <label class="form-label">Link Type</label>
            <select class="form-input" id="crossflowType">
                <option value="triggers">Triggers </option>
                <option value="triggered-by"> Triggered by</option>
                <option value="related"> Related to</option>
                <option value="subprocess"> Subprocess of</option>
            </select>
        </div>
    </div><div class="modal-footer">
        <button class="btn" id="crossflowCancelBtn">Cancel</button>
        <button class="btn btn-primary" id="crossflowAddBtn">Add Link</button>
    </div></div></div>
    
    <!-- Brief Modal -->
    <div class="modal-overlay" id="briefModal"><div class="modal xl"><div class="modal-header"><span class="modal-title" id="briefModalTitle">New Project Brief</span><button class="modal-close" id="closeBriefModal"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button></div><div class="modal-body">
        <div class="brief-editor">
            <div class="form-row" style="gap:12px;">
                <div class="form-group" style="flex:2;">
                    <label class="form-label">Brief Title</label>
                    <input type="text" class="form-input" id="briefTitle" placeholder="e.g., Fix Exhibitor VAT Validation" />
                </div>
                <div class="form-group" style="flex:1;">
                    <label class="form-label">Status</label>
                    <select class="form-input" id="briefStatus">
                        <option value="draft"> Draft</option>
                        <option value="agreed"> Agreed</option>
                        <option value="in-progress"> In Progress</option>
                        <option value="validating"> Validating</option>
                        <option value="complete"> Complete</option>
                    </select>
                </div>
            </div>
            
            <div class="brief-section">
                <div class="brief-section-header"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 015.83 1c0 2-3 3-3 3"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>Problem Statement</div>
                <textarea class="form-input" id="briefProblem" rows="3" placeholder="What problem are we solving? Why does it matter?"></textarea>
            </div>
            
            <div class="brief-section">
                <div class="brief-section-header"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 21v-2a4 4 0 00-4-4H5a4 4 0 00-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 00-3-3.87"/><path d="M16 3.13a4 4 0 010 7.75"/></svg>Participants</div>
                <div class="brief-participants" id="briefParticipants"></div>
                <div class="form-row" style="gap:8px; margin-top:8px;">
                    <input type="text" class="form-input" id="briefNewParticipant" placeholder="Name" style="flex:2;" />
                    <select class="form-input" id="briefParticipantRole" style="flex:1;">
                        <option value="decision">Decision</option>
                        <option value="product">Product</option>
                        <option value="dev">Developer</option>
                        <option value="review">Review</option>
                        <option value="stakeholder">Stakeholder</option>
                    </select>
                    <button class="btn" id="briefAddParticipant"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg></button>
                </div>
            </div>
            
            <div class="brief-section">
                <div class="brief-section-header"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></svg>Agreed Solution</div>
                <textarea class="form-input" id="briefSolution" rows="4" placeholder="What did we agree to build/change?&#10;1. ...&#10;2. ...&#10;3. ..."></textarea>
            </div>
            
            <div class="brief-section">
                <div class="brief-section-header"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 11.08V12a10 10 0 11-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>Acceptance Criteria</div>
                <div class="brief-criteria-list" id="briefCriteria"></div>
                <div class="form-row" style="gap:8px; margin-top:8px;">
                    <input type="text" class="form-input" id="briefNewCriteria" placeholder="Add acceptance criterion..." style="flex:1;" />
                    <button class="btn" id="briefAddCriteria"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg></button>
                </div>
            </div>
            
            <div class="brief-section">
                <div class="brief-section-header"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15a2 2 0 01-2 2H7l-4 4V5a2 2 0 012-2h14a2 2 0 012 2z"/></svg>Discussion Notes</div>
                <textarea class="form-input" id="briefNotes" rows="4" placeholder="Key points from the discussion...&#10; ...&#10; ...&#10; Agreed that..."></textarea>
            </div>
            
            <div class="brief-section">
                <div class="brief-section-header"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"/></svg>Linked Flows</div>
                <div class="brief-linked-flows" id="briefLinkedFlows"></div>
                <div class="brief-add-btn" id="briefLinkFlowBtn"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>Link a Flow</div>
            </div>
        </div>
    </div><div class="modal-footer">
        <button class="btn" id="deleteBriefBtn" style="color:var(--red); margin-right:auto;">Delete Brief</button>
        <button class="btn" id="importBriefBtn" title="Import brief from JSON file"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>Import</button>
        <button class="btn" id="cancelBriefBtn">Cancel</button>
        <button class="btn btn-primary" id="saveBriefBtn">Save Brief</button>
    </div></div></div>
    
    <!-- Link Flow to Brief Modal -->
    <div class="modal-overlay" id="linkFlowModal"><div class="modal"><div class="modal-header"><span class="modal-title">Link Flow to Brief</span><button class="modal-close" id="closeLinkFlowModal"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button></div><div class="modal-body">
        <div class="flow-list" id="linkFlowList" style="max-height:300px; overflow-y:auto;"></div>
    </div></div></div>
    
    <!-- Editing Conflict Modal -->
    <div class="modal-overlay" id="editingConflictModal"><div class="modal" style="max-width:450px;"><div class="modal-header"><span class="modal-title"> Flow In Use</span><button class="modal-close" id="closeEditingConflictModal"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button></div><div class="modal-body">
        <div class="conflict-warning">
            <div class="conflict-warning-title">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10.29 3.86L1.82 18a2 2 0 001.71 3h16.94a2 2 0 001.71-3L13.71 3.86a2 2 0 00-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>
                Someone is editing this flow
            </div>
            <div class="conflict-warning-text">
                <span class="conflict-warning-user" id="conflictUserName">Someone</span> is currently editing this flow.
                <br><br>
                Last activity: <span id="conflictLastActivity">a few minutes ago</span>
                <br><br>
                Opening it now may cause conflicts if you both save changes.
            </div>
        </div>
        <div class="conflict-actions">
            <button class="btn" id="conflictCancelBtn">Cancel</button>
            <button class="btn btn-primary" id="conflictOpenAnywayBtn">Open Anyway</button>
        </div>
    </div></div></div>
    
    <!-- Save Conflict Modal -->
    <div class="modal-overlay" id="saveConflictModal"><div class="modal" style="max-width:450px;"><div class="modal-header"><span class="modal-title"> Save Conflict</span><button class="modal-close" id="closeSaveConflictModal"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button></div><div class="modal-body">
        <div class="conflict-warning">
            <div class="conflict-warning-title">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10.29 3.86L1.82 18a2 2 0 001.71 3h16.94a2 2 0 001.71-3L13.71 3.86a2 2 0 00-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>
                Flow was modified
            </div>
            <div class="conflict-warning-text">
                This flow was modified by <span class="conflict-warning-user" id="saveConflictUser">someone</span> while you were editing.
                <br><br>
                Modified: <span id="saveConflictTime">recently</span>
                <br><br>
                What would you like to do?
            </div>
        </div>
        <div class="conflict-actions" style="flex-direction: column;">
            <button class="btn" id="saveConflictReloadBtn"> Reload Their Version (lose my changes)</button>
            <button class="btn btn-primary" id="saveConflictOverwriteBtn"> Save My Version (overwrite theirs)</button>
        </div>
    </div></div></div>
    
    <!-- Session Expired Modal -->
    <div class="modal-overlay" id="sessionExpiredModal"><div class="modal" style="max-width:420px;"><div class="modal-header"><span class="modal-title"> Session Expired</span></div><div class="modal-body">
        <div style="text-align:center; padding: 20px 0;">
            <div style="font-size: 48px; margin-bottom: 16px;"></div>
            <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 12px;">
                Your Google sign-in session has expired.
            </div>
            <div style="font-size: 12px; color: var(--text-muted); margin-bottom: 20px;">
                This happens after about 1 hour of inactivity.<br>
                Your work is still saved in memory - just sign out and sign back in to continue.
            </div>
            <button class="btn btn-primary" id="sessionExpiredSignOutBtn" style="width: 100%; padding: 12px; font-size: 14px;">
                 Sign Out & Sign Back In
            </button>
            <div style="font-size: 10px; color: var(--text-muted); margin-top: 12px;">
                After signing back in, press Ctrl+S to save your work
            </div>
        </div>
    </div></div></div>
    
    <!-- Image Viewer -->
    <div class="image-viewer" id="imageViewer"><img id="imageViewerImg" /></div>
    <!-- Blocking Save Overlay -->
    <div class="save-overlay" id="saveOverlay">
        <div class="save-overlay-spinner"></div>
        <div class="save-overlay-text" id="saveOverlayText">Saving to Google Drive...</div>
        <div class="save-overlay-subtext" id="saveOverlaySubtext">Please wait, do not close this page</div>
    </div>
    <div class="toast-container" id="toastContainer"></div>
    <script>
    const STEP_TYPES = {
        action: { name: 'Action', color: '#3b82f6', icon: '<rect x="6" y="6" width="12" height="12" rx="2" fill="currentColor"/>' },
        decision: { name: 'Decision', color: '#f97316', icon: '<path d="M12 4L4 12l8 8 8-8-8-8z" fill="currentColor"/>' },
        api: { name: 'API', color: '#a855f7', icon: '<circle cx="12" cy="12" r="4" fill="currentColor"/>' },
        email: { name: 'Email', color: '#ec4899', icon: '<rect x="2" y="4" width="20" height="16" rx="2" fill="currentColor"/>' },
        form: { name: 'Form', color: '#8b5cf6', icon: '<rect x="4" y="4" width="16" height="16" rx="2" stroke="currentColor" stroke-width="2" fill="none"/>' },
        data: { name: 'Data', color: '#22c55e', icon: '<ellipse cx="12" cy="6" rx="8" ry="3" fill="currentColor"/>' },
        delay: { name: 'Delay', color: '#06b6d4', icon: '<circle cx="12" cy="12" r="9" stroke="currentColor" stroke-width="2" fill="none"/>' },
        webhook: { name: 'Webhook', color: '#eab308', icon: '<path d="M10 13a5 5 0 007.54.54l3-3" stroke="currentColor" stroke-width="2" fill="none"/>' }
    };
    
    const ACTOR_TYPES = {
        user: { name: 'User', color: '#0ea5e9', icon: '<path d="M20 21v-2a4 4 0 00-4-4H8a4 4 0 00-4 4v2"/><circle cx="12" cy="7" r="4"/>' },
        system: { name: 'System', color: '#a855f7', icon: '<rect x="4" y="4" width="16" height="16" rx="2"/><path d="M9 9h6M9 13h6M9 17h4"/>' },
        admin: { name: 'Admin', color: '#f59e0b', icon: '<path d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"/>' }
    };
    
    const TEMPLATES = [
        { id: 'blank', name: 'Blank', desc: 'Start from scratch', icon: '' },
        { id: 'journey', name: 'User Journey', desc: 'Customer flow', icon: '' },
        { id: 'approval', name: 'Approval', desc: 'Multi-step approval', icon: '' },
        { id: 'onboarding', name: 'Onboarding', desc: 'New user flow', icon: '' }
    ];
    const PRIORITIES = ['critical', 'high', 'medium', 'low'];
    const STATUSES = ['todo', 'in-progress', 'review', 'done'];

    const GOOGLE_CLIENT_ID = '131879736877-21fqkvlpnf12csi73qgv1c9j5jf9lk10.apps.googleusercontent.com';
    const GOOGLE_API_KEY = ''; // Not needed for OAuth
    const DRIVE_FOLDER_NAME = 'FlowBuilder';
    
    class FlowBuilder {
        constructor() {
            this.flows = {};
            this.currentFlowId = null;
            this.currentFlowIsDrive = false;
            this.mode = 'sketch';
            this.activeTab = 'details';
            this.current = { blocks: new Map(), connections: [], zoom: 1, panX: 0, panY: 0 };
            this.proposed = { blocks: new Map(), connections: [], zoom: 1, panX: 0, panY: 0 };
            this.activePane = 'current';
            this.selectedBlock = null;
            this.blockIdCounter = 0;
            this.isDragging = false;
            this.isPanning = false;
            this.isConnecting = false;
            // Inline editing
            this.inlineEditBlock = null;
            this.inlineEditPane = null;
            this.inlineEditEl = null;
            this.inlineEditOriginal = null;
            this.issueFixLinks = [];
            this.versionHistory = [];
            // Undo/Redo
            this.undoStack = [];
            this.redoStack = [];
            this.maxHistorySize = 50;
            this.isUndoRedo = false; // Flag to prevent saving state during undo/redo
            // Google Drive
            this.googleUser = null;
            this.driveFlows = {};
            this.driveFolderId = null;
            this.storageMode = 'drive'; // Force drive-only
            this.tokenClient = null;
            this.gapiInited = false;
            this.gisInited = false;
            this.authenticated = false;
            // Dashboard
            this.dashboardSearchTerm = '';
            // Briefs
            this.briefs = {};
            this.briefsFileId = null;
            this.currentBriefId = null;
            this.editingBrief = null;
            // Collaboration / Editing Sessions
            this.editingSessions = {};
            this.sessionUpdateInterval = null;
            this.flowLoadedAt = null;  // Track when we loaded the current flow
            this.sessionExpiryMinutes = 10;  // Sessions expire after 10 min inactivity
            this.pendingFlowId = null;  // Flow awaiting conflict resolution
            // Multi-select
            this.multiSelectedBlocks = new Set();
            this.multiSelectPane = null;
            // Attachments
            this.pendingAttachmentBlockId = null;
            this.pendingAttachmentPane = null;
            // Cross-flow links
            this.pendingCrossflowBlockId = null;
            this.pendingCrossflowPane = null;
            // Block list drag
            this.draggedBlockItem = null;
            this.initAuth();
        }

        async initAuth() {
            // Show loading while Google API loads
            document.getElementById('loginContent').classList.add('hidden');
            document.getElementById('loginLoading').classList.add('show');
            document.querySelector('#loginLoading span').textContent = 'Loading...';
            
            // Initialize Google API
            try {
                await this.initGoogleApi();
                // API ready - show login button (if not auto-logged in)
                if (!this.authenticated) {
                    document.getElementById('loginContent').classList.remove('hidden');
                    document.getElementById('loginLoading').classList.remove('show');
                }
            } catch (e) {
                console.error('Failed to load Google API:', e);
                document.getElementById('loginLoading').classList.remove('show');
                document.getElementById('loginError').textContent = 'Failed to load. Please refresh the page.';
                document.getElementById('loginError').classList.add('show');
            }
            
            // Bind login button
            document.getElementById('loginBtn').addEventListener('click', () => this.loginWithGoogle());
        }
        
        initApp() {
            // Only called after successful authentication
            document.getElementById('loginScreen').classList.add('hidden');
            
            this.loadFlows();
            this.bindEvents();
            this.bindDashboardEvents();
            this.renderTemplates();
            this.renderPanel();
            this.updateValidation();
            
            // Show dashboard first
            this.showDashboard();
        }
        
        bindDashboardEvents() {
            document.getElementById('backToDashboard')?.addEventListener('click', () => this.showDashboard());
            document.getElementById('newFlowDashBtn')?.addEventListener('click', () => this.showModal('flowModal'));
            document.getElementById('newBriefDashBtn')?.addEventListener('click', () => this.showBriefModal());
            document.getElementById('importDashBtn')?.addEventListener('click', () => document.getElementById('importFileInput').click());
            document.getElementById('importBriefDashBtn')?.addEventListener('click', () => document.getElementById('importBriefInput').click());
            document.getElementById('refreshDashBtn')?.addEventListener('click', async () => {
                try {
                    await this.loadDriveFlows();
                    await this.loadBriefsFromDrive();
                    await this.loadEditingSessions();
                    this.renderDashboard();
                    this.toast('Dashboard refreshed', 'success');
                } catch (e) {
                    this.toast('Failed to refresh', 'error');
                }
            });
            
            // Search functionality
            document.getElementById('dashboardSearch')?.addEventListener('input', e => {
                this.dashboardSearchTerm = e.target.value.toLowerCase();
                this.renderFlowMap();
                this.renderBriefsSection();
            });
            
            // Environment selector in header
            document.getElementById('flowEnvSelector')?.addEventListener('change', e => {
                if (this.currentFlowId && this.currentFlowIsDrive) {
                    const flow = this.driveFlows[this.currentFlowId];
                    if (flow) {
                        flow.environment = e.target.value;
                        this.saveToDrive(flow);
                        this.toast(`Environment changed to ${e.target.value}`, 'success');
                    }
                }
            });
            
            // Flow status selector in header
            document.getElementById('flowStatusSelector')?.addEventListener('change', e => {
                if (this.currentFlowId && this.currentFlowIsDrive) {
                    const flow = this.driveFlows[this.currentFlowId];
                    if (flow) {
                        flow.flowStatus = e.target.value;
                        flow.updatedAt = new Date().toISOString();
                        this.saveToDrive(flow);
                        this.updateFlowStatusBadge();
                        const labels = {
                            'draft': 'Draft',
                            'documenting': 'Documenting',
                            'ready-dev': 'Ready for Dev',
                            'in-dev': 'In Development',
                            'ready-review': 'Ready for Review',
                            'approved': 'Approved'
                        };
                        this.toast(`Status: ${labels[e.target.value]}`, 'success');
                    }
                }
            });
            
            // Brief modal events
            document.getElementById('closeBriefModal')?.addEventListener('click', () => this.hideModal('briefModal'));
            document.getElementById('cancelBriefBtn')?.addEventListener('click', () => this.hideModal('briefModal'));
            document.getElementById('saveBriefBtn')?.addEventListener('click', () => this.saveBrief());
            document.getElementById('deleteBriefBtn')?.addEventListener('click', () => this.deleteBrief());
            document.getElementById('importBriefBtn')?.addEventListener('click', () => document.getElementById('importBriefInput').click());
            document.getElementById('importBriefInput')?.addEventListener('change', e => this.importBrief(e));
            document.getElementById('briefAddParticipant')?.addEventListener('click', () => this.addBriefParticipant());
            document.getElementById('briefNewParticipant')?.addEventListener('keydown', e => {
                if (e.key === 'Enter') this.addBriefParticipant();
            });
            document.getElementById('briefAddCriteria')?.addEventListener('click', () => this.addBriefCriteria());
            document.getElementById('briefNewCriteria')?.addEventListener('keydown', e => {
                if (e.key === 'Enter') this.addBriefCriteria();
            });
            document.getElementById('briefLinkFlowBtn')?.addEventListener('click', () => this.showLinkFlowModal());
            document.getElementById('closeLinkFlowModal')?.addEventListener('click', () => this.hideModal('linkFlowModal'));
            
            // Conflict modal events
            document.getElementById('closeEditingConflictModal')?.addEventListener('click', () => this.hideModal('editingConflictModal'));
            document.getElementById('conflictCancelBtn')?.addEventListener('click', () => this.hideModal('editingConflictModal'));
            document.getElementById('conflictOpenAnywayBtn')?.addEventListener('click', () => this.confirmOpenFlow());
            document.getElementById('closeSaveConflictModal')?.addEventListener('click', () => this.hideModal('saveConflictModal'));
            document.getElementById('saveConflictReloadBtn')?.addEventListener('click', () => this.reloadConflictedFlow());
            document.getElementById('saveConflictOverwriteBtn')?.addEventListener('click', () => this.overwriteConflictedFlow());
            
            // Session expired modal
            document.getElementById('sessionExpiredSignOutBtn')?.addEventListener('click', () => {
                this.hideSessionExpiredModal();
                this.googleSignOut();
            });
        }
        
        loginWithGoogle() {
            if (!this.gisInited) { 
                const errorEl = document.getElementById('loginError');
                if (errorEl) {
                    errorEl.textContent = 'Still loading. Please wait a moment and try again.';
                    errorEl.classList.add('show');
                }
                return; 
            }
            document.getElementById('loginError')?.classList.remove('show');
            document.getElementById('loginContent')?.classList.add('hidden');
            document.getElementById('loginLoading')?.classList.add('show');
            const loadingSpan = document.querySelector('#loginLoading span');
            if (loadingSpan) loadingSpan.textContent = 'Signing in...';
            this.tokenClient.requestAccessToken({ prompt: '' });
        }
        
        async initGoogleApi() {
            // Load Google API scripts dynamically
            await this.loadScript('https://apis.google.com/js/api.js');
            await this.loadScript('https://accounts.google.com/gsi/client');
            
            // Init gapi
            await new Promise((resolve) => {
                gapi.load('client', async () => {
                    await gapi.client.init({});
                    await gapi.client.load('https://www.googleapis.com/discovery/v1/apis/drive/v3/rest');
                    this.gapiInited = true;
                    resolve();
                });
            });
            
            // Init Google Identity Services
            this.tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: GOOGLE_CLIENT_ID,
                scope: 'https://www.googleapis.com/auth/drive',
                callback: (response) => {
                    if (response.error) {
                        // Auth failed or denied
                        document.getElementById('loginContent')?.classList.remove('hidden');
                        document.getElementById('loginLoading')?.classList.remove('show');
                        const errorEl = document.getElementById('loginError');
                        if (errorEl) {
                            errorEl.textContent = 'Access denied. You are not authorized to use this app.';
                            errorEl.classList.add('show');
                        }
                        return;
                    }
                    if (response.access_token) {
                        this.onGoogleSignIn(response);
                    }
                },
                error_callback: (error) => {
                    document.getElementById('loginContent')?.classList.remove('hidden');
                    document.getElementById('loginLoading')?.classList.remove('show');
                    const errorEl = document.getElementById('loginError');
                    if (errorEl) {
                        errorEl.textContent = 'Authentication failed. Please try again.';
                        errorEl.classList.add('show');
                    }
                }
            });
            this.gisInited = true;
            
            // Full drive access required for team collaboration (shared folders)
            const tokenVersion = localStorage.getItem('fb_token_version');
            if (tokenVersion !== '2') {
                localStorage.removeItem('fb_google_token');
                localStorage.removeItem('fb_google_user');
                localStorage.setItem('fb_token_version', '2');
            }
            
            // Check for existing token - auto login
            const savedToken = localStorage.getItem('fb_google_token');
            if (savedToken) {
                document.getElementById('loginContent').classList.add('hidden');
                document.getElementById('loginLoading').classList.add('show');
                this.updateLoadingProgress('Validating session...', 10);
                try {
                    gapi.client.setToken({ access_token: savedToken });
                    // Test if token is still valid
                    await gapi.client.drive.about.get({ fields: 'user' });
                    const userInfo = JSON.parse(localStorage.getItem('fb_google_user') || '{}');
                    this.googleUser = userInfo;
                    this.authenticated = true;
                    this.updateLoadingProgress('Finding FlowBuilder folder...', 25);
                    await this.ensureDriveFolder();
                    this.updateLoadingProgress('Loading flows from Drive...', 45);
                    await this.loadDriveFlows();
                    this.updateLoadingProgress('Loading briefs...', 70);
                    await this.loadBriefsFromDrive();
                    this.updateLoadingProgress('Checking active sessions...', 90);
                    await this.loadEditingSessions();
                    this.updateLoadingProgress('Ready!', 100);
                    this.initApp();
                } catch (e) {
                    // Token expired or invalid
                    localStorage.removeItem('fb_google_token');
                    localStorage.removeItem('fb_google_user');
                    document.getElementById('loginContent').classList.remove('hidden');
                    document.getElementById('loginLoading').classList.remove('show');
                }
            }
        }
        
        updateLoadingProgress(text, percent) {
            const loadingText = document.querySelector('.login-loading-text');
            const progressContainer = document.querySelector('.login-loading-progress');
            const progressBar = document.querySelector('.login-progress-bar');
            const detailText = document.querySelector('.login-loading-detail');
            
            if (loadingText) loadingText.textContent = 'Loading your workspace...';
            if (progressContainer) progressContainer.style.display = 'block';
            if (progressBar) progressBar.style.width = percent + '%';
            if (detailText) detailText.textContent = text;
        }
        
        loadScript(src) {
            return new Promise((resolve, reject) => {
                if (document.querySelector(`script[src="${src}"]`)) { resolve(); return; }
                const script = document.createElement('script');
                script.src = src;
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }
        
        googleSignIn() {
            // Keep for compatibility but main flow uses loginWithGoogle
            this.loginWithGoogle();
        }
        
        async onGoogleSignIn(response) {
            // Set the token in gapi.client FIRST
            gapi.client.setToken({ access_token: response.access_token });
            localStorage.setItem('fb_google_token', response.access_token);
            
            // Get user info
            try {
                this.updateLoadingProgress('Getting user info...', 15);
                const aboutResp = await gapi.client.drive.about.get({ fields: 'user' });
                this.googleUser = aboutResp.result.user;
                localStorage.setItem('fb_google_user', JSON.stringify(this.googleUser));
                this.authenticated = true;
                
                // Find or create FlowBuilder folder
                this.updateLoadingProgress('Finding FlowBuilder folder...', 30);
                await this.ensureDriveFolder();
                this.updateLoadingProgress('Loading flows from Drive...', 50);
                await this.loadDriveFlows();
                this.updateLoadingProgress('Loading briefs...', 75);
                await this.loadBriefsFromDrive();
                this.updateLoadingProgress('Checking active sessions...', 90);
                await this.loadEditingSessions();
                this.updateLoadingProgress('Ready!', 100);
                
                // Initialize the app now that we're authenticated
                this.initApp();
                this.updateGoogleAuthUI();
            } catch (e) {
                console.error('Sign in error:', e);
                document.getElementById('loginContent')?.classList.remove('hidden');
                document.getElementById('loginLoading')?.classList.remove('show');
                const errorEl = document.getElementById('loginError');
                if (errorEl) {
                    errorEl.textContent = 'Sign in failed. Please try again.';
                    errorEl.classList.add('show');
                }
            }
        }
        
        googleSignOut() {
            const token = gapi.client.getToken();
            if (token) {
                google.accounts.oauth2.revoke(token.access_token);
                gapi.client.setToken(null);
            }
            localStorage.removeItem('fb_google_token');
            localStorage.removeItem('fb_google_user');
            this.googleUser = null;
            this.driveFlows = {};
            this.driveFolderId = null;
            this.authenticated = false;
            // Reload the page to show login screen
            window.location.reload();
        }
        
        async ensureValidToken() {
            // Check if we have a valid token
            const token = gapi.client.getToken();
            if (!token || !token.access_token) {
                throw new Error('Session expired');
            }
            
            // Try a simple API call to verify token is still valid
            try {
                await gapi.client.drive.about.get({ fields: 'user' });
                return true;
            } catch (e) {
                if (e.status === 401) {
                    throw new Error('Session expired');
                }
                throw e;
            }
        }
        
        updateGoogleAuthUI() {
            const userPhoto = document.getElementById('googleUserPhoto');
            const userName = document.getElementById('googleUserName');
            
            if (this.googleUser && userPhoto && userName) {
                userPhoto.src = this.googleUser.photoLink || 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%236e7681"><circle cx="12" cy="8" r="4"/><path d="M12 14c-6 0-8 3-8 6v2h16v-2c0-3-2-6-8-6z"/></svg>';
                userName.textContent = this.googleUser.displayName || this.googleUser.emailAddress;
            }
        }
        
          async ensureDriveFolder() {
            // Return cached ID if we already have it
            if (this.driveFolderId) return this.driveFolderId;

            try {
                // 1. Unified Search: Find ANY folder with this name (Owned OR Shared)
                // We request 'capabilities' to check if we can actually write to it.
                const listResp = await gapi.client.drive.files.list({
                    q: `name = '${DRIVE_FOLDER_NAME}' and mimeType = 'application/vnd.google-apps.folder' and trashed = false`,
                    fields: 'files(id, name, owners, shared, capabilities(canEdit, canAddChildren))',
                    spaces: 'drive',
                    // critical for finding folders inside Team/Shared Drives
                    includeItemsFromAllDrives: true,
                    supportsAllDrives: true
                });

                const folders = listResp.result.files;
                let targetFolder = null;

                if (folders && folders.length > 0) {
                    // 2. Filter: Only consider folders where we have EDIT/WRITE permission
                    // 'canAddChildren' is the specific permission needed to upload files into a folder
                    const writableFolders = folders.filter(f => 
                        f.capabilities.canEdit || f.capabilities.canAddChildren
                    );

                    if (writableFolders.length > 0) {
                        // 3. Priority: Prefer a SHARED folder if one exists (for team collaboration)
                        const sharedWritable = writableFolders.find(f => f.shared);
                        
                        if (sharedWritable) {
                            targetFolder = sharedWritable;
                            console.log('Using SHARED FlowBuilder folder (Edit access verified)');
                        } else {
                            targetFolder = writableFolders[0];
                            console.log('Using OWNED FlowBuilder folder');
                        }
                    } else {
                        console.warn(`Found '${DRIVE_FOLDER_NAME}', but you only have Read-Only access. Ignoring and creating a new one...`);
                    }
                }

                if (targetFolder) {
                    this.driveFolderId = targetFolder.id;
                } else {
                    // 4. Fallback: Create folder if no writable one exists
                    console.log('No writable folder found. Creating new one...');
                    const createResp = await gapi.client.drive.files.create({
                        resource: { 
                            name: DRIVE_FOLDER_NAME, 
                            mimeType: 'application/vnd.google-apps.folder' 
                        },
                        fields: 'id',
                        supportsAllDrives: true
                    });
                    this.driveFolderId = createResp.result.id;
                }
                
                return this.driveFolderId;

            } catch (err) {
                console.error('Error ensuring Drive folder:', err);
                // Throwing error allows the caller to handle the UI failure state
                throw err;
            }
        }
        
        async loadDriveFlows() {
            if (!this.googleUser || !this.driveFolderId) return;
            
            try {
                const resp = await gapi.client.drive.files.list({
                    q: `'${this.driveFolderId}' in parents and mimeType='application/json' and trashed=false`,
                    fields: 'files(id, name, modifiedTime)',
                    orderBy: 'modifiedTime desc',
                    spaces: 'drive',
                    supportsAllDrives: true,
                    includeItemsFromAllDrives: true
                });
                
                this.driveFlows = {};
                for (const file of (resp.result.files || [])) {
                    // Skip system files
                    if (file.name.startsWith('_')) continue;
                    
                    // Load file content
                    const contentResp = await gapi.client.drive.files.get({
                        fileId: file.id,
                        alt: 'media',
                        supportsAllDrives: true
                    });
                    try {
                        const flowData = typeof contentResp.body === 'string' ? JSON.parse(contentResp.body) : contentResp.body;
                        flowData.driveFileId = file.id;
                        flowData.isDrive = true;
                        this.driveFlows[flowData.id || file.id] = flowData;
                        
                        // Debug logging
                        console.log('Loaded from Drive:', file.name);
                        console.log('  Current blocks:', (flowData.current?.blocks || []).length);
                        console.log('  Current connections:', (flowData.current?.connections || []).length);
                    } catch (e) {
                        console.error('Failed to parse flow:', file.name, e);
                    }
                }
            } catch (e) {
                console.error('Failed to load drive flows:', e);
                this.toast('Failed to load Drive flows', 'error');
            }
        }
        
        async saveToDrive(flow) {
            if (!this.googleUser) { 
                this.toast('Sign in to save to Drive', 'error'); 
                throw new Error('Not signed in');
            }
            
            // Ensure token is valid before attempting save
            try {
                await this.ensureValidToken();
            } catch (e) {
                this.showSessionExpiredModal();
                throw e;
            }
            
            await this.ensureDriveFolder();
            
            const fileName = (flow.name || 'Untitled').replace(/[^a-zA-Z0-9\s-_]/g, '') + '.json';
            const fileContent = JSON.stringify(flow, null, 2);
            const blob = new Blob([fileContent], { type: 'application/json' });
            const expectedBlocks = (flow.current?.blocks || []).length;
            
            // Debug: log what we're saving
            console.log('=== SAVING TO DRIVE ===');
            console.log('Flow:', flow.name);
            console.log('File size:', fileContent.length, 'bytes');
            console.log('Blocks to save:', expectedBlocks);
            console.log('Connections to save:', (flow.current?.connections || []).length);
            
            document.getElementById('savingIndicator').classList.add('active');
            this.showSaveOverlay('Uploading to Google Drive...');
            
            try {
                const token = gapi.client.getToken().access_token;
                if (!token) {
                    throw new Error('No access token available');
                }
                let fileId = flow.driveFileId;
                
                if (fileId) {
                    // Update existing file
                    console.log('Updating existing file:', fileId);
                    const resp = await fetch(`https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=media&supportsAllDrives=true`, {
                        method: 'PATCH',
                        headers: {
                            'Authorization': 'Bearer ' + token,
                            'Content-Type': 'application/json'
                        },
                        body: fileContent
                    });
                    
                    if (!resp.ok) {
                        const errorText = await resp.text();
                        throw new Error(`Upload failed (${resp.status}): ${errorText}`);
                    }
                    console.log('Update response:', resp.status, resp.statusText);
                } else {
                    // Create new file
                    console.log('Creating new file:', fileName);
                    const metadata = {
                        name: fileName,
                        mimeType: 'application/json',
                        parents: [this.driveFolderId]
                    };
                    
                    const form = new FormData();
                    form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
                    form.append('file', blob);
                    
                    const resp = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=id&supportsAllDrives=true', {
                        method: 'POST',
                        headers: { 'Authorization': 'Bearer ' + token },
                        body: form
                    });
                    
                    if (!resp.ok) {
                        const errorText = await resp.text();
                        throw new Error(`Create failed (${resp.status}): ${errorText}`);
                    }
                    
                    const result = await resp.json();
                    fileId = result.id;
                    flow.driveFileId = fileId;
                    console.log('Created new file with ID:', fileId);
                }
                
                // VERIFY: Read back the file and check it
                this.showSaveOverlay('Verifying save...');
                console.log('Verifying saved file...');
                
                const verifyResp = await gapi.client.drive.files.get({
                    fileId: fileId,
                    alt: 'media',
                    supportsAllDrives: true
                });
                
                const savedData = JSON.parse(verifyResp.body);
                const savedBlocks = (savedData.current?.blocks || []).length;
                
                console.log('Verification - blocks in saved file:', savedBlocks);
                
                if (savedBlocks !== expectedBlocks) {
                    throw new Error(`Verification failed! Expected ${expectedBlocks} blocks but saved file has ${savedBlocks}`);
                }
                
                console.log(' Save verified successfully!');
                
                flow.isDrive = true;
                this.driveFlows[flow.id] = flow;
                this.toast('Saved to Drive ', 'success');
                
            } catch (e) {
                console.error('Save to drive failed:', e);
                
                // Check if it's an auth error
                if (e.message && (e.message.includes('401') || e.message.includes('UNAUTHENTICATED') || e.message.includes('Invalid Credentials') || e.message.includes('Session expired'))) {
                    this.showSessionExpiredModal();
                } else {
                    this.toast(' Save failed: ' + e.message, 'error');
                }
                throw e; // Re-throw so caller knows it failed
            } finally {
                document.getElementById('savingIndicator').classList.remove('active');
                this.hideSaveOverlay();
            }
        }
        
        async deleteFromDrive(flowId) {
            const flow = this.driveFlows[flowId];
            if (!flow || !flow.driveFileId) return;
            
            try {
                await gapi.client.drive.files.delete({ fileId: flow.driveFileId, supportsAllDrives: true });
                delete this.driveFlows[flowId];
                this.toast('Deleted from Drive', 'success');
            } catch (e) {
                console.error('Delete failed:', e);
                this.toast('Failed to delete', 'error');
            }
        }
        
        showSessionExpiredModal() {
            document.getElementById('sessionExpiredModal').classList.add('show');
        }
        
        hideSessionExpiredModal() {
            document.getElementById('sessionExpiredModal').classList.remove('show');
        }

        getPane(paneId) { return paneId === 'current' ? this.current : this.proposed; }
        
        getPaneElements(paneId) {
            return {
                canvas: document.getElementById(`${paneId}Canvas`),
                canvasArea: document.getElementById(`${paneId}CanvasArea`),
                blocksContainer: document.getElementById(`${paneId}BlocksContainer`),
                connectionsSvg: document.getElementById(`${paneId}ConnectionsSvg`),
                zoomLevel: document.getElementById(`${paneId}ZoomLevel`),
                instructions: document.getElementById(`${paneId}Instructions`)
            };
        }

        toast(msg, type = 'success') {
            const c = document.getElementById('toastContainer');
            const t = document.createElement('div');
            t.className = 'toast ' + type;
            t.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">${type === 'success' ? '<path d="M22 11.08V12a10 10 0 11-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/>' : '<circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/>'}</svg><span>${msg}</span>`;
            c.appendChild(t);
            // Error messages stay longer (6 seconds) so user can read them
            const duration = type === 'error' ? 6000 : 2500;
            setTimeout(() => { t.style.opacity = '0'; setTimeout(() => t.remove(), 200); }, duration);
        }

        bindEvents() {
            document.getElementById('flowSelector').addEventListener('click', () => this.showFlowModal());
            document.getElementById('closeFlowModal').addEventListener('click', () => this.hideModal('flowModal'));
            document.getElementById('createFlowBtn').addEventListener('click', () => this.createFlow());
            document.getElementById('newFlowName').addEventListener('keypress', e => { if (e.key === 'Enter') this.createFlow(); });
            document.getElementById('importFlowBtn').addEventListener('click', () => document.getElementById('importFileInput').click());
            document.getElementById('importFileInput').addEventListener('change', e => this.importFlow(e));
            document.getElementById('sketchModeBtn')?.addEventListener('click', () => this.setMode('sketch'));
            document.getElementById('configureModeBtn')?.addEventListener('click', () => this.setMode('configure'));
            document.getElementById('detailModeBtn')?.addEventListener('click', () => this.setMode('detail'));
            document.getElementById('devModeBtn')?.addEventListener('click', () => this.setMode('dev'));
            document.querySelectorAll('.panel-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.panel-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    this.activeTab = tab.dataset.tab;
                    this.renderPanelContent();
                });
            });
            document.getElementById('addCurrentBlockBtn').addEventListener('click', () => this.addBlock('current'));
            document.getElementById('addProposedBlockBtn').addEventListener('click', () => this.addBlock('proposed'));
            document.getElementById('addCurrentHelperBtn')?.addEventListener('click', () => this.addHelperBlock('current'));
            document.getElementById('addProposedHelperBtn')?.addEventListener('click', () => this.addHelperBlock('proposed'));
            document.getElementById('copyFromCurrentBtn').addEventListener('click', () => this.copyCurrentToProposed());
            document.getElementById('promoteToCurrentBtn').addEventListener('click', () => this.promoteToCurrentState());
            // View toggle
            document.getElementById('viewCurrentBtn').addEventListener('click', () => this.setViewMode('current'));
            document.getElementById('viewSplitBtn').addEventListener('click', () => this.setViewMode('split'));
            document.getElementById('viewProposedBtn').addEventListener('click', () => this.setViewMode('proposed'));
            ['current', 'proposed'].forEach(paneId => {
                const els = this.getPaneElements(paneId);
                els.canvasArea.addEventListener('mousedown', e => this.onCanvasMouseDown(e, paneId));
                els.canvasArea.addEventListener('mousemove', e => this.onCanvasMouseMove(e, paneId));
                els.canvasArea.addEventListener('mouseup', e => this.onCanvasMouseUp(e, paneId));
                els.canvasArea.addEventListener('wheel', e => this.onCanvasWheel(e, paneId), { passive: false });
                els.canvasArea.addEventListener('click', e => {
                    if (e.target === els.canvasArea || e.target.closest('.canvas-container')) {
                        if (this.isConnecting) {
                            this.cancelConnecting();
                        } else if (!e.shiftKey) {
                            this.selectBlock(null, paneId);
                            this.clearMultiSelect();
                        }
                    }
                });
                els.canvasArea.querySelectorAll('.zoom-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const action = btn.dataset.action;
                        const pane = this.getPane(paneId);
                        if (action === 'in') this.setZoom(pane.zoom + 0.1, paneId);
                        else if (action === 'out') this.setZoom(pane.zoom - 0.1, paneId);
                        else if (action === 'fit') this.zoomToFit(paneId);
                        else if (action === 'snap-grid') this.snapAllToGrid(paneId);
                        else if (action === 'auto-layout') this.autoLayout(paneId);
                    });
                });
            });
            document.getElementById('exportBtn').addEventListener('click', () => this.showExportModal());
            document.getElementById('closeExportModal').addEventListener('click', () => this.hideModal('exportModal'));
            document.querySelectorAll('.export-option').forEach(opt => opt.addEventListener('click', () => this.doExport(opt.dataset.export)));
            document.getElementById('helpBtn').addEventListener('click', () => this.showHelpModal());
            document.getElementById('closeHelpModal').addEventListener('click', () => this.hideModal('helpModal'));
            document.querySelectorAll('.help-tab').forEach(tab => tab.addEventListener('click', () => this.switchHelpTab(tab.dataset.help)));
            document.getElementById('copyAiPromptBtn')?.addEventListener('click', () => this.copyAiPrompt());
            document.getElementById('copyBriefPromptBtn')?.addEventListener('click', () => this.copyBriefPrompt());
            document.getElementById('validateBtn')?.addEventListener('click', () => this.showValidationModal());
            document.getElementById('closeValidationModal').addEventListener('click', () => this.hideModal('validationModal'));
            document.getElementById('closeImportModal').addEventListener('click', () => this.hideModal('importModal'));
            document.getElementById('saveBtn').addEventListener('click', () => this.saveCurrentFlow());
            document.getElementById('searchInput').addEventListener('input', e => this.filterBlocks(e.target.value));
            document.getElementById('undoBtn').addEventListener('click', () => this.undo());
            document.getElementById('redoBtn').addEventListener('click', () => this.redo());
            
            // Flow settings
            document.getElementById('flowSettingsBtn')?.addEventListener('click', () => this.showFlowSettingsModal());
            document.getElementById('closeFlowSettingsModal')?.addEventListener('click', () => this.hideModal('flowSettingsModal'));
            document.getElementById('flowSettingsCancelBtn')?.addEventListener('click', () => this.hideModal('flowSettingsModal'));
            document.getElementById('saveFlowSettingsBtn')?.addEventListener('click', () => this.saveFlowSettings());
            document.getElementById('deleteFlowSettingsBtn')?.addEventListener('click', () => this.deleteCurrentFlow());
            document.getElementById('addCrossFlowLinkBtn')?.addEventListener('click', () => this.showCrossflowModal());
            
            // Cross-flow modal
            document.getElementById('closeCrossflowModal')?.addEventListener('click', () => this.hideModal('crossflowModal'));
            document.getElementById('crossflowCancelBtn')?.addEventListener('click', () => this.hideModal('crossflowModal'));
            document.getElementById('crossflowAddBtn')?.addEventListener('click', () => this.addCrossFlowLink());
            
            // Duplicate flow
            document.getElementById('duplicateFlowBtn')?.addEventListener('click', () => this.duplicateFlow());
            
            // Block search
            document.getElementById('blockSearchInput')?.addEventListener('input', e => this.searchBlocks(e.target.value));
            document.getElementById('blockSearchInput')?.addEventListener('keydown', e => {
                if (e.key === 'Enter') this.jumpToNextSearchResult();
                if (e.key === 'Escape') { e.target.value = ''; this.searchBlocks(''); e.target.blur(); }
            });
            
            // Image viewer
            document.getElementById('imageViewer')?.addEventListener('click', () => {
                document.getElementById('imageViewer').classList.remove('show');
            });
            document.getElementById('crossFlowSearch')?.addEventListener('input', e => this.filterCrossFlowList(e.target.value));
            
            // Attachment preview
            document.getElementById('attachmentPreview')?.addEventListener('click', () => {
                document.getElementById('attachmentPreview').classList.remove('show');
            });
            document.getElementById('attachmentFileInput')?.addEventListener('change', e => this.handleAttachmentUpload(e));
            
            // ===== NEW UX EVENT BINDINGS =====
            
            // Sidebar toggle
            document.getElementById('toggleSidebarBtn')?.addEventListener('click', () => this.toggleSidebar());
            
            // Panel toggle
            document.getElementById('togglePanelBtn')?.addEventListener('click', () => this.togglePanel());
            document.getElementById('togglePanelHeaderBtn')?.addEventListener('click', () => this.togglePanel());
            
            // Sidebar accordions
            document.querySelectorAll('.sidebar-accordion .accordion-header').forEach(header => {
                header.addEventListener('click', () => {
                    header.closest('.sidebar-accordion').classList.toggle('open');
                });
            });
            
            // Panel accordions (delegated)
            document.getElementById('panelContent')?.addEventListener('click', e => {
                const accordionHeader = e.target.closest('.panel-accordion-header');
                if (accordionHeader) {
                    accordionHeader.closest('.panel-accordion').classList.toggle('open');
                }
            });
            
            // Search input - also bind to sidebar search
            document.getElementById('searchInput')?.addEventListener('keydown', e => {
                if (e.key === 'Enter') this.jumpToNextSearchResult();
                if (e.key === 'Escape') { e.target.value = ''; this.filterBlocks(''); e.target.blur(); }
            });
            
            document.addEventListener('keydown', e => {
                if (e.key === 'Delete' && this.selectedBlock && !['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName)) {
                    if (this.multiSelectedBlocks.size > 0) this.deleteMultiSelected();
                    else this.deleteSelectedBlock();
                }
                if ((e.ctrlKey || e.metaKey) && e.key === 's') { e.preventDefault(); this.saveCurrentFlow(); }
                if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) { e.preventDefault(); this.undo(); }
                if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) { e.preventDefault(); this.redo(); }
                if ((e.ctrlKey || e.metaKey) && e.key === 'f') { 
                    e.preventDefault(); 
                    // Focus sidebar search
                    const sidebar = document.getElementById('sidebarLeft');
                    if (sidebar?.classList.contains('collapsed')) {
                        sidebar.classList.remove('collapsed');
                    }
                    const searchInput = document.getElementById('searchInput');
                    if (searchInput) { searchInput.focus(); searchInput.select(); }
                }
                if ((e.ctrlKey || e.metaKey) && e.key === 'a' && !['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName)) {
                    e.preventDefault();
                    this.selectAllBlocks();
                }
                if (e.key === 'Escape') { 
                    if (this.inlineEditBlock) {
                        this.closeInlineEdit(true);
                        return;
                    }
                    this.cancelConnecting(); 
                    this.clearMultiSelect();
                    this.hideModal('flowModal'); 
                    this.hideModal('exportModal'); 
                    this.hideModal('validationModal'); 
                    this.hideModal('importModal'); 
                    this.hideModal('helpModal'); 
                    this.hideModal('flowSettingsModal');
                    this.hideModal('crossflowModal');
                    this.selectBlock(null, this.activePane); 
                }
            });
        }

        // ===== NEW UX METHODS =====
        
        toggleSidebar() {
            const sidebar = document.getElementById('sidebarLeft');
            const toggleBtn = document.getElementById('toggleSidebarBtn');
            sidebar.classList.toggle('collapsed');
            toggleBtn?.classList.toggle('active', !sidebar.classList.contains('collapsed'));
        }
        
        togglePanel() {
            const panel = document.getElementById('panel');
            const toggleBtn = document.getElementById('togglePanelBtn');
            const headerBtn = document.getElementById('togglePanelHeaderBtn');
            panel.classList.toggle('collapsed');
            const isOpen = !panel.classList.contains('collapsed');
            toggleBtn?.classList.toggle('active', isOpen);
            headerBtn?.classList.toggle('active', isOpen);
        }
        
        updateEnvBadge(env) {
            const badge = document.getElementById('envBadge');
            if (!badge) return;
            
            badge.className = 'env-badge';
            if (env && env !== 'other') {
                badge.classList.add(env, 'show');
                const labels = { exhibitor: 'Exhibitor', organizer: 'Organizer', ea: 'EA Exhibitions', valverde: 'Valverde' };
                badge.textContent = labels[env] || env;
            }
        }
        
        updateValidationBadge() {
            const badge = document.getElementById('validationBadge');
            if (!badge) return;
            
            const errors = document.querySelectorAll('.validation-item.error').length;
            const warnings = document.querySelectorAll('.validation-item.warning').length;
            
            badge.className = 'validation-badge';
            if (errors > 0) {
                badge.classList.add('show');
                badge.textContent = errors;
            } else if (warnings > 0) {
                badge.classList.add('show', 'warning');
                badge.textContent = warnings;
            }
        }

        setMode(mode) {
            this.mode = mode;
            document.getElementById('sketchModeBtn')?.classList.toggle('active', mode === 'sketch');
            document.getElementById('configureModeBtn')?.classList.toggle('active', mode === 'configure');
            document.getElementById('detailModeBtn')?.classList.toggle('active', mode === 'detail');
            document.getElementById('devModeBtn')?.classList.toggle('active', mode === 'dev');
            this.renderPanelContent();
            ['current', 'proposed'].forEach(paneId => this.getPane(paneId).blocks.forEach(block => this.updateBlockElement(block, paneId)));
        }

        loadFlows() { const saved = localStorage.getItem('fb_pro_flows'); this.flows = saved ? JSON.parse(saved) : {}; }
        saveFlows() { localStorage.setItem('fb_pro_flows', JSON.stringify(this.flows)); }

        // Normalize block to ensure all properties exist with proper defaults
        normalizeBlock(block, paneId = 'current') {
            const isHelper = block.isHelper === true;
            return {
                // Required properties
                id: block.id || 'block_' + Date.now(),
                name: block.name || (isHelper ? 'Note' : 'Untitled'),
                description: block.description || '',
                x: this.snapToGrid(block.x ?? 96),
                y: this.snapToGrid(block.y ?? 96),
                
                // Output ports (helpers have 0)
                outputs: isHelper ? 0 : (block.outputs ?? 1),
                
                // Helper block flag
                isHelper: isHelper,
                
                // Step type and actor
                stepType: block.stepType || null,
                actor: block.actor || null,
                config: block.config || {},
                
                // Current pane: issues
                issueType: block.issueType || null,
                issueText: block.issueText || '',
                
                // Proposed pane: changes
                changeType: paneId === 'proposed' ? (block.changeType || null) : null,
                fixText: block.fixText || '',
                status: paneId === 'proposed' ? (block.status || null) : null,
                
                // Metadata
                owner: block.owner || '',
                systems: block.systems || '',
                timeEstimate: block.timeEstimate || '',
                priority: block.priority || '',
                
                // Detail mode fields
                preconditions: block.preconditions || '',
                validation: block.validation || '',
                errorPath: block.errorPath || '',
                systemLink: block.systemLink || '',
                
                // Comments and attachments
                comments: Array.isArray(block.comments) ? block.comments : [],
                attachments: Array.isArray(block.attachments) ? block.attachments : []
            };
        }
        
        // Normalize connection to ensure all properties exist
        normalizeConnection(conn) {
            return {
                id: conn.id || 'conn_' + Date.now(),
                from: conn.from,
                to: conn.to,
                portIndex: conn.portIndex ?? 0,
                label: conn.label || '',
                waypoints: Array.isArray(conn.waypoints) ? conn.waypoints : undefined
            };
        }

        // Undo/Redo functionality
        saveState(action = 'change') {
            if (this.isUndoRedo) return; // Don't save during undo/redo operations
            
            // Create a snapshot of current state
            const state = {
                action,
                timestamp: Date.now(),
                current: {
                    blocks: Array.from(this.current.blocks.entries()).map(([id, block]) => [id, { ...block }]),
                    connections: this.current.connections.map(c => ({ ...c, waypoints: c.waypoints ? [...c.waypoints] : undefined }))
                },
                proposed: {
                    blocks: Array.from(this.proposed.blocks.entries()).map(([id, block]) => [id, { ...block }]),
                    connections: this.proposed.connections.map(c => ({ ...c, waypoints: c.waypoints ? [...c.waypoints] : undefined }))
                },
                issueFixLinks: this.issueFixLinks.map(l => ({ ...l })),
                selectedBlockId: this.selectedBlock?.id,
                activePane: this.activePane
            };
            
            this.undoStack.push(state);
            
            // Limit history size
            if (this.undoStack.length > this.maxHistorySize) {
                this.undoStack.shift();
            }
            
            // Clear redo stack when new action is performed
            this.redoStack = [];
            
            this.updateUndoRedoButtons();
        }
        
        restoreState(state) {
            // Restore current pane
            this.current.blocks.clear();
            state.current.blocks.forEach(([id, block]) => this.current.blocks.set(id, { ...block }));
            this.current.connections = state.current.connections.map(c => ({ ...c, waypoints: c.waypoints ? [...c.waypoints] : undefined }));
            
            // Restore proposed pane
            this.proposed.blocks.clear();
            state.proposed.blocks.forEach(([id, block]) => this.proposed.blocks.set(id, { ...block }));
            this.proposed.connections = state.proposed.connections.map(c => ({ ...c, waypoints: c.waypoints ? [...c.waypoints] : undefined }));
            
            // Restore issue-fix links
            this.issueFixLinks = state.issueFixLinks.map(l => ({ ...l }));
            
            // Re-render everything
            this.renderBlocks('current');
            this.renderBlocks('proposed');
            this.updateConnections('current');
            this.updateConnections('proposed');
            this.updateInstructions();
            this.updateBlockList();
            this.updateMinimap();
            this.updateValidation();
            
            // Restore selection
            if (state.selectedBlockId) {
                const block = this.getPane(state.activePane).blocks.get(state.selectedBlockId);
                if (block) {
                    this.selectBlock(block, state.activePane);
                } else {
                    this.selectBlock(null, state.activePane);
                }
            } else {
                this.selectBlock(null, this.activePane);
            }
        }
        
        undo() {
            if (this.undoStack.length === 0) return;
            
            // Save current state to redo stack before undoing
            const currentState = {
                action: 'before-undo',
                timestamp: Date.now(),
                current: {
                    blocks: Array.from(this.current.blocks.entries()).map(([id, block]) => [id, { ...block }]),
                    connections: this.current.connections.map(c => ({ ...c, waypoints: c.waypoints ? [...c.waypoints] : undefined }))
                },
                proposed: {
                    blocks: Array.from(this.proposed.blocks.entries()).map(([id, block]) => [id, { ...block }]),
                    connections: this.proposed.connections.map(c => ({ ...c, waypoints: c.waypoints ? [...c.waypoints] : undefined }))
                },
                issueFixLinks: this.issueFixLinks.map(l => ({ ...l })),
                selectedBlockId: this.selectedBlock?.id,
                activePane: this.activePane
            };
            this.redoStack.push(currentState);
            
            // Pop and restore the previous state
            const prevState = this.undoStack.pop();
            this.isUndoRedo = true;
            this.restoreState(prevState);
            this.isUndoRedo = false;
            
            this.updateUndoRedoButtons();
            this.toast('Undo', 'info');
        }
        
        redo() {
            if (this.redoStack.length === 0) return;
            
            // Save current state to undo stack before redoing
            const currentState = {
                action: 'before-redo',
                timestamp: Date.now(),
                current: {
                    blocks: Array.from(this.current.blocks.entries()).map(([id, block]) => [id, { ...block }]),
                    connections: this.current.connections.map(c => ({ ...c, waypoints: c.waypoints ? [...c.waypoints] : undefined }))
                },
                proposed: {
                    blocks: Array.from(this.proposed.blocks.entries()).map(([id, block]) => [id, { ...block }]),
                    connections: this.proposed.connections.map(c => ({ ...c, waypoints: c.waypoints ? [...c.waypoints] : undefined }))
                },
                issueFixLinks: this.issueFixLinks.map(l => ({ ...l })),
                selectedBlockId: this.selectedBlock?.id,
                activePane: this.activePane
            };
            this.undoStack.push(currentState);
            
            // Pop and restore the redo state
            const redoState = this.redoStack.pop();
            this.isUndoRedo = true;
            this.restoreState(redoState);
            this.isUndoRedo = false;
            
            this.updateUndoRedoButtons();
            this.toast('Redo', 'info');
        }
        
        updateUndoRedoButtons() {
            document.getElementById('undoBtn').disabled = this.undoStack.length === 0;
            document.getElementById('redoBtn').disabled = this.redoStack.length === 0;
        }
        
        clearHistory() {
            this.undoStack = [];
            this.redoStack = [];
            this.updateUndoRedoButtons();
        }

        async createFlow(templateId = 'blank', envOverride = null) {
            const nameInput = document.getElementById('newFlowName');
            const envSelect = document.getElementById('newFlowEnv');
            const name = nameInput.value.trim() || 'Untitled Analysis';
            const environment = envOverride || (envSelect ? envSelect.value : 'other');
            const id = 'flow_' + Date.now();
            const newFlow = { id, name, description: '', environment, current: { blocks: [], connections: [] }, proposed: { blocks: [], connections: [] }, issueFixLinks: [], createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() };
            
            // Always save to Drive
            if (templateId !== 'blank') {
                this.driveFlows[id] = newFlow;
                this.applyTemplate(id, templateId, true);
            } else {
                this.driveFlows[id] = newFlow;
            }
            await this.saveToDrive(this.driveFlows[id]);
            this.loadFlow(id, true);
            
            this.hideModal('flowModal');
            this.hideDashboard();
            nameInput.value = '';
            this.toast('Analysis created', 'success');
        }

        applyTemplate(flowId, templateId, isDrive = true) {
            const flow = this.driveFlows[flowId];
            const templates = {
                'journey': { blocks: [{ name: 'User arrives', description: 'User lands on page', x: 100, y: 100 }, { name: 'View content', description: 'User browses', x: 100, y: 240 }, { name: 'Take action', description: 'Main action', x: 100, y: 380 }, { name: 'Confirmation', description: 'Success shown', x: 100, y: 520 }] },
                'approval': { blocks: [{ name: 'Submit request', description: 'User submits', x: 100, y: 100 }, { name: 'Manager review', description: 'Manager decides', x: 100, y: 240 }, { name: 'Final approval', description: 'Authority approves', x: 100, y: 380 }, { name: 'Complete', description: 'Request done', x: 100, y: 520 }] },
                'onboarding': { blocks: [{ name: 'Registration', description: 'Create account', x: 100, y: 100 }, { name: 'Verification', description: 'Email verify', x: 100, y: 240 }, { name: 'Profile setup', description: 'Complete profile', x: 100, y: 380 }, { name: 'Welcome', description: 'Onboarding done', x: 100, y: 520 }] }
            };
            const template = templates[templateId];
            if (template) {
                flow.current.blocks = template.blocks.map((b, i) => ({ id: `block_${i + 1}`, ...b, outputs: 1, issueType: null, issueText: '', owner: '', systems: '', timeEstimate: '', priority: '', comments: [] }));
                flow.current.connections = template.blocks.slice(0, -1).map((_, i) => ({ id: `conn_${i}`, from: `block_${i + 1}`, portIndex: 0, to: `block_${i + 2}` }));
            }
        }

        loadFlow(flowId, isDrive = false) {
            const flow = isDrive ? this.driveFlows[flowId] : this.flows[flowId];
            if (!flow) return;
            
            // Debug logging
            console.log('Loading flow:', flow.name);
            console.log('  Current blocks:', (flow.current?.blocks || []).length);
            console.log('  Current connections:', (flow.current?.connections || []).length);
            console.log('  Proposed blocks:', (flow.proposed?.blocks || []).length);
            console.log('  Proposed connections:', (flow.proposed?.connections || []).length);
            
            this.currentFlowId = flowId;
            this.currentFlowIsDrive = isDrive;
            if (!isDrive) localStorage.setItem('fb_pro_lastFlow', flowId);
            ['current', 'proposed'].forEach(paneId => {
                const pane = this.getPane(paneId);
                const els = this.getPaneElements(paneId);
                els.blocksContainer.innerHTML = '';
                pane.blocks.clear();
                pane.connections = [];
                pane.zoom = 1;
                pane.panX = 0;
                pane.panY = 0;
            });
            this.blockIdCounter = 0;
            this.selectedBlock = null;
            this.issueFixLinks = flow.issueFixLinks || [];
            
            // Load current blocks with normalization
            (flow.current?.blocks || []).forEach(block => {
                const b = this.normalizeBlock(block, 'current');
                this.current.blocks.set(b.id, b);
                this.renderBlock(b, 'current');
                const num = parseInt(b.id.split('_')[1]) || 0;
                if (num >= this.blockIdCounter) this.blockIdCounter = num + 1;
            });
            
            // Load current connections with normalization
            this.current.connections = (flow.current?.connections || []).map(c => this.normalizeConnection(c));
            
            // Load proposed blocks with normalization
            (flow.proposed?.blocks || []).forEach(block => {
                const b = this.normalizeBlock(block, 'proposed');
                this.proposed.blocks.set(b.id, b);
                this.renderBlock(b, 'proposed');
                const num = parseInt(b.id.split('_')[1]) || 0;
                if (num >= this.blockIdCounter) this.blockIdCounter = num + 1;
            });
            
            // Load proposed connections with normalization
            this.proposed.connections = (flow.proposed?.connections || []).map(c => this.normalizeConnection(c));
            
            this.updateConnections('current');
            this.updateConnections('proposed');
            this.updateFlowSelector();
            this.renderPanel();
            this.updateBlockList();
            this.updateMinimap();
            this.updateValidation();
            this.updateInstructions();
            this.clearHistory(); // Clear undo/redo history when loading a new flow
            
            // Update environment selector
            const envSelector = document.getElementById('flowEnvSelector');
            if (envSelector) {
                envSelector.style.display = 'block';
                envSelector.value = flow.environment || 'other';
            }
            
            // Update flow status selector
            const statusSelector = document.getElementById('flowStatusSelector');
            if (statusSelector) {
                statusSelector.style.display = 'block';
                statusSelector.value = flow.flowStatus || 'draft';
                this.updateFlowStatusBadge();
            }
            
            // Show flow action buttons
            document.getElementById('flowSettingsBtn').style.display = '';
            document.getElementById('duplicateFlowBtn').style.display = '';
            
            // Update brief reference in sidebar
            this.updateBriefReference();
            
            setTimeout(() => { this.zoomToFit('current'); this.zoomToFit('proposed'); }, 100);
        }

        async saveCurrentFlow() {
            if (!this.currentFlowId) { this.showFlowModal(); return; }
            
            // Check for conflicts before saving (Drive only)
            if (this.currentFlowIsDrive) {
                const hasConflict = await this.checkSaveConflict();
                if (hasConflict) return; // Modal will be shown
            }
            
            // Show blocking overlay
            this.showSaveOverlay('Preparing to save...');
            
            try {
                this.addToHistory();
                
                const isDrive = this.currentFlowIsDrive;
                const flow = isDrive ? this.driveFlows[this.currentFlowId] : this.flows[this.currentFlowId];
                
                // Deep copy blocks and connections to avoid reference issues
                const currentBlocks = Array.from(this.current.blocks.values()).map(b => JSON.parse(JSON.stringify(b)));
                const currentConnections = JSON.parse(JSON.stringify(this.current.connections));
                const proposedBlocks = Array.from(this.proposed.blocks.values()).map(b => JSON.parse(JSON.stringify(b)));
                const proposedConnections = JSON.parse(JSON.stringify(this.proposed.connections));
                
                // Validate data before saving
                console.log('=== SAVE VALIDATION ===');
                console.log('Flow:', flow.name);
                console.log('Current blocks in memory:', this.current.blocks.size);
                console.log('Current blocks to save:', currentBlocks.length);
                console.log('Current connections to save:', currentConnections.length);
                console.log('Proposed blocks to save:', proposedBlocks.length);
                
                // Verify deep copy worked
                if (currentBlocks.length !== this.current.blocks.size) {
                    throw new Error(`Block count mismatch: memory has ${this.current.blocks.size}, copy has ${currentBlocks.length}`);
                }
                
                // Verify blocks have required data
                for (const block of currentBlocks) {
                    if (!block.id || block.x === undefined || block.y === undefined) {
                        console.error('Invalid block:', block);
                        throw new Error(`Invalid block found: ${JSON.stringify(block)}`);
                    }
                }
                
                flow.current = { blocks: currentBlocks, connections: currentConnections };
                flow.proposed = { blocks: proposedBlocks, connections: proposedConnections };
                flow.issueFixLinks = JSON.parse(JSON.stringify(this.issueFixLinks));
                flow.updatedAt = new Date().toISOString();
                
                // Verify the flow object is complete
                const flowJson = JSON.stringify(flow);
                const flowSize = flowJson.length;
                console.log('Flow JSON size:', flowSize, 'bytes');
                
                // Parse it back to verify it's valid JSON
                const verifyFlow = JSON.parse(flowJson);
                if (verifyFlow.current.blocks.length !== currentBlocks.length) {
                    throw new Error('JSON serialization corrupted the data!');
                }
                
                console.log('Validation passed, saving...');
                
                if (isDrive) {
                    this.showSaveOverlay('Saving to Google Drive...');
                    await this.saveToDrive(flow);
                    this.flowLoadedAt = Date.now();
                } else {
                    this.saveFlows();
                    this.toast('Saved', 'success');
                }
            } catch (e) {
                console.error('Save failed:', e);
                this.toast('Save failed: ' + e.message, 'error');
            } finally {
                this.hideSaveOverlay();
            }
        }
        
        showSaveOverlay(text) {
            const overlay = document.getElementById('saveOverlay');
            const textEl = document.getElementById('saveOverlayText');
            if (overlay) overlay.classList.add('active');
            if (textEl) textEl.textContent = text || 'Saving...';
        }
        
        hideSaveOverlay() {
            const overlay = document.getElementById('saveOverlay');
            if (overlay) overlay.classList.remove('active');
        }

        addToHistory() {
            const snapshot = { timestamp: new Date().toISOString(), current: { blocks: Array.from(this.current.blocks.values()), connections: [...this.current.connections] }, proposed: { blocks: Array.from(this.proposed.blocks.values()), connections: [...this.proposed.connections] } };
            this.versionHistory.push(snapshot);
            if (this.versionHistory.length > 20) this.versionHistory.shift();
        }

        async deleteFlow(flowId, isDrive = false) {
            if (!confirm('Delete this analysis?')) return;
            
            if (isDrive) {
                await this.deleteFromDrive(flowId);
            } else {
                delete this.flows[flowId];
                this.saveFlows();
            }
            
            if (this.currentFlowId === flowId) {
                this.currentFlowId = null;
                this.currentFlowIsDrive = false;
                ['current', 'proposed'].forEach(paneId => { const pane = this.getPane(paneId); const els = this.getPaneElements(paneId); els.blocksContainer.innerHTML = ''; pane.blocks.clear(); pane.connections = []; });
                this.updateFlowSelector();
                this.updateInstructions();
                this.renderPanel();
            }
            this.renderFlowList();
            this.toast('Deleted', 'success');
        }

        importFlow(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (evt) => {
                try {
                    const content = evt.target.result;
                    const isMarkdown = file.name.endsWith('.md') || file.name.endsWith('.markdown') || file.name.endsWith('.txt');
                    
                    let data;
                    if (isMarkdown) {
                        data = this.parseMarkdownFlow(content, file.name);
                    } else {
                        const parsed = JSON.parse(content);
                        
                        // Check if it's an array of flows
                        if (Array.isArray(parsed)) {
                            if (parsed.length === 0) {
                                this.toast('File contains no flows', 'error');
                                return;
                            }
                            // Show flow picker if multiple flows
                            if (parsed.length > 1) {
                                this.showFlowPickerModal(parsed, file.name);
                                return;
                            }
                            // Single flow in array
                            data = parsed[0];
                        } else {
                            data = parsed;
                        }
                    }
                    
                    if (!data || (!data.current?.blocks?.length && !data.proposed?.blocks?.length)) {
                        this.toast('No valid flow data found', 'error');
                        return;
                    }
                    
                    this.pendingImport = data;
                    this.showImportDiffModal(data, file.name);
                } catch (err) { 
                    console.error('Import error:', err);
                    this.toast('Invalid file format: ' + err.message, 'error'); 
                }
            };
            reader.readAsText(file);
            e.target.value = '';
        }
        
        showFlowPickerModal(flows, filename) {
            const body = document.getElementById('importModalBody');
            const footer = document.getElementById('importModalFooter');
            
            body.innerHTML = `
                <div class="import-info">
                    <div class="import-info-row"><span class="import-info-label">File:</span><span>${filename}</span></div>
                    <div class="import-info-row"><span class="import-info-label">Contains:</span><span>${flows.length} flows</span></div>
                </div>
                <div class="section-divider">
                    <div class="section-title">Select a flow to import</div>
                </div>
                <div class="flow-picker-list">
                    ${flows.map((flow, idx) => `
                        <div class="flow-picker-item" data-index="${idx}">
                            <div class="flow-picker-name">${flow.name || 'Untitled Flow ' + (idx + 1)}</div>
                            <div class="flow-picker-meta">
                                ${(flow.current?.blocks?.length || 0)} current steps, 
                                ${(flow.proposed?.blocks?.length || 0)} proposed steps
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
            
            footer.innerHTML = `
                <button class="btn" id="importAllFlowsBtn">Import All (${flows.length})</button>
                <button class="btn" id="cancelFlowPickerBtn">Cancel</button>
            `;
            
            // Bind events
            body.querySelectorAll('.flow-picker-item').forEach(item => {
                item.addEventListener('click', () => {
                    const idx = parseInt(item.dataset.index);
                    this.pendingImport = flows[idx];
                    this.showImportDiffModal(flows[idx], filename);
                });
            });
            
            document.getElementById('importAllFlowsBtn').addEventListener('click', async () => {
                this.hideModal('importModal');
                let imported = 0;
                let lastId = null;
                for (const flow of flows) {
                    if (flow.current?.blocks?.length || flow.proposed?.blocks?.length) {
                        lastId = await this.importFlowDirect(flow);
                        imported++;
                    }
                }
                this.toast(`Imported ${imported} flows`, 'success');
                this.renderFlowList();
                // Load the last imported flow and hide dashboard
                if (lastId) {
                    this.loadFlow(lastId, true);
                    this.hideDashboard();
                }
            });
            
            document.getElementById('cancelFlowPickerBtn').addEventListener('click', () => {
                this.hideModal('importModal');
            });
            
            this.showModal('importModal');
        }
        
        async importFlowDirect(data) {
            const id = 'flow_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
            
            // Snap all blocks to grid before saving
            const snapBlocks = (blocks) => (blocks || []).map(b => ({
                ...b,
                x: this.snapToGrid(b.x || 96),
                y: this.snapToGrid(b.y || 96)
            }));
            
            const newFlow = {
                id,
                name: data.name || 'Imported Flow',
                description: data.description || '',
                environment: data.environment || 'other',
                current: { blocks: snapBlocks(data.current?.blocks), connections: data.current?.connections || [] },
                proposed: { blocks: snapBlocks(data.proposed?.blocks), connections: data.proposed?.connections || [] },
                issueFixLinks: data.issueFixLinks || [],
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString()
            };
            
            this.driveFlows[id] = newFlow;
            await this.saveToDrive(newFlow);
            return id;
        }
        
        parseMarkdownFlow(content, filename) {
            const lines = content.split('\n');
            const flow = {
                name: filename.replace(/\.(md|markdown|txt|json)$/i, ''),
                description: '',
                current: { blocks: [], connections: [] },
                proposed: { blocks: [], connections: [] },
                issueFixLinks: [],
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString()
            };
            
            let currentSection = null; // 'current' or 'proposed'
            let currentBlock = null;
            let blockIdCounter = 0;
            let blockNameToId = {};
            let pendingConnections = [];
            
            const stepTypes = ['action', 'decision', 'api', 'email', 'form', 'document', 'wait', 'start', 'end'];
            const issueTypes = ['error', 'warning'];
            const changeTypes = ['fix', 'new', 'removed', 'unchanged'];
            
            const saveCurrentBlock = () => {
                if (currentBlock && currentSection) {
                    flow[currentSection].blocks.push(currentBlock);
                    blockNameToId[currentBlock.name.toLowerCase()] = currentBlock.id;
                }
            };
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // Flow title (# Title)
                if (line.match(/^#\s+(.+)$/) && !line.match(/^##/)) {
                    const match = line.match(/^#\s+(.+)$/);
                    flow.name = match[1].trim();
                    continue;
                }
                
                // Section headers (## AS-IS or ## TO-BE or ## Current or ## Proposed)
                if (line.match(/^##\s+(AS-IS|Current|TO-BE|Proposed)/i)) {
                    saveCurrentBlock();
                    currentBlock = null;
                    if (line.match(/AS-IS|Current/i)) {
                        currentSection = 'current';
                    } else {
                        currentSection = 'proposed';
                    }
                    continue;
                }
                
                // Block header (### Step Name or ### 1. Step Name)
                if (line.match(/^###\s+(.+)$/)) {
                    saveCurrentBlock();
                    const match = line.match(/^###\s+(?:\d+\.\s*)?(.+)$/);
                    let name = match[1].trim();
                    
                    // Check for tags in parentheses: (Fix), (New), (Issue), etc.
                    let changeType = null;
                    let issueType = null;
                    const tagMatch = name.match(/\((\w+)\)\s*$/);
                    if (tagMatch) {
                        const tag = tagMatch[1].toLowerCase();
                        if (changeTypes.includes(tag)) changeType = tag;
                        if (issueTypes.includes(tag)) issueType = tag;
                        name = name.replace(/\s*\(\w+\)\s*$/, '');
                    }
                    
                    blockIdCounter++;
                    currentBlock = {
                        id: 'block_' + blockIdCounter,
                        name: name,
                        description: '',
                        x: 96,
                        y: 96 + (flow[currentSection]?.blocks.length || 0) * 168,
                        outputs: 1,
                        issueType: issueType,
                        issueText: '',
                        changeType: currentSection === 'proposed' ? (changeType || 'new') : null,
                        fixText: '',
                        status: currentSection === 'proposed' ? 'todo' : null,
                        owner: '',
                        systems: '',
                        timeEstimate: '',
                        priority: '',
                        stepType: null,
                        config: {},
                        comments: [],
                        preconditions: '',
                        validation: '',
                        errorPath: '',
                        systemLink: ''
                    };
                    continue;
                }
                
                // Block properties (- **Property**: Value or - Property: Value)
                if (currentBlock && line.match(/^[-*]\s+/)) {
                    const propMatch = line.match(/^[-*]\s+\*?\*?([^:*]+)\*?\*?:\s*(.*)$/);
                    if (propMatch) {
                        const prop = propMatch[1].toLowerCase().trim();
                        const value = propMatch[2].trim();
                        
                        switch (prop) {
                            case 'description':
                            case 'desc':
                                currentBlock.description = value;
                                break;
                            case 'type':
                            case 'step type':
                                if (stepTypes.includes(value.toLowerCase())) {
                                    currentBlock.stepType = value.toLowerCase();
                                }
                                break;
                            case 'issue':
                            case 'problem':
                                currentBlock.issueType = currentBlock.issueType || 'error';
                                currentBlock.issueText = value;
                                break;
                            case 'warning':
                                currentBlock.issueType = 'warning';
                                currentBlock.issueText = value;
                                break;
                            case 'fix':
                            case 'solution':
                                currentBlock.changeType = 'fix';
                                currentBlock.fixText = value;
                                break;
                            case 'owner':
                            case 'assigned':
                            case 'assignee':
                                currentBlock.owner = value;
                                break;
                            case 'time':
                            case 'estimate':
                            case 'duration':
                                currentBlock.timeEstimate = value;
                                break;
                            case 'priority':
                                currentBlock.priority = value;
                                break;
                            case 'systems':
                            case 'system':
                                currentBlock.systems = value;
                                break;
                            case 'status':
                                currentBlock.status = value.toLowerCase();
                                break;
                            case 'preconditions':
                            case 'precondition':
                                currentBlock.preconditions = value;
                                break;
                            case 'validation':
                                currentBlock.validation = value;
                                break;
                            case 'error path':
                            case 'errorpath':
                                currentBlock.errorPath = value;
                                break;
                            case 'link':
                            case 'system link':
                                currentBlock.systemLink = value;
                                break;
                        }
                    }
                    
                    // Connection syntax:  Next Step or -> Next Step [Label]
                    const connMatch = line.match(/^[-*]\s+(?:|->|connects? to|next)\s+(.+?)(?:\s+\[([^\]]+)\])?$/i);
                    if (connMatch && currentBlock) {
                        pendingConnections.push({
                            fromId: currentBlock.id,
                            toName: connMatch[1].trim().toLowerCase(),
                            label: connMatch[2] || '',
                            section: currentSection
                        });
                    }
                    continue;
                }
                
                // Plain description line (if no property marker and we have a block)
                if (currentBlock && line && !line.startsWith('#') && !line.startsWith('-') && !line.startsWith('*')) {
                    if (!currentBlock.description) {
                        currentBlock.description = line;
                    } else {
                        currentBlock.description += ' ' + line;
                    }
                }
            }
            
            // Save last block
            saveCurrentBlock();
            
            // Process connections
            pendingConnections.forEach((conn, idx) => {
                const toId = blockNameToId[conn.toName];
                if (toId) {
                    flow[conn.section].connections.push({
                        id: 'conn_' + (idx + 1),
                        from: conn.fromId,
                        portIndex: 0,
                        to: toId,
                        label: conn.label
                    });
                }
            });
            
            return flow;
        }

        showImportDiffModal(data, filename) {
            const body = document.getElementById('importModalBody');
            const footer = document.getElementById('importModalFooter');
            
            // Check if we have a matching flow by name (without timestamp suffix)
            const baseName = data.name?.replace(/\s*\(imported\)\s*$/, '').trim();
            const existingFlow = Object.values(this.flows).find(f => f.name === baseName || f.name === data.name?.replace(/\s*\(imported\)\s*$/, ''));
            
            // Build import info
            const importedBlocks = [...(data.current?.blocks || []), ...(data.proposed?.blocks || [])];
            const importedCurrentCount = (data.current?.blocks || []).length;
            const importedProposedCount = (data.proposed?.blocks || []).length;
            const importedIssues = (data.current?.blocks || []).filter(b => b.issueType).length;
            const exportedAt = data.exportedAt ? new Date(data.exportedAt).toLocaleString() : 'Unknown';
            
            let diffHtml = '';
            let canMerge = false;
            let added = [], changed = [], removed = [];
            
            if (existingFlow && this.currentFlowId) {
                // Compare with current loaded flow
                canMerge = true;
                const currentBlocks = Array.from(this.current.blocks.values());
                const proposedBlocks = Array.from(this.proposed.blocks.values());
                const existingBlocksMap = new Map([...currentBlocks, ...proposedBlocks].map(b => [b.id, b]));
                const importBlocksMap = new Map(importedBlocks.map(b => [b.id, b]));
                
                // Find added blocks (in import but not in existing)
                importedBlocks.forEach(b => {
                    if (!existingBlocksMap.has(b.id)) {
                        added.push(b);
                    }
                });
                
                // Find removed blocks (in existing but not in import)
                [...currentBlocks, ...proposedBlocks].forEach(b => {
                    if (!importBlocksMap.has(b.id)) {
                        removed.push(b);
                    }
                });
                
                // Find changed blocks
                importedBlocks.forEach(b => {
                    const existing = existingBlocksMap.get(b.id);
                    if (existing) {
                        const changes = [];
                        if (b.name !== existing.name) changes.push('name');
                        if (b.description !== existing.description) changes.push('description');
                        if (b.issueType !== existing.issueType) changes.push('issue');
                        if (b.issueText !== existing.issueText) changes.push('issue text');
                        if (b.changeType !== existing.changeType) changes.push('change type');
                        if (b.fixText !== existing.fixText) changes.push('fix text');
                        if ((b.comments?.length || 0) !== (existing.comments?.length || 0)) changes.push('comments');
                        if (changes.length > 0) {
                            changed.push({ block: b, changes });
                        }
                    }
                });
                
                // New comments count
                let newComments = 0;
                importedBlocks.forEach(b => {
                    const existing = existingBlocksMap.get(b.id);
                    if (existing && b.comments?.length > (existing.comments?.length || 0)) {
                        newComments += b.comments.length - (existing.comments?.length || 0);
                    }
                });
                
                diffHtml = `
                    <div class="import-info">
                        <div class="import-info-row"><span class="import-info-label">File:</span><span>${filename}</span></div>
                        <div class="import-info-row"><span class="import-info-label">Exported:</span><span>${exportedAt}</span></div>
                        <div class="import-info-row"><span class="import-info-label">Comparing to:</span><span>${this.flows[this.currentFlowId]?.name || 'Current flow'}</span></div>
                    </div>
                    <div class="diff-summary">
                        <div class="diff-stat"><div class="diff-stat-value added">${added.length}</div><div class="diff-stat-label">Added</div></div>
                        <div class="diff-stat"><div class="diff-stat-value changed">${changed.length}</div><div class="diff-stat-label">Changed</div></div>
                        <div class="diff-stat"><div class="diff-stat-value removed">${removed.length}</div><div class="diff-stat-label">Removed</div></div>
                    </div>
                `;
                
                if (added.length > 0) {
                    diffHtml += `<div class="diff-section"><div class="diff-section-title"> New Blocks <span class="count">${added.length}</span></div>`;
                    added.forEach(b => { diffHtml += `<div class="diff-item added"><span class="diff-item-icon"></span><span class="diff-item-name">${b.name}</span></div>`; });
                    diffHtml += '</div>';
                }
                
                if (changed.length > 0) {
                    diffHtml += `<div class="diff-section"><div class="diff-section-title"> Modified Blocks <span class="count">${changed.length}</span></div>`;
                    changed.forEach(c => { diffHtml += `<div class="diff-item changed"><span class="diff-item-icon"></span><span class="diff-item-name">${c.block.name}</span><span class="diff-item-detail">${c.changes.join(', ')}</span></div>`; });
                    diffHtml += '</div>';
                }
                
                if (removed.length > 0) {
                    diffHtml += `<div class="diff-section"><div class="diff-section-title"> Removed Blocks <span class="count">${removed.length}</span></div>`;
                    removed.forEach(b => { diffHtml += `<div class="diff-item removed"><span class="diff-item-icon"></span><span class="diff-item-name">${b.name}</span></div>`; });
                    diffHtml += '</div>';
                }
                
                if (added.length === 0 && changed.length === 0 && removed.length === 0) {
                    diffHtml += '<div style="text-align:center;padding:20px;color:var(--text-muted);"><div style="font-size:24px;margin-bottom:8px;"></div>No differences found</div>';
                }
                
            } else {
                // No matching flow - just show import info
                diffHtml = `
                    <div class="import-info">
                        <div class="import-info-row"><span class="import-info-label">File:</span><span>${filename}</span></div>
                        <div class="import-info-row"><span class="import-info-label">Name:</span><span>${data.name || 'Untitled'}</span></div>
                        <div class="import-info-row"><span class="import-info-label">Exported:</span><span>${exportedAt}</span></div>
                    </div>
                    <div class="diff-summary">
                        <div class="diff-stat"><div class="diff-stat-value">${importedCurrentCount}</div><div class="diff-stat-label">Current Steps</div></div>
                        <div class="diff-stat"><div class="diff-stat-value">${importedProposedCount}</div><div class="diff-stat-label">Proposed Steps</div></div>
                        <div class="diff-stat"><div class="diff-stat-value" style="color:var(--red);">${importedIssues}</div><div class="diff-stat-label">Issues</div></div>
                    </div>
                    <div style="text-align:center;padding:16px;color:var(--text-muted);font-size:12px;">This will be imported as a new analysis.</div>
                `;
            }
            
            body.innerHTML = diffHtml;
            
            // Footer with action buttons
            this.importDiffData = { added, changed, removed, canMerge };
            footer.innerHTML = `
                <button class="btn" id="importCancelBtn">Cancel</button>
                ${canMerge && (added.length > 0 || changed.length > 0) ? '<button class="btn btn-merge" id="importMergeBtn"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="12" height="12"><path d="M8 6v6m0 0v6m0-6h8m-8 0H0"/></svg>Merge Changes</button>' : ''}
                <button class="btn btn-primary" id="importReplaceBtn">${canMerge ? 'Replace All' : 'Import'}</button>
            `;
            
            footer.querySelector('#importCancelBtn').addEventListener('click', () => this.hideModal('importModal'));
            footer.querySelector('#importReplaceBtn').addEventListener('click', () => this.doImport('replace'));
            footer.querySelector('#importMergeBtn')?.addEventListener('click', () => this.doImport('merge'));
            
            this.hideModal('flowModal');
            this.showModal('importModal');
        }

        doImport(mode) {
            const data = this.pendingImport;
            if (!data) return;
            
            if (mode === 'merge' && this.currentFlowId && this.importDiffData?.canMerge) {
                // Merge: add new blocks, update changed blocks, keep removed blocks
                const { added, changed } = this.importDiffData;
                
                // Add new blocks with normalization
                added.forEach(b => {
                    const isCurrentPane = (data.current?.blocks || []).some(cb => cb.id === b.id);
                    const pane = isCurrentPane ? this.current : this.proposed;
                    const paneId = isCurrentPane ? 'current' : 'proposed';
                    // Normalize block to ensure all properties exist
                    const block = this.normalizeBlock(b, paneId);
                    pane.blocks.set(block.id, block);
                    this.renderBlock(block, paneId);
                    const num = parseInt(block.id.split('_')[1]) || 0;
                    if (num >= this.blockIdCounter) this.blockIdCounter = num + 1;
                });
                
                // Update changed blocks
                changed.forEach(c => {
                    const b = c.block;
                    let pane = this.current.blocks.has(b.id) ? this.current : this.proposed;
                    let paneId = this.current.blocks.has(b.id) ? 'current' : 'proposed';
                    const existing = pane.blocks.get(b.id);
                    if (existing) {
                        // Merge: keep position, merge comments
                        const mergedComments = [...(existing.comments || [])];
                        (b.comments || []).forEach(newComment => {
                            if (!mergedComments.some(ec => ec.date === newComment.date && ec.text === newComment.text)) {
                                mergedComments.push(newComment);
                            }
                        });
                        // Normalize merged block
                        const merged = this.normalizeBlock({ ...b, x: existing.x, y: existing.y, comments: mergedComments }, paneId);
                        pane.blocks.set(b.id, merged);
                        this.updateBlockElement(merged, paneId);
                    }
                });
                
                // Merge connections with normalization
                ['current', 'proposed'].forEach(paneKey => {
                    const importConns = data[paneKey]?.connections || [];
                    const pane = paneKey === 'current' ? this.current : this.proposed;
                    importConns.forEach(ic => {
                        if (!pane.connections.some(c => c.from === ic.from && c.to === ic.to && c.portIndex === ic.portIndex)) {
                            pane.connections.push(this.normalizeConnection(ic));
                        }
                    });
                    this.updateConnections(paneKey);
                });
                
                // Merge issue-fix links
                (data.issueFixLinks || []).forEach(link => {
                    if (!this.issueFixLinks.some(l => l.issueId === link.issueId && l.fixId === link.fixId)) {
                        this.issueFixLinks.push(link);
                    }
                });
                
                this.updateBlockList();
                this.updateMinimap();
                this.updateValidation();
                this.updateInstructions();
                this.saveCurrentFlow(); // Save merged changes to Drive
                this.hideModal('importModal');
                this.toast(`Merged: ${added.length} added, ${changed.length} updated`, 'success');
                
            } else {
                // Replace: create new flow in Drive
                const id = 'flow_' + Date.now();
                data.id = id;
                data.name = (data.name || 'Imported Flow') + ' (imported)';
                data.createdAt = data.createdAt || new Date().toISOString();
                data.updatedAt = new Date().toISOString();
                data.environment = data.environment || 'other';
                
                // Normalize all blocks and connections before saving
                // This ensures all properties exist with proper defaults
                if (data.current?.blocks) {
                    data.current.blocks = data.current.blocks.map(b => this.normalizeBlock(b, 'current'));
                }
                if (data.current?.connections) {
                    data.current.connections = data.current.connections.map(c => this.normalizeConnection(c));
                }
                if (data.proposed?.blocks) {
                    data.proposed.blocks = data.proposed.blocks.map(b => this.normalizeBlock(b, 'proposed'));
                }
                if (data.proposed?.connections) {
                    data.proposed.connections = data.proposed.connections.map(c => this.normalizeConnection(c));
                }
                
                this.driveFlows[id] = data;
                this.saveToDrive(data);
                this.loadFlow(id, true);
                this.hideModal('importModal');
                this.hideDashboard();
                this.toast('Flow imported', 'success');
            }
            
            this.pendingImport = null;
        }

        updateFlowSelector() { 
            const flow = this.currentFlowIsDrive ? this.driveFlows[this.currentFlowId] : this.flows[this.currentFlowId];
            document.getElementById('currentFlowName').textContent = this.currentFlowId ? (flow?.name || 'Untitled') : 'Select analysis...';
            // Update environment badge
            this.updateEnvBadge(flow?.environment);
        }
        showFlowModal() { this.renderFlowList(); this.showModal('flowModal'); document.getElementById('newFlowName').focus(); }

        renderTemplates() {
            const grid = document.getElementById('templateGrid');
            grid.innerHTML = TEMPLATES.map(t => `<div class="template-item" data-template="${t.id}"><div class="template-item-icon">${t.icon}</div><div class="template-item-name">${t.name}</div><div class="template-item-desc">${t.desc}</div></div>`).join('');
            grid.querySelectorAll('.template-item').forEach(item => item.addEventListener('click', () => { const nameInput = document.getElementById('newFlowName'); if (!nameInput.value.trim()) nameInput.value = item.querySelector('.template-item-name').textContent; this.createFlow(item.dataset.template); }));
        }

        renderFlowList() {
            const list = document.getElementById('flowList');
            const flows = this.driveFlows;
            const flowIds = Object.keys(flows).sort((a, b) => new Date(flows[b].updatedAt || 0) - new Date(flows[a].updatedAt || 0));
            
            if (flowIds.length === 0) { 
                list.innerHTML = '<div style="text-align:center;padding:16px;color:var(--text-muted);font-size:12px;">No flows yet. Create your first one!</div>'; 
                return; 
            }
            
            list.innerHTML = flowIds.map(id => {
                const flow = flows[id];
                const date = flow.updatedAt ? new Date(flow.updatedAt).toLocaleDateString() : '';
                const issueCount = (flow.current?.blocks || []).filter(b => b.issueType).length;
                return `<div class="flow-item ${id === this.currentFlowId ? 'active' : ''}" data-id="${id}"><div class="flow-item-info"><div class="flow-item-name">${flow.name}</div><div class="flow-item-meta">${(flow.current?.blocks || []).length} steps${issueCount > 0 ? `  ${issueCount} issues` : ''}${date ? `  ${date}` : ''}</div></div><div class="flow-item-actions"><button class="flow-item-btn danger" data-action="delete" title="Delete"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="12" height="12"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg></button></div></div>`;
            }).join('');
            
            list.querySelectorAll('.flow-item').forEach(item => item.addEventListener('click', e => { 
                if (e.target.closest('[data-action="delete"]')) { 
                    e.stopPropagation(); 
                    this.deleteFlow(item.dataset.id, true);
                } else { 
                    this.loadFlow(item.dataset.id, true); 
                    this.hideModal('flowModal');
                    this.hideDashboard();
                } 
            }));
        }

        copyCurrentToProposed() {
            if (this.proposed.blocks.size > 0 && !confirm('Replace proposed flow?')) return;
            const els = this.getPaneElements('proposed');
            els.blocksContainer.innerHTML = '';
            this.proposed.blocks.clear();
            this.proposed.connections = [];
            const idMap = new Map();
            this.current.blocks.forEach(block => {
                const newId = 'block_' + (++this.blockIdCounter);
                idMap.set(block.id, newId);
                const newBlock = { ...JSON.parse(JSON.stringify(block)), id: newId, changeType: block.issueType ? 'fix' : null, fixText: '', status: block.issueType ? 'todo' : null, linkedIssueId: block.issueType ? block.id : null };
                delete newBlock.issueType;
                delete newBlock.issueText;
                this.proposed.blocks.set(newId, newBlock);
                this.renderBlock(newBlock, 'proposed');
            });
            this.proposed.connections = this.current.connections.map(conn => ({ ...conn, id: 'conn_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5), from: idMap.get(conn.from), to: idMap.get(conn.to) }));
            this.current.blocks.forEach(block => { if (block.issueType) { const fixBlockId = idMap.get(block.id); this.issueFixLinks.push({ issueId: block.id, fixId: fixBlockId }); } });
            this.updateConnections('proposed');
            this.updateInstructions();
            this.updateBlockList();
            this.updateMinimap();
            this.updateValidation();
            this.renderPanel();
            setTimeout(() => this.zoomToFit('proposed'), 100);
            this.toast('Copied to proposed', 'success');
        }
        
        setViewMode(mode) {
            this.viewMode = mode;
            const split = document.getElementById('canvasSplit');
            split.classList.remove('view-current', 'view-proposed');
            if (mode === 'current') split.classList.add('view-current');
            else if (mode === 'proposed') split.classList.add('view-proposed');
            
            document.getElementById('viewCurrentBtn').classList.toggle('active', mode === 'current');
            document.getElementById('viewSplitBtn').classList.toggle('active', mode === 'split');
            document.getElementById('viewProposedBtn').classList.toggle('active', mode === 'proposed');
            
            // Re-draw connections and fit zoom after view change
            // Connections must be redrawn because getBoundingClientRect doesn't work on hidden panes
            setTimeout(() => {
                if (mode === 'current' || mode === 'split') {
                    this.updateConnections('current');
                    this.zoomToFit('current');
                }
                if (mode === 'proposed' || mode === 'split') {
                    this.updateConnections('proposed');
                    this.zoomToFit('proposed');
                }
            }, 50);
        }
        
        promoteToCurrentState() {
            if (this.proposed.blocks.size === 0) {
                this.toast('No proposed changes to promote', 'warning');
                return;
            }
            if (!confirm('This will replace the Current State with the Proposed State. The current issues and fixes tracking will be cleared. Continue?')) return;
            
            // Clear current
            const currentEls = this.getPaneElements('current');
            currentEls.blocksContainer.innerHTML = '';
            this.current.blocks.clear();
            this.current.connections = [];
            
            // Copy proposed to current
            const idMap = new Map();
            this.proposed.blocks.forEach(block => {
                const newId = 'block_' + (++this.blockIdCounter);
                idMap.set(block.id, newId);
                // Convert proposed block to current block (strip proposed-specific fields)
                const newBlock = { 
                    ...JSON.parse(JSON.stringify(block)), 
                    id: newId,
                    changeType: null,
                    fixText: '',
                    status: null,
                    linkedIssueId: null,
                    issueType: null,
                    issueText: ''
                };
                this.current.blocks.set(newId, newBlock);
                this.renderBlock(newBlock, 'current');
            });
            
            // Copy connections with new IDs
            this.current.connections = this.proposed.connections.map(conn => ({
                ...conn,
                id: 'conn_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5),
                from: idMap.get(conn.from) || conn.from,
                to: idMap.get(conn.to) || conn.to
            })).filter(conn => conn.from && conn.to);
            
            // Clear proposed
            const proposedEls = this.getPaneElements('proposed');
            proposedEls.blocksContainer.innerHTML = '';
            this.proposed.blocks.clear();
            this.proposed.connections = [];
            
            // Clear issue-fix links
            this.issueFixLinks = [];
            
            // Update everything
            this.updateConnections('current');
            this.updateConnections('proposed');
            this.updateInstructions();
            this.updateBlockList();
            this.updateMinimap();
            this.updateValidation();
            this.renderPanel();
            
            setTimeout(() => this.zoomToFit('current'), 100);
            this.toast('Promoted to current state', 'success');
        }

        updateInstructions() {
            document.getElementById('currentInstructions').classList.toggle('hidden', this.current.blocks.size > 0);
            document.getElementById('proposedInstructions').classList.toggle('hidden', this.proposed.blocks.size > 0);
        }

        renderPanel() { if (this.selectedBlock) this.renderPanelContent(); else this.renderOverviewPanel(); }

        renderOverviewPanel() {
            const content = document.getElementById('panelContent');
            if (!this.currentFlowId) { content.innerHTML = '<div style="text-align:center;padding:30px;color:var(--text-muted);font-size:12px;">Select or create an analysis</div>'; return; }
            const flow = this.currentFlowIsDrive ? this.driveFlows[this.currentFlowId] : this.flows[this.currentFlowId];
            if (!flow) { content.innerHTML = '<div style="text-align:center;padding:30px;color:var(--text-muted);font-size:12px;">Flow not found</div>'; return; }
            const currentBlocks = Array.from(this.current.blocks.values());
            const proposedBlocks = Array.from(this.proposed.blocks.values());
            const issues = currentBlocks.filter(b => b.issueType === 'error').length;
            const warnings = currentBlocks.filter(b => b.issueType === 'warning').length;
            const fixes = proposedBlocks.filter(b => b.changeType === 'fix' || b.fixText).length;
            const newSteps = proposedBlocks.filter(b => b.changeType === 'new').length;
            const storageInfo = this.currentFlowIsDrive ? '<div style="display:flex;align-items:center;gap:4px;font-size:10px;color:#4285f4;margin-bottom:12px;"><svg viewBox="0 0 24 24" fill="currentColor" width="14" height="14"><path d="M7.71 3.5L1.15 15l3.43 6 6.55-11.5L7.71 3.5zm1.73 0l6.55 11.5H22L15.45 3.5H9.44zm6.47 12.5H3.33l3.42 6h12.9l-3.44-6z"/></svg>Saved in Google Drive</div>' : '';
            content.innerHTML = `${storageInfo}<div class="form-group"><label class="form-label">Analysis Name</label><input type="text" class="form-input" id="flowNameInput" value="${flow.name || ''}" /></div><div class="form-group"><label class="form-label">Description</label><textarea class="form-input" id="flowDescInput" placeholder="Describe the process...">${flow.description || ''}</textarea></div><div class="section-divider"><div class="section-title">Summary</div><div class="summary-grid"><div class="summary-stat"><div class="summary-stat-value issues">${issues}</div><div class="summary-stat-label">Issues</div></div><div class="summary-stat"><div class="summary-stat-value warnings">${warnings}</div><div class="summary-stat-label">Warnings</div></div><div class="summary-stat"><div class="summary-stat-value fixes">${fixes}</div><div class="summary-stat-label">Fixes</div></div><div class="summary-stat"><div class="summary-stat-value new">${newSteps}</div><div class="summary-stat-label">New</div></div></div></div><div class="section-divider"><div class="section-title"><span class="dot" style="background:var(--orange);"></span>Current: ${currentBlocks.length} steps</div><div class="section-title"><span class="dot" style="background:var(--green);"></span>Proposed: ${proposedBlocks.length} steps</div></div>`;
            content.querySelector('#flowNameInput')?.addEventListener('input', e => { 
                const flow = this.currentFlowIsDrive ? this.driveFlows[this.currentFlowId] : this.flows[this.currentFlowId];
                if (flow) flow.name = e.target.value;
                this.updateFlowSelector(); 
            });
            content.querySelector('#flowDescInput')?.addEventListener('input', e => { 
                const flow = this.currentFlowIsDrive ? this.driveFlows[this.currentFlowId] : this.flows[this.currentFlowId];
                if (flow) flow.description = e.target.value; 
            });
        }

        renderPanelContent() {
            if (!this.selectedBlock) { this.renderOverviewPanel(); return; }
            const content = document.getElementById('panelContent');
            const block = this.selectedBlock;
            const paneId = this.activePane;
            if (this.activeTab === 'details') { content.innerHTML = this.getDetailsTabHtml(block, paneId); this.bindDetailsTabEvents(block, paneId); }
            else if (this.activeTab === 'comments') { content.innerHTML = this.getCommentsTabHtml(block); this.bindCommentsTabEvents(block, paneId); }
            else if (this.activeTab === 'history') { content.innerHTML = this.getHistoryTabHtml(); }
        }

        getDetailsTabHtml(block, paneId) {
            const isCurrentPane = paneId === 'current';
            
            // Helper blocks have simplified panel
            if (block.isHelper) {
                let html = `
                    <div class="form-group">
                        <label class="form-label">Note Title</label>
                        <input type="text" class="form-input" id="blockNameInput" value="${block.name || ''}" placeholder="Note title..." />
                    </div>
                    <div class="form-group">
                        <label class="form-label">Content</label>
                        <textarea class="form-input" id="blockDescInput" rows="6" placeholder="Add helpful context, tips, or explanations...">${block.description || ''}</textarea>
                    </div>
                    <div class="section-divider">
                        <div class="section-title" style="color:var(--purple);"> Note Block</div>
                        <p style="font-size:10px;color:var(--text-muted);margin:4px 0 0 0;">Helper notes are for documentation purposes and don't connect to the flow.</p>
                    </div>
                `;
                return html;
            }
            
            let html = `<div class="form-group"><label class="form-label">Step Name</label><input type="text" class="form-input" id="blockNameInput" value="${block.name || ''}" /></div><div class="form-group"><label class="form-label">Description</label><textarea class="form-input" id="blockDescInput" placeholder="What does this step do?">${block.description || ''}</textarea></div>`;
            
            if (this.mode === 'dev') {
                // DEV MODE: Show ALL fields from all modes combined
                
                // === ACTOR TYPE ===
                html += `<div class="section-divider"><div class="section-title" style="color:var(--cyan);"> Actor (Who does this?)</div><div class="actor-selector" id="actorSelector"><div class="actor-option user ${block.actor === 'user' ? 'selected' : ''}" data-actor="user"><div class="actor-option-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">${ACTOR_TYPES.user.icon}</svg></div><div class="actor-option-label">User</div></div><div class="actor-option system ${block.actor === 'system' ? 'selected' : ''}" data-actor="system"><div class="actor-option-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">${ACTOR_TYPES.system.icon}</svg></div><div class="actor-option-label">System</div></div><div class="actor-option admin ${block.actor === 'admin' ? 'selected' : ''}" data-actor="admin"><div class="actor-option-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">${ACTOR_TYPES.admin.icon}</svg></div><div class="actor-option-label">Admin</div></div></div></div>`;
                
                // === CONFIGURE: Step Type ===
                html += `<div class="section-divider"><div class="section-title" style="color:var(--purple);"> Step Type</div><div class="type-grid" id="typeGrid">${Object.entries(STEP_TYPES).map(([key, type]) => `<div class="type-option ${block.stepType === key ? 'selected' : ''}" data-type="${key}"><div class="type-option-icon" style="background:${type.color}"><svg viewBox="0 0 24 24">${type.icon}</svg></div><div class="type-option-name">${type.name}</div></div>`).join('')}</div></div>`;
                
                // === SKETCH: Metadata ===
                html += `<div class="section-divider"><div class="section-title" style="color:var(--purple);"> Metadata</div><div class="form-row"><div class="form-group"><label class="form-label">Owner</label><input type="text" class="form-input" id="ownerInput" value="${block.owner || ''}" placeholder="Team/Person" /></div><div class="form-group"><label class="form-label">Time</label><input type="text" class="form-input" id="timeInput" value="${block.timeEstimate || ''}" placeholder="5 min" /></div></div><div class="form-row"><div class="form-group"><label class="form-label">Systems</label><input type="text" class="form-input" id="systemsInput" value="${block.systems || ''}" placeholder="CRM, API..." /></div><div class="form-group"><label class="form-label">Priority</label><select class="form-select" id="prioritySelect"><option value="">None</option>${PRIORITIES.map(p => `<option value="${p}" ${block.priority === p ? 'selected' : ''}>${p.charAt(0).toUpperCase() + p.slice(1)}</option>`).join('')}</select></div></div></div>`;
                
                // === SKETCH: Issue/Change marking (pane dependent) ===
                if (isCurrentPane) {
                    html += `<div class="section-divider"><div class="section-title" style="color:var(--red);"> Issue Marking</div><div class="option-grid"><div class="option-item ${block.issueType === 'error' ? 'selected error' : ''}" data-issue="error"><div class="option-item-icon"><svg viewBox="0 0 24 24" fill="none" stroke="${block.issueType === 'error' ? 'var(--red)' : 'currentColor'}" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/></svg></div><div class="option-item-label">Issue</div></div><div class="option-item ${block.issueType === 'warning' ? 'selected warning' : ''}" data-issue="warning"><div class="option-item-icon"><svg viewBox="0 0 24 24" fill="none" stroke="${block.issueType === 'warning' ? 'var(--orange)' : 'currentColor'}" stroke-width="2"><path d="M10.29 3.86L1.82 18a2 2 0 001.71 3h16.94a2 2 0 001.71-3L13.71 3.86a2 2 0 00-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg></div><div class="option-item-label">Warning</div></div></div><div class="form-group" style="margin-top:8px;"><label class="form-label">What's wrong?</label><textarea class="form-input" id="issueTextInput" placeholder="Describe the problem...">${block.issueText || ''}</textarea></div>${block.issueType ? '<button class="btn" id="clearIssueBtn" style="width:100%;font-size:10px;">Clear Issue</button>' : ''}</div>`;
                } else {
                    const linkedIssue = this.getLinkedIssue(block.id);
                    html += `<div class="section-divider"><div class="section-title" style="color:var(--green);"> Change Type</div><div class="option-grid"><div class="option-item ${block.changeType === 'fix' ? 'selected fix' : ''}" data-change="fix"><div class="option-item-icon"></div><div class="option-item-label">Fix</div></div><div class="option-item ${block.changeType === 'new' ? 'selected new' : ''}" data-change="new"><div class="option-item-icon"></div><div class="option-item-label">New</div></div><div class="option-item ${block.changeType === 'modified' ? 'selected' : ''}" data-change="modified"><div class="option-item-icon"></div><div class="option-item-label">Modified</div></div><div class="option-item ${block.changeType === 'removed' ? 'selected' : ''}" data-change="removed"><div class="option-item-icon"></div><div class="option-item-label">Remove</div></div></div></div>`;
                    html += `<div class="form-group"><label class="form-label">Fix Description</label><textarea class="form-input" id="fixTextInput" placeholder="Explain the fix...">${block.fixText || ''}</textarea></div>`;
                    html += `<div class="form-group"><label class="form-label">Link to Issue</label><div class="link-selector">${linkedIssue ? `<div class="link-selector-current"><span> ${linkedIssue.name}</span><button class="link-selector-btn" id="unlinkIssueBtn">Unlink</button></div>` : `<div class="link-selector-label">Connect to an issue</div><div class="link-selector-list" id="issueLinkList">${this.getIssueLinkListHtml()}</div>`}</div></div>`;
                    html += `<div class="form-group"><label class="form-label">Status</label><select class="form-select" id="statusSelect"><option value="">None</option>${STATUSES.map(s => `<option value="${s}" ${block.status === s ? 'selected' : ''}>${s.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ')}</option>`).join('')}</select></div>`;
                }
                
                // === DETAIL: Technical specs ===
                html += `<div class="section-divider"><div class="section-title" style="color:var(--purple);"> Technical Details</div></div>`;
                html += `<div class="form-group"><label class="form-label">Preconditions</label><textarea class="form-input" id="preconditionsInput" placeholder="What must be true before this step?">${block.preconditions || ''}</textarea></div>`;
                html += `<div class="form-group"><label class="form-label">Validation Rules</label><textarea class="form-input" id="validationInput" placeholder="What checks should happen?">${block.validation || ''}</textarea></div>`;
                html += `<div class="form-group"><label class="form-label">On Failure</label><input type="text" class="form-input" id="errorPathInput" value="${block.errorPath || ''}" placeholder="What happens when this fails?" /></div>`;
                html += `<div class="form-group"><label class="form-label">System Link</label><input type="text" class="form-input" id="systemLinkInput" value="${block.systemLink || ''}" placeholder="URL to screen, docs, or code..." /></div>`;
                
            } else if (this.mode === 'sketch') {
                // Sketch mode: actor + metadata + issue/change marking
                html += `<div class="section-divider"><div class="section-title">Actor (Who does this?)</div><div class="actor-selector" id="actorSelector"><div class="actor-option user ${block.actor === 'user' ? 'selected' : ''}" data-actor="user"><div class="actor-option-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">${ACTOR_TYPES.user.icon}</svg></div><div class="actor-option-label">User</div></div><div class="actor-option system ${block.actor === 'system' ? 'selected' : ''}" data-actor="system"><div class="actor-option-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">${ACTOR_TYPES.system.icon}</svg></div><div class="actor-option-label">System</div></div><div class="actor-option admin ${block.actor === 'admin' ? 'selected' : ''}" data-actor="admin"><div class="actor-option-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">${ACTOR_TYPES.admin.icon}</svg></div><div class="actor-option-label">Admin</div></div></div></div>`;
                html += `<div class="section-divider"><div class="section-title">Metadata</div><div class="form-row"><div class="form-group"><label class="form-label">Owner</label><input type="text" class="form-input" id="ownerInput" value="${block.owner || ''}" placeholder="Team/Person" /></div><div class="form-group"><label class="form-label">Time</label><input type="text" class="form-input" id="timeInput" value="${block.timeEstimate || ''}" placeholder="5 min" /></div></div><div class="form-row"><div class="form-group"><label class="form-label">Systems</label><input type="text" class="form-input" id="systemsInput" value="${block.systems || ''}" placeholder="CRM, API..." /></div><div class="form-group"><label class="form-label">Priority</label><select class="form-select" id="prioritySelect"><option value="">None</option>${PRIORITIES.map(p => `<option value="${p}" ${block.priority === p ? 'selected' : ''}>${p.charAt(0).toUpperCase() + p.slice(1)}</option>`).join('')}</select></div></div></div>`;
                if (isCurrentPane) {
                    html += `<div class="section-divider"><div class="section-title"><span class="dot" style="background:var(--red);"></span>Issue Marking</div><div class="option-grid"><div class="option-item ${block.issueType === 'error' ? 'selected error' : ''}" data-issue="error"><div class="option-item-icon"><svg viewBox="0 0 24 24" fill="none" stroke="${block.issueType === 'error' ? 'var(--red)' : 'currentColor'}" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/></svg></div><div class="option-item-label">Issue</div></div><div class="option-item ${block.issueType === 'warning' ? 'selected warning' : ''}" data-issue="warning"><div class="option-item-icon"><svg viewBox="0 0 24 24" fill="none" stroke="${block.issueType === 'warning' ? 'var(--orange)' : 'currentColor'}" stroke-width="2"><path d="M10.29 3.86L1.82 18a2 2 0 001.71 3h16.94a2 2 0 001.71-3L13.71 3.86a2 2 0 00-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg></div><div class="option-item-label">Warning</div></div></div><div class="form-group" style="margin-top:8px;"><label class="form-label">What's wrong?</label><textarea class="form-input" id="issueTextInput" placeholder="Describe the problem...">${block.issueText || ''}</textarea></div>${block.issueType ? '<button class="btn" id="clearIssueBtn" style="width:100%;font-size:10px;">Clear Issue</button>' : ''}</div>`;
                } else {
                    const linkedIssue = this.getLinkedIssue(block.id);
                    html += `<div class="section-divider"><div class="section-title"><span class="dot" style="background:var(--green);"></span>Change Type</div><div class="option-grid"><div class="option-item ${block.changeType === 'fix' ? 'selected fix' : ''}" data-change="fix"><div class="option-item-icon"></div><div class="option-item-label">Fix</div></div><div class="option-item ${block.changeType === 'new' ? 'selected new' : ''}" data-change="new"><div class="option-item-icon"></div><div class="option-item-label">New</div></div><div class="option-item ${block.changeType === 'modified' ? 'selected' : ''}" data-change="modified"><div class="option-item-icon"></div><div class="option-item-label">Modified</div></div><div class="option-item ${block.changeType === 'removed' ? 'selected' : ''}" data-change="removed"><div class="option-item-icon"></div><div class="option-item-label">Remove</div></div></div></div><div class="section-divider"><div class="section-title">Fix Description</div><textarea class="form-input" id="fixTextInput" placeholder="Explain the fix...">${block.fixText || ''}</textarea></div><div class="section-divider"><div class="section-title">Link to Issue</div><div class="link-selector">${linkedIssue ? `<div class="link-selector-current"><span> ${linkedIssue.name}</span><button class="link-selector-btn" id="unlinkIssueBtn">Unlink</button></div>` : `<div class="link-selector-label">Connect to an issue</div><div class="link-selector-list" id="issueLinkList">${this.getIssueLinkListHtml()}</div>`}</div></div><div class="section-divider"><div class="section-title">Status</div><select class="form-select" id="statusSelect"><option value="">None</option>${STATUSES.map(s => `<option value="${s}" ${block.status === s ? 'selected' : ''}>${s.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ')}</option>`).join('')}</select></div>`;
                }
            } else if (this.mode === 'configure') {
                // Configure mode: actor + step type selection
                html += `<div class="section-divider"><div class="section-title">Actor</div><div class="actor-selector" id="actorSelector"><div class="actor-option user ${block.actor === 'user' ? 'selected' : ''}" data-actor="user"><div class="actor-option-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">${ACTOR_TYPES.user.icon}</svg></div><div class="actor-option-label">User</div></div><div class="actor-option system ${block.actor === 'system' ? 'selected' : ''}" data-actor="system"><div class="actor-option-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">${ACTOR_TYPES.system.icon}</svg></div><div class="actor-option-label">System</div></div><div class="actor-option admin ${block.actor === 'admin' ? 'selected' : ''}" data-actor="admin"><div class="actor-option-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">${ACTOR_TYPES.admin.icon}</svg></div><div class="actor-option-label">Admin</div></div></div></div>`;
                html += `<div class="section-divider"><div class="section-title">Step Type</div><div class="type-grid" id="typeGrid">${Object.entries(STEP_TYPES).map(([key, type]) => `<div class="type-option ${block.stepType === key ? 'selected' : ''}" data-type="${key}"><div class="type-option-icon" style="background:${type.color}"><svg viewBox="0 0 24 24">${type.icon}</svg></div><div class="type-option-name">${type.name}</div></div>`).join('')}</div></div>`;
            } else if (this.mode === 'detail') {
                // Detail mode: technical specs
                html += `<div class="section-divider"><div class="section-title"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="12" height="12" style="margin-right:4px;"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>Preconditions</div><textarea class="form-input" id="preconditionsInput" placeholder="What must be true before this step?&#10; Customer has billing identity&#10; VAT number validated">${block.preconditions || ''}</textarea><div class="form-hint">Conditions that MUST be met before this step runs</div></div>`;
                html += `<div class="section-divider"><div class="section-title"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="12" height="12" style="margin-right:4px;"><path d="M9 12l2 2 4-4"/><circle cx="12" cy="12" r="10"/></svg>Validation Rules</div><textarea class="form-input" id="validationInput" placeholder="What checks should happen?&#10; Email format: name@domain.com&#10; Amount > 0&#10; Country in EU list">${block.validation || ''}</textarea><div class="form-hint">Exact rules to validate inputs/outputs</div></div>`;
                html += `<div class="section-divider"><div class="section-title"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="12" height="12" style="margin-right:4px;"><path d="M10.29 3.86L1.82 18a2 2 0 001.71 3h16.94a2 2 0 001.71-3L13.71 3.86a2 2 0 00-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>On Failure</div><input type="text" class="form-input" id="errorPathInput" value="${block.errorPath || ''}" placeholder="What happens when this fails?  Go to step X, Retry, Alert admin..." /><div class="form-hint">Where to go or what to do when this step fails</div></div>`;
                html += `<div class="section-divider"><div class="section-title"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="12" height="12" style="margin-right:4px;"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"/></svg>System Links</div><input type="text" class="form-input" id="systemLinkInput" value="${block.systemLink || ''}" placeholder="URL to screen, docs, or code..." /><div class="form-hint">Link to the actual screen, API endpoint, or documentation</div></div>`;
            }
            // Attachments section (all modes)
            const attachments = block.attachments || [];
            html += `<div class="attachments-section">
                <div class="attachments-header">
                    <span class="attachments-title">Attachments</span>
                    <button class="attachment-add-btn" id="addAttachmentBtn"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="10" height="10"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg> Add</button>
                </div>
                <div class="attachments-grid">
                    ${attachments.map(att => `
                        <div class="attachment-item" data-att-id="${att.id}">
                            <img src="${att.data}" alt="${att.name}" />
                            <div class="attachment-overlay">
                                <button class="attachment-btn" data-action="view" title="View"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg></button>
                                <button class="attachment-btn danger" data-action="remove" title="Remove"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg></button>
                            </div>
                        </div>
                    `).join('')}
                    ${attachments.length === 0 ? '<div class="attachment-placeholder" id="attachmentPlaceholder"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg></div>' : ''}
                </div>
            </div>`;
            html += `<div class="section-divider"><button class="btn" id="deleteBlockBtn" style="width:100%;justify-content:center;color:var(--red);"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="12" height="12"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>Delete Step</button></div>`;
            return html;
        }

        getIssueLinkListHtml() {
            const issues = Array.from(this.current.blocks.values()).filter(b => b.issueType);
            if (issues.length === 0) return '<div style="font-size:10px;color:var(--text-muted);padding:6px;">No issues in Current State</div>';
            return issues.map(b => `<div class="link-selector-item" data-issue-id="${b.id}"><span style="color:${b.issueType === 'error' ? 'var(--red)' : 'var(--orange)'};"></span> ${b.name}</div>`).join('');
        }

        getLinkedIssue(fixBlockId) { const link = this.issueFixLinks.find(l => l.fixId === fixBlockId); return link ? this.current.blocks.get(link.issueId) : null; }
        getLinkedFix(issueBlockId) { const link = this.issueFixLinks.find(l => l.issueId === issueBlockId); return link ? this.proposed.blocks.get(link.fixId) : null; }

        bindDetailsTabEvents(block, paneId) {
            const content = document.getElementById('panelContent');
            content.querySelector('#blockNameInput')?.addEventListener('input', e => { block.name = e.target.value; this.updateBlockElement(block, paneId); this.updateBlockList(); });
            content.querySelector('#blockDescInput')?.addEventListener('input', e => { block.description = e.target.value; this.updateBlockElement(block, paneId); });
            content.querySelector('#deleteBlockBtn')?.addEventListener('click', () => this.deleteSelectedBlock());
            content.querySelector('#ownerInput')?.addEventListener('input', e => { block.owner = e.target.value; this.updateBlockElement(block, paneId); });
            content.querySelector('#systemsInput')?.addEventListener('input', e => { block.systems = e.target.value; this.updateBlockElement(block, paneId); });
            content.querySelector('#timeInput')?.addEventListener('input', e => { block.timeEstimate = e.target.value; this.updateBlockElement(block, paneId); });
            content.querySelector('#prioritySelect')?.addEventListener('change', e => { block.priority = e.target.value; this.updateBlockElement(block, paneId); });
            content.querySelectorAll('[data-issue]').forEach(opt => opt.addEventListener('click', () => { block.issueType = block.issueType === opt.dataset.issue ? null : opt.dataset.issue; this.updateBlockElement(block, paneId); this.updateBlockList(); this.updateValidation(); this.renderPanelContent(); }));
            content.querySelector('#issueTextInput')?.addEventListener('input', e => { block.issueText = e.target.value; if (e.target.value && !block.issueType) block.issueType = 'error'; this.updateBlockElement(block, paneId); });
            content.querySelector('#clearIssueBtn')?.addEventListener('click', () => { block.issueType = null; block.issueText = ''; this.updateBlockElement(block, paneId); this.updateBlockList(); this.updateValidation(); this.renderPanelContent(); });
            content.querySelectorAll('[data-change]').forEach(opt => opt.addEventListener('click', () => { block.changeType = block.changeType === opt.dataset.change ? null : opt.dataset.change; this.updateBlockElement(block, paneId); this.updateBlockList(); this.updateValidation(); this.renderPanelContent(); }));
            content.querySelector('#fixTextInput')?.addEventListener('input', e => { block.fixText = e.target.value; this.updateBlockElement(block, paneId); });
            content.querySelector('#statusSelect')?.addEventListener('change', e => { block.status = e.target.value; this.updateBlockElement(block, paneId); });
            content.querySelectorAll('.link-selector-item').forEach(item => item.addEventListener('click', () => { const issueId = item.dataset.issueId; this.issueFixLinks = this.issueFixLinks.filter(l => l.fixId !== block.id); this.issueFixLinks.push({ issueId, fixId: block.id }); this.updateBlockElement(block, paneId); this.renderPanelContent(); this.updateValidation(); }));
            content.querySelector('#unlinkIssueBtn')?.addEventListener('click', () => { this.issueFixLinks = this.issueFixLinks.filter(l => l.fixId !== block.id); this.updateBlockElement(block, paneId); this.renderPanelContent(); this.updateValidation(); });
            content.querySelectorAll('.type-option').forEach(opt => opt.addEventListener('click', () => { block.stepType = opt.dataset.type; block.config = block.config || {}; this.updateBlockElement(block, paneId); this.renderPanelContent(); }));
            // Actor selector binding
            content.querySelectorAll('.actor-option').forEach(opt => opt.addEventListener('click', () => { block.actor = block.actor === opt.dataset.actor ? null : opt.dataset.actor; this.updateBlockElement(block, paneId); this.renderPanelContent(); }));
            // Detail mode bindings
            content.querySelector('#preconditionsInput')?.addEventListener('input', e => { block.preconditions = e.target.value; });
            content.querySelector('#validationInput')?.addEventListener('input', e => { block.validation = e.target.value; });
            content.querySelector('#errorPathInput')?.addEventListener('input', e => { block.errorPath = e.target.value; });
            content.querySelector('#systemLinkInput')?.addEventListener('input', e => { block.systemLink = e.target.value; });
            
            // Attachments
            content.querySelector('#addAttachmentBtn')?.addEventListener('click', () => this.showAttachmentUpload(block.id, paneId));
            content.querySelector('#attachmentPlaceholder')?.addEventListener('click', () => this.showAttachmentUpload(block.id, paneId));
            content.querySelectorAll('.attachment-item').forEach(item => {
                item.querySelector('[data-action="view"]')?.addEventListener('click', e => {
                    e.stopPropagation();
                    const att = (block.attachments || []).find(a => a.id === item.dataset.attId);
                    if (att) this.showImageViewer(att.data);
                });
                item.querySelector('[data-action="remove"]')?.addEventListener('click', e => {
                    e.stopPropagation();
                    this.removeAttachment(block.id, paneId, item.dataset.attId);
                });
            });
        }

        getCommentsTabHtml(block) {
            const comments = block.comments || [];
            return `<div class="comments-list">${comments.length === 0 ? '<div style="text-align:center;padding:16px;color:var(--text-muted);font-size:11px;">No comments yet</div>' : comments.map((c, i) => `<div class="comment-item"><div class="comment-header"><span class="comment-author">${c.author || 'User'}</span><span class="comment-date">${new Date(c.date).toLocaleString()}</span></div><div class="comment-text">${c.text}</div></div>`).join('')}</div><div class="comment-input-row"><input type="text" class="form-input" id="newCommentInput" placeholder="Add a comment..." /><button class="btn btn-primary" id="addCommentBtn" style="flex-shrink:0;">Add</button></div>`;
        }

        bindCommentsTabEvents(block, paneId) {
            const content = document.getElementById('panelContent');
            const input = content.querySelector('#newCommentInput');
            const addBtn = content.querySelector('#addCommentBtn');
            const addComment = () => { const text = input.value.trim(); if (!text) return; block.comments = block.comments || []; block.comments.push({ text, author: 'User', date: new Date().toISOString() }); input.value = ''; this.updateBlockElement(block, paneId); this.renderPanelContent(); };
            addBtn?.addEventListener('click', addComment);
            input?.addEventListener('keypress', e => { if (e.key === 'Enter') addComment(); });
        }

        getHistoryTabHtml() {
            if (this.versionHistory.length === 0) return '<div style="text-align:center;padding:16px;color:var(--text-muted);font-size:11px;">No history yet. Save to create snapshots.</div>';
            return `<div style="font-size:11px;color:var(--text-muted);margin-bottom:8px;">Last ${this.versionHistory.length} saves</div>${this.versionHistory.slice().reverse().map((v, i) => `<div style="padding:8px;background:var(--bg-tertiary);border-radius:5px;margin-bottom:6px;"><div style="font-size:11px;font-weight:500;">${new Date(v.timestamp).toLocaleString()}</div><div style="font-size:10px;color:var(--text-muted);">${v.current.blocks.length} current, ${v.proposed.blocks.length} proposed</div></div>`).join('')}`;
        }

        addBlock(paneId) {
            if (!this.currentFlowId) { this.showFlowModal(); return; }
            this.saveState('add-block');
            const pane = this.getPane(paneId);
            const els = this.getPaneElements(paneId);
            const rect = els.canvasArea.getBoundingClientRect();
            let x = (rect.width / 2 - pane.panX) / pane.zoom - 130;
            let y = (rect.height / 2 - pane.panY) / pane.zoom - 50;
            if (pane.blocks.size > 0) { const lastBlock = Array.from(pane.blocks.values()).pop(); x = lastBlock.x; y = lastBlock.y + 140; }
            x = Math.round(x / 24) * 24; y = Math.round(y / 24) * 24;
            const id = 'block_' + (++this.blockIdCounter);
            const block = { id, name: 'New Step', description: '', x, y, outputs: 1, issueType: null, issueText: '', changeType: paneId === 'proposed' ? 'new' : null, fixText: '', status: paneId === 'proposed' ? 'todo' : null, owner: '', systems: '', timeEstimate: '', priority: '', stepType: null, actor: null, config: {}, comments: [], preconditions: '', validation: '', errorPath: '', systemLink: '' };
            pane.blocks.set(id, block);
            this.renderBlock(block, paneId);
            this.selectBlock(block, paneId);
            this.updateInstructions();
            this.updateBlockList();
            this.updateMinimap();
            setTimeout(() => { const input = document.getElementById('blockNameInput'); if (input) { input.focus(); input.select(); } }, 100);
        }
        
        addHelperBlock(paneId) {
            if (!this.currentFlowId) { this.showFlowModal(); return; }
            this.saveState('add-helper');
            const pane = this.getPane(paneId);
            const els = this.getPaneElements(paneId);
            const rect = els.canvasArea.getBoundingClientRect();
            let x = (rect.width / 2 - pane.panX) / pane.zoom - 100;
            let y = (rect.height / 2 - pane.panY) / pane.zoom - 50;
            // Position near selected block if any
            if (this.selectedBlock && this.activePane === paneId) {
                x = this.selectedBlock.x + 280;
                y = this.selectedBlock.y;
            }
            x = Math.round(x / 24) * 24; y = Math.round(y / 24) * 24;
            const id = 'block_' + (++this.blockIdCounter);
            const block = { id, name: 'Note', description: 'Add helpful context here...', x, y, isHelper: true, outputs: 0 };
            pane.blocks.set(id, block);
            this.renderBlock(block, paneId);
            this.selectBlock(block, paneId);
            this.updateInstructions();
            this.updateMinimap();
            setTimeout(() => { const input = document.getElementById('blockDescInput'); if (input) { input.focus(); input.select(); } }, 100);
        }

        // Helper function to get pane-prefixed DOM ID for a block
        // This prevents ID collisions when same block IDs exist in both current and proposed panes
        getDomId(blockId, paneId) {
            return `${paneId}_${blockId}`;
        }
        
        renderBlock(block, paneId) {
            const els = this.getPaneElements(paneId);
            const el = document.createElement('div');
            el.className = this.getBlockClasses(block, paneId);
            el.id = this.getDomId(block.id, paneId);
            el.dataset.pane = paneId;
            el.dataset.blockId = block.id;
            el.style.left = block.x + 'px';
            el.style.top = block.y + 'px';
            el.innerHTML = this.getBlockHtml(block, paneId);
            this.bindBlockEvents(el, block, paneId);
            els.blocksContainer.appendChild(el);
        }
        
        renderBlocks(paneId) {
            const pane = this.getPane(paneId);
            const els = this.getPaneElements(paneId);
            els.blocksContainer.innerHTML = '';
            pane.blocks.forEach(block => this.renderBlock(block, paneId));
        }

        getBlockClasses(block, paneId) {
            let classes = ['block'];
            if (block.isHelper) classes.push('helper-block');
            if (block.actor) classes.push('actor-' + block.actor);
            if (this.selectedBlock?.id === block.id && this.activePane === paneId) classes.push('selected');
            if (paneId === 'current') { 
                if (block.issueType === 'error') classes.push('issue-error'); 
                else if (block.issueType === 'warning') classes.push('issue-warning'); 
            } else { 
                // Proposed pane - handle change types
                if (block.changeType === 'fix' || block.changeType === 'improved' || block.fixText) classes.push('change-fix'); 
                else if (block.changeType === 'new') classes.push('change-new'); 
                else if (block.changeType === 'removed') classes.push('change-removed'); 
            }
            const hasLink = paneId === 'current' ? this.issueFixLinks.some(l => l.issueId === block.id) : this.issueFixLinks.some(l => l.fixId === block.id);
            if (hasLink) classes.push('linked');
            return classes.join(' ');
        }

        getBlockHtml(block, paneId) {
            // Helper block - simplified display
            if (block.isHelper) {
                return `<div class="block-header"><div class="block-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15a2 2 0 01-2 2H7l-4 4V5a2 2 0 012-2h14a2 2 0 012 2z"/></svg></div><div class="block-title">${block.name || 'Note'}</div></div><div class="block-body"><div class="block-description ${block.description ? '' : 'empty'}">${block.description || 'Add note...'}</div></div>`;
            }
            
            const isCurrentPane = paneId === 'current';
            const typeInfo = block.stepType ? STEP_TYPES[block.stepType] : null;
            let badges = '';
            let annotation = '';
            
            if (isCurrentPane) { 
                // Current pane - left border stripe indicates issue type, no badge needed
                // Only show annotation if there's issue text
                if (block.issueText) annotation = `<div class="block-annotation ${block.issueType || 'issue'}">${block.issueText}</div>`; 
            } else { 
                // Proposed pane - show change type badges (Fix/New/Improved)
                if (block.changeType === 'fix' || block.changeType === 'improved' || block.fixText) {
                    badges += `<span class="block-badge fix">${block.changeType === 'improved' ? 'Improved' : 'Fix'}</span>`;
                } else if (block.changeType === 'new') {
                    badges += '<span class="block-badge new">New</span>';
                } else if (block.changeType === 'removed') {
                    badges += '<span class="block-badge" style="background:var(--red-dim);color:var(--red);">Del</span>';
                }
                // Only show fixText annotation in proposed pane
                if (block.fixText) annotation = `<div class="block-annotation fix">${block.fixText}</div>`; 
                if (block.status) badges += `<span class="block-badge status">${block.status}</span>`; 
            }
            const hasLink = isCurrentPane ? this.issueFixLinks.some(l => l.issueId === block.id) : this.issueFixLinks.some(l => l.fixId === block.id);
            if (hasLink) badges += '<span class="block-badge linked"></span>';
            
            // Actor indicator - check actor field first, then auto-detect from owner
            let actorHtml = '';
            let detectedActor = block.actor;
            
            // Auto-detect actor from owner field if actor not explicitly set
            if (!detectedActor && block.owner) {
                const ownerLower = block.owner.toLowerCase();
                if (ownerLower === 'user' || ownerLower.includes('customer') || ownerLower.includes('exhibitor') || ownerLower.includes('visitor')) {
                    detectedActor = 'user';
                } else if (ownerLower === 'system' || ownerLower.includes('api') || ownerLower.includes('framework') || ownerLower.includes('service') || ownerLower.includes('.js') || ownerLower.includes('.php') || ownerLower === 'ui') {
                    detectedActor = 'system';
                } else if (ownerLower === 'admin' || ownerLower.includes('administrator') || ownerLower.includes('support') || ownerLower.includes('organizer')) {
                    detectedActor = 'admin';
                }
            }
            
            if (detectedActor && ACTOR_TYPES[detectedActor]) {
                const actorInfo = ACTOR_TYPES[detectedActor];
                actorHtml = `<div class="actor-indicator ${detectedActor}"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">${actorInfo.icon}</svg>${actorInfo.name}</div>`;
            } else if (detectedActor) {
                // Unknown actor type - show generic indicator
                actorHtml = `<div class="actor-indicator" style="background:var(--bg-tertiary);color:var(--text-secondary);"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4M12 8h.01"/></svg>${detectedActor}</div>`;
            }
            
            let metaHtml = '';
            if (block.owner || block.timeEstimate) { metaHtml = '<div class="block-meta">'; if (block.owner) metaHtml += `<span class="block-meta-item"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 21v-2a4 4 0 00-4-4H8a4 4 0 00-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>${block.owner}</span>`; if (block.timeEstimate) metaHtml += `<span class="block-meta-item"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg>${block.timeEstimate}</span>`; metaHtml += '</div>'; }
            return `<div class="block-header"><div class="block-icon ${typeInfo ? 'typed' : ''}" style="${typeInfo ? `background:${typeInfo.color}` : ''}"><svg viewBox="0 0 24 24">${typeInfo ? typeInfo.icon : '<rect x="3" y="3" width="18" height="18" rx="2" stroke="currentColor" stroke-width="2" fill="none"/>'}</svg></div><div class="block-title">${block.name || 'Untitled'}</div>${actorHtml}<div class="block-badges">${badges}</div></div><div class="block-body"><div class="block-description ${block.description ? '' : 'empty'}">${block.description || 'No description'}</div>${annotation}${metaHtml}</div><div class="port-in" data-port="in"></div><div class="block-outputs">${Array(block.outputs || 1).fill(0).map((_, i) => `<div class="port-out" data-port="out" data-index="${i}"></div>`).join('')}</div><div class="add-output"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg></div>`;
        }

        bindBlockEvents(el, block, paneId) {
            const pane = this.getPane(paneId);
            const blockId = block.id; // Store ID for Map lookups
            el.addEventListener('mousedown', e => { 
                if (e.target.closest('.port-in') || e.target.closest('.port-out') || e.target.closest('.add-output')) return; 
                e.stopPropagation();
                // Get actual block from Map to handle stale closure references (e.g., after import/undo)
                const actualBlock = this.getPane(paneId).blocks.get(blockId);
                if (!actualBlock) return;
                this.isDragging = true; 
                this.dragBlock = actualBlock;
                this.dragStartPos = { x: actualBlock.x, y: actualBlock.y }; // Track original position
                this.dragPane = paneId; 
                const rect = el.getBoundingClientRect(); 
                this.dragOffset = { x: (e.clientX - rect.left) / pane.zoom, y: (e.clientY - rect.top) / pane.zoom }; 
                this.selectBlock(actualBlock, paneId); 
            });
            el.addEventListener('click', e => { 
                e.stopPropagation(); 
                // Get actual block from Map to handle stale closure references
                const actualBlock = this.getPane(paneId).blocks.get(blockId);
                if (!actualBlock) return;
                // If connecting and clicked on a valid target block
                if (this.isConnecting && this.connectingFrom.id !== blockId && this.connectingPane === paneId) {
                    this.createConnection(this.connectingFrom.id, this.connectingPortIndex, blockId, paneId);
                    this.cancelConnecting();
                    return;
                }
                this.selectBlock(actualBlock, paneId); 
            });
            // Double-click to open inline edit
            el.addEventListener('dblclick', e => {
                e.stopPropagation();
                if (e.target.closest('.port-in') || e.target.closest('.port-out') || e.target.closest('.add-output')) return;
                // Get actual block from Map (openInlineEdit also does this, but pass the ID-based reference)
                const actualBlock = this.getPane(paneId).blocks.get(blockId);
                if (!actualBlock) return;
                this.openInlineEdit(actualBlock, paneId, el);
            });
            // Click on output port to START connection
            el.querySelectorAll('.port-out').forEach(port => {
                port.addEventListener('click', e => { 
                    e.stopPropagation();
                    const actualBlock = this.getPane(paneId).blocks.get(blockId);
                    if (!actualBlock) return;
                    // If already connecting from this port, cancel
                    if (this.isConnecting && this.connectingFrom.id === blockId && this.connectingPortIndex === (parseInt(port.dataset.index) || 0)) {
                        this.cancelConnecting();
                        return;
                    }
                    this.startConnecting(actualBlock, paneId, parseInt(port.dataset.index) || 0);
                });
                // Right-click to delete output port
                port.addEventListener('contextmenu', e => {
                    e.preventDefault();
                    e.stopPropagation();
                    const actualBlock = this.getPane(paneId).blocks.get(blockId);
                    if (!actualBlock) return;
                    const portIndex = parseInt(port.dataset.index) || 0;
                    const numOutputs = actualBlock.outputs || 1;
                    
                    if (numOutputs <= 1) {
                        this.toast('Cannot delete the last output port', 'error');
                        return;
                    }
                    
                    this.saveState('delete-port');
                    
                    // Delete connections from this port
                    const pane = this.getPane(paneId);
                    pane.connections = pane.connections.filter(c => !(c.from === blockId && c.portIndex === portIndex));
                    
                    // Adjust port indices for connections from higher-indexed ports
                    pane.connections.forEach(c => {
                        if (c.from === blockId && c.portIndex > portIndex) {
                            c.portIndex--;
                        }
                    });
                    
                    // Reduce output count
                    actualBlock.outputs = numOutputs - 1;
                    this.updateBlockElement(actualBlock, paneId);
                    this.updateConnections(paneId);
                    this.toast('Output port deleted', 'success');
                });
            });
            // Click on input port to COMPLETE connection
            el.querySelector('.port-in')?.addEventListener('click', e => { 
                e.stopPropagation(); 
                if (this.isConnecting && this.connectingFrom.id !== blockId && this.connectingPane === paneId) {
                    this.createConnection(this.connectingFrom.id, this.connectingPortIndex, blockId, paneId);
                    this.cancelConnecting();
                }
            });
            el.querySelector('.add-output')?.addEventListener('click', e => { 
                e.stopPropagation(); 
                const actualBlock = this.getPane(paneId).blocks.get(blockId);
                if (!actualBlock) return;
                this.saveState('add-port'); 
                actualBlock.outputs = (actualBlock.outputs || 1) + 1; 
                this.updateBlockElement(actualBlock, paneId); 
                this.updateConnections(paneId); 
            });
        }
        
        startConnecting(block, paneId, portIndex) {
            this.isConnecting = true;
            this.connectingFrom = block;
            this.connectingPane = paneId;
            this.connectingPortIndex = portIndex;
            
            // Visual feedback
            const els = this.getPaneElements(paneId);
            els.canvasArea.classList.add('connecting-mode');
            
            // Highlight source port
            const sourceEl = document.getElementById(this.getDomId(block.id, paneId));
            const sourcePort = sourceEl?.querySelector(`.port-out[data-index="${portIndex}"]`) || sourceEl?.querySelector('.port-out');
            sourcePort?.classList.add('connect-source');
            
            // Highlight valid targets
            this.getPane(paneId).blocks.forEach((b, id) => {
                if (id !== block.id) {
                    const targetEl = document.getElementById(this.getDomId(id, paneId));
                    targetEl?.classList.add('connect-target-block');
                    targetEl?.querySelector('.port-in')?.classList.add('connect-target');
                }
            });
            
            this.toast('Click on a target step to connect, or press Escape to cancel', 'info');
        }
        
        cancelConnecting() {
            if (!this.isConnecting) return;
            
            // Remove visual feedback
            document.querySelectorAll('.connecting-mode').forEach(el => el.classList.remove('connecting-mode'));
            document.querySelectorAll('.connect-source').forEach(el => el.classList.remove('connect-source'));
            document.querySelectorAll('.connect-target').forEach(el => el.classList.remove('connect-target'));
            document.querySelectorAll('.connect-target-block').forEach(el => el.classList.remove('connect-target-block'));
            
            this.isConnecting = false;
            this.connectingFrom = null;
            this.connectingPane = null;
            this.removeTempConnection('current');
            this.removeTempConnection('proposed');
        }
        
        openInlineEdit(block, paneId, el) {
            // Close any existing inline edit
            this.closeInlineEdit();
            
            // block should already be the correct reference from the Map (caller looks it up)
            // Double-check it exists
            if (!block || !this.getPane(paneId).blocks.has(block.id)) {
                console.error('Block not found for inline edit:', block?.id, paneId);
                return;
            }
            
            this.inlineEditBlock = block;
            this.inlineEditPane = paneId;
            this.inlineEditEl = el;
            
            // Store original values for cancel
            this.inlineEditOriginal = {
                name: block.name,
                description: block.description,
                stepType: block.stepType
            };
            
            // Create overlay
            const overlay = document.createElement('div');
            overlay.className = 'inline-edit-overlay';
            overlay.id = 'inlineEditOverlay';
            
            // Build HTML based on block type
            let html = `
                <input type="text" class="inline-edit-input title-input" id="inlineEditName" value="${(block.name || '').replace(/"/g, '&quot;')}" placeholder="Step name..." />
                <textarea class="inline-edit-input inline-edit-textarea" id="inlineEditDesc" placeholder="Description...">${block.description || ''}</textarea>
            `;
            
            // Only show type selector for non-helper blocks
            if (!block.isHelper) {
                html += `<div class="inline-edit-types" id="inlineEditTypes">`;
                for (const [key, type] of Object.entries(STEP_TYPES)) {
                    html += `<div class="inline-edit-type ${block.stepType === key ? 'selected' : ''}" data-type="${key}" title="${type.name}" style="background:${type.color}"><svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">${type.icon}</svg></div>`;
                }
                html += `</div>`;
            }
            
            html += `
                <div class="inline-edit-actions">
                    <button class="inline-edit-btn cancel" id="inlineEditCancel">Cancel</button>
                    <button class="inline-edit-btn save" id="inlineEditSave">Save</button>
                </div>
            `;
            
            overlay.innerHTML = html;
            el.appendChild(overlay);
            
            // Bind events
            const nameInput = overlay.querySelector('#inlineEditName');
            const descInput = overlay.querySelector('#inlineEditDesc');
            const saveBtn = overlay.querySelector('#inlineEditSave');
            const cancelBtn = overlay.querySelector('#inlineEditCancel');
            
            nameInput.focus();
            nameInput.select();
            
            // Type selection
            overlay.querySelectorAll('.inline-edit-type').forEach(typeEl => {
                typeEl.addEventListener('click', e => {
                    e.stopPropagation();
                    overlay.querySelectorAll('.inline-edit-type').forEach(t => t.classList.remove('selected'));
                    typeEl.classList.add('selected');
                });
            });
            
            // Save on Enter in name field
            nameInput.addEventListener('keydown', e => {
                if (e.key === 'Enter') { e.preventDefault(); this.saveInlineEdit(); }
                if (e.key === 'Escape') { e.preventDefault(); this.closeInlineEdit(true); }
            });
            
            // Tab from name to description
            nameInput.addEventListener('keydown', e => {
                if (e.key === 'Tab' && !e.shiftKey) { e.preventDefault(); descInput.focus(); }
            });
            
            // Escape to cancel
            descInput.addEventListener('keydown', e => {
                if (e.key === 'Escape') { e.preventDefault(); this.closeInlineEdit(true); }
            });
            
            saveBtn.addEventListener('click', e => { e.stopPropagation(); this.saveInlineEdit(); });
            cancelBtn.addEventListener('click', e => { e.stopPropagation(); this.closeInlineEdit(true); });
            
            // Prevent mousedown from triggering drag
            overlay.addEventListener('mousedown', e => e.stopPropagation());
            overlay.addEventListener('click', e => e.stopPropagation());
        }
        
        saveInlineEdit() {
            if (!this.inlineEditBlock) return;
            
            const overlay = document.getElementById('inlineEditOverlay');
            if (!overlay) return;
            
            this.saveState('inline-edit');
            
            const nameInput = overlay.querySelector('#inlineEditName');
            const descInput = overlay.querySelector('#inlineEditDesc');
            const selectedType = overlay.querySelector('.inline-edit-type.selected');
            
            this.inlineEditBlock.name = nameInput.value || 'Untitled';
            this.inlineEditBlock.description = descInput.value;
            if (selectedType && !this.inlineEditBlock.isHelper) {
                this.inlineEditBlock.stepType = selectedType.dataset.type;
            }
            
            this.closeInlineEdit(false);
            this.updateBlockElement(this.inlineEditBlock, this.inlineEditPane);
            this.updateBlockList();
            this.renderPanel();
        }
        
        closeInlineEdit(restore = false) {
            const overlay = document.getElementById('inlineEditOverlay');
            if (overlay) {
                if (restore && this.inlineEditOriginal) {
                    this.inlineEditBlock.name = this.inlineEditOriginal.name;
                    this.inlineEditBlock.description = this.inlineEditOriginal.description;
                    this.inlineEditBlock.stepType = this.inlineEditOriginal.stepType;
                }
                overlay.remove();
            }
            this.inlineEditBlock = null;
            this.inlineEditPane = null;
            this.inlineEditEl = null;
            this.inlineEditOriginal = null;
        }

        updateBlockElement(block, paneId) { const el = document.getElementById(this.getDomId(block.id, paneId)); if (!el || el.dataset.pane !== paneId) return; el.style.left = block.x + 'px'; el.style.top = block.y + 'px'; el.className = this.getBlockClasses(block, paneId); el.innerHTML = this.getBlockHtml(block, paneId); this.bindBlockEvents(el, block, paneId); this.updateConnections(paneId); this.updateMinimap(); }
        selectBlock(block, paneId) { document.querySelectorAll('.block.selected').forEach(el => el.classList.remove('selected')); this.selectedBlock = block; this.activePane = paneId; if (block) { document.getElementById(this.getDomId(block.id, paneId))?.classList.add('selected'); this.activeTab = 'details'; document.querySelectorAll('.panel-tab').forEach(t => t.classList.remove('active')); document.querySelector('.panel-tab[data-tab="details"]').classList.add('active'); } this.renderPanel(); }
        deleteSelectedBlock() { if (!this.selectedBlock) return; this.saveState('delete-block'); const pane = this.getPane(this.activePane); const blockId = this.selectedBlock.id; document.getElementById(this.getDomId(blockId, this.activePane))?.remove(); pane.blocks.delete(blockId); pane.connections = pane.connections.filter(c => c.from !== blockId && c.to !== blockId); this.issueFixLinks = this.issueFixLinks.filter(l => l.issueId !== blockId && l.fixId !== blockId); this.selectedBlock = null; this.renderPanel(); this.updateConnections(this.activePane); this.updateInstructions(); this.updateBlockList(); this.updateMinimap(); this.updateValidation(); }

        createConnection(fromId, portIndex, toId, paneId) { this.saveState('create-connection'); const pane = this.getPane(paneId); pane.connections = pane.connections.filter(c => !(c.from === fromId && c.portIndex === portIndex)); pane.connections.push({ id: 'conn_' + Date.now(), from: fromId, portIndex, to: toId, label: '' }); this.updateConnections(paneId); this.updateValidation(); }

        updateConnections(paneId) {
            const pane = this.getPane(paneId);
            const els = this.getPaneElements(paneId);
            els.connectionsSvg.innerHTML = '';
            
            // Add arrow marker definition
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            defs.innerHTML = `<marker id="arrowhead-${paneId}" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" class="connection-arrow"/></marker>`;
            els.connectionsSvg.appendChild(defs);
            
            // Get all block rectangles for collision detection
            const blockRects = [];
            const blockElMap = new Map();
            pane.blocks.forEach((block, id) => {
                const el = document.getElementById(this.getDomId(id, paneId));
                if (el) {
                    blockElMap.set(id, el);
                    blockRects.push({
                        id: id,
                        x: block.x,
                        y: block.y,
                        width: el.offsetWidth || 260,
                        height: el.offsetHeight || 140,
                        right: block.x + (el.offsetWidth || 260),
                        bottom: block.y + (el.offsetHeight || 140)
                    });
                }
            });
            
            // Count incoming connections per block and sort by source X position
            const incomingByBlock = new Map();
            pane.connections.forEach(conn => {
                if (!incomingByBlock.has(conn.to)) {
                    incomingByBlock.set(conn.to, []);
                }
                const fromBlock = pane.blocks.get(conn.from);
                incomingByBlock.get(conn.to).push({
                    conn: conn,
                    fromX: fromBlock ? fromBlock.x : 0
                });
            });
            
            // Sort incoming connections by source X position (left to right)
            incomingByBlock.forEach((conns, blockId) => {
                conns.sort((a, b) => a.fromX - b.fromX);
                conns.forEach((c, idx) => {
                    c.inputIndex = idx;
                    c.inputTotal = conns.length;
                });
            });
            
            // Track outgoing connections per block+port to spread lines horizontally
            const outgoingByPort = new Map();
            pane.connections.forEach(conn => {
                const key = `${conn.from}:${conn.portIndex || 0}`;
                if (!outgoingByPort.has(key)) {
                    outgoingByPort.set(key, []);
                }
                const toBlock = pane.blocks.get(conn.to);
                outgoingByPort.get(key).push({
                    conn: conn,
                    toX: toBlock ? toBlock.x : 0,
                    toY: toBlock ? toBlock.y : 0
                });
            });
            
            // Sort outgoing connections by target X position and assign output indices
            outgoingByPort.forEach((conns, portKey) => {
                conns.sort((a, b) => a.toX - b.toX);
                conns.forEach((c, idx) => {
                    c.outputIndex = idx;
                    c.outputTotal = conns.length;
                });
            });
            
            pane.connections.forEach(conn => {
                const fromEl = blockElMap.get(conn.from);
                const toEl = blockElMap.get(conn.to);
                if (!fromEl || !toEl || fromEl.dataset.pane !== paneId) return;
                
                const fromPort = fromEl.querySelector(`.port-out[data-index="${conn.portIndex}"]`) || fromEl.querySelector('.port-out');
                if (!fromPort) return;
                
                const fromRect = fromPort.getBoundingClientRect();
                const canvasRect = els.canvas.getBoundingClientRect();
                const x1 = (fromRect.left + 7 - canvasRect.left) / pane.zoom;
                const y1 = (fromRect.top + 7 - canvasRect.top) / pane.zoom;
                
                // Calculate input position - spread across the top of the block
                const toBlock = pane.blocks.get(conn.to);
                const incomingInfo = incomingByBlock.get(conn.to)?.find(c => c.conn === conn);
                const inputIndex = incomingInfo?.inputIndex || 0;
                const inputTotal = incomingInfo?.inputTotal || 1;
                
                const blockWidth = toEl.offsetWidth || 260;
                const inputSpacing = Math.min(40, blockWidth / (inputTotal + 1));
                const inputStartX = toBlock.x + (blockWidth - (inputTotal - 1) * inputSpacing) / 2;
                const x2 = inputStartX + inputIndex * inputSpacing;
                const y2 = toBlock.y - 2; // Just above the block
                
                // Create group for connection elements
                const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                group.classList.add('connection-group');
                
                // Get outgoing info for spreading lines
                const portKey = `${conn.from}:${conn.portIndex || 0}`;
                const outgoingInfo = outgoingByPort.get(portKey)?.find(c => c.conn === conn);
                const outputIndex = outgoingInfo?.outputIndex || 0;
                const outputTotal = outgoingInfo?.outputTotal || 1;
                
                // Calculate horizontal offset to spread outgoing lines
                // Center the spread around x1
                const spreadWidth = Math.min(60, outputTotal * 20); // Max 60px total spread
                const outputOffset = outputTotal > 1 
                    ? (outputIndex - (outputTotal - 1) / 2) * (spreadWidth / (outputTotal - 1 || 1))
                    : 0;
                
                // Get manual waypoints
                const manualWaypoints = conn.waypoints || [];
                
                // Calculate path waypoints (manual or auto-route around obstacles)
                let pathWaypoints = manualWaypoints.length > 0 
                    ? manualWaypoints 
                    : this.calculateSmartRoute(x1, y1, x2, y2, conn.from, conn.to, blockRects);
                
                // Build path with waypoints
                let pathD;
                if (pathWaypoints.length === 0) {
                    // Simple bezier curve - handle different directions
                    const dy = y2 - y1;
                    const dx = x2 - x1;
                    
                    if (dy > 30) {
                        // Going DOWN - use spread offset on control points
                        const controlDist = Math.max(30, Math.min(Math.abs(dy) * 0.35, 60));
                        // Apply offset to the first control point to spread lines
                        const x1Offset = x1 + outputOffset;
                        pathD = `M${x1},${y1} C${x1Offset},${y1 + controlDist} ${x2},${y2 - controlDist} ${x2},${y2}`;
                    } else if (dy < -30) {
                        // Going UP - route around with orthogonal path, apply offset
                        const sideOffset = (dx > 0 ? 50 : -50) + outputOffset;
                        pathD = `M${x1},${y1} L${x1},${y1 + 25} L${x1 + sideOffset},${y1 + 25} L${x1 + sideOffset},${y2 - 25} L${x2},${y2 - 25} L${x2},${y2}`;
                    } else {
                        // SAME LEVEL - horizontal S-curve or route
                        if (Math.abs(dx) < 30) {
                            // Very close horizontally, curve to side with offset
                            const sign = dx >= 0 ? 1 : -1;
                            const midY = Math.max(y1, y2) + 30 + Math.abs(outputOffset);
                            pathD = `M${x1},${y1} C${x1 + sign * 60 + outputOffset},${midY} ${x2 + sign * 60},${midY} ${x2},${y2}`;
                        } else {
                            // Route down, across, up with S-curve feel
                            const midY = Math.max(y1, y2) + 40 + Math.abs(outputOffset) * 0.5;
                            pathD = `M${x1},${y1} C${x1 + outputOffset},${midY} ${x2},${midY} ${x2},${y2}`;
                        }
                    }
                } else {
                    // Path through waypoints with smooth curves
                    const points = [{x: x1, y: y1}, ...pathWaypoints, {x: x2, y: y2}];
                    pathD = this.buildSmoothPath(points);
                }
                
                // Hit area (invisible wider path for easier clicking) - add first so it's behind
                const hitArea = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                hitArea.setAttribute('d', pathD);
                hitArea.setAttribute('stroke', 'transparent');
                hitArea.setAttribute('stroke-width', '20');
                hitArea.setAttribute('fill', 'none');
                hitArea.style.cursor = 'pointer';
                hitArea.style.pointerEvents = 'stroke';
                group.appendChild(hitArea);
                
                // Visible path
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', pathD);
                path.classList.add('connection');
                path.setAttribute('marker-end', `url(#arrowhead-${paneId})`);
                path.style.pointerEvents = 'none'; // Let hitArea handle events
                group.appendChild(path);
                
                // Label position - use path waypoints for positioning
                let midX, midY;
                if (pathWaypoints.length > 0) {
                    const midIdx = Math.floor(pathWaypoints.length / 2);
                    if (pathWaypoints.length % 2 === 0) {
                        midX = (pathWaypoints[midIdx - 1].x + pathWaypoints[midIdx].x) / 2;
                        midY = (pathWaypoints[midIdx - 1].y + pathWaypoints[midIdx].y) / 2;
                    } else {
                        midX = pathWaypoints[midIdx].x;
                        midY = pathWaypoints[midIdx].y;
                    }
                } else {
                    midX = (x1 + x2) / 2;
                    midY = (y1 + y2) / 2;
                }
                const labelText = conn.label || '';
                
                // Label background
                if (labelText) {
                    const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    const textWidth = labelText.length * 6 + 8;
                    bg.setAttribute('x', midX - textWidth/2);
                    bg.setAttribute('y', midY - 8);
                    bg.setAttribute('width', textWidth);
                    bg.setAttribute('height', 16);
                    bg.setAttribute('rx', 3);
                    bg.classList.add('connection-label-bg');
                    group.appendChild(bg);
                }
                
                // Label text (show placeholder if empty)
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', midX);
                label.setAttribute('y', midY + 4);
                label.setAttribute('text-anchor', 'middle');
                label.classList.add('connection-label');
                label.textContent = labelText || '+';
                if (!labelText) label.style.opacity = '0.3';
                group.appendChild(label);
                
                // Click on label to edit
                label.addEventListener('click', e => {
                    e.stopPropagation();
                    const newLabel = prompt('Connection label (e.g., Yes, No, Success, Error):', conn.label || '');
                    if (newLabel !== null && newLabel !== conn.label) {
                        this.saveState('edit-label');
                        conn.label = newLabel;
                        this.updateConnections(paneId);
                    }
                });
                
                // Double-click on hitArea to add waypoint
                hitArea.addEventListener('dblclick', e => {
                    e.stopPropagation();
                    this.saveState('add-waypoint');
                    const rect = els.canvas.getBoundingClientRect();
                    const wx = (e.clientX - rect.left) / pane.zoom;
                    const wy = (e.clientY - rect.top) / pane.zoom;
                    if (!conn.waypoints) conn.waypoints = [];
                    
                    // Insert waypoint in correct position based on y coordinate
                    const allPoints = [{x: x1, y: y1}, ...conn.waypoints, {x: x2, y: y2}];
                    let insertIdx = conn.waypoints.length;
                    for (let i = 0; i < allPoints.length - 1; i++) {
                        const minY = Math.min(allPoints[i].y, allPoints[i + 1].y);
                        const maxY = Math.max(allPoints[i].y, allPoints[i + 1].y);
                        if (wy >= minY && wy <= maxY) {
                            insertIdx = i;
                            break;
                        }
                    }
                    conn.waypoints.splice(insertIdx, 0, { x: wx, y: wy });
                    this.updateConnections(paneId);
                });
                
                // Right-click on hitArea to delete
                hitArea.addEventListener('contextmenu', e => { 
                    e.preventDefault();
                    e.stopPropagation(); 
                    if (confirm('Delete connection?')) { 
                        this.saveState('delete-connection');
                        pane.connections = pane.connections.filter(c => c.id !== conn.id); 
                        this.updateConnections(paneId); 
                        this.updateValidation(); 
                    } 
                });
                
                // Add bend hints between segments for manual waypoints only
                // Use manual waypoints for the interactive editing points
                const editPoints = [{x: x1, y: y1}, ...manualWaypoints, {x: x2, y: y2}];
                for (let i = 0; i < editPoints.length - 1; i++) {
                    const p1 = editPoints[i];
                    const p2 = editPoints[i + 1];
                    const hintX = (p1.x + p2.x) / 2;
                    const hintY = (p1.y + p2.y) / 2;
                    
                    // Skip if too close to existing label
                    if (Math.abs(hintX - midX) < 30 && Math.abs(hintY - midY) < 30) continue;
                    
                    const hint = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    hint.setAttribute('x', hintX);
                    hint.setAttribute('y', hintY + 5);
                    hint.setAttribute('text-anchor', 'middle');
                    hint.setAttribute('dominant-baseline', 'middle');
                    hint.classList.add('connection-add-hint');
                    hint.style.pointerEvents = 'all';
                    hint.style.cursor = 'pointer';
                    hint.textContent = '';
                    const segmentIdx = i; // Capture for closure
                    hint.addEventListener('click', e => {
                        e.stopPropagation();
                        e.preventDefault();
                        this.saveState('add-waypoint');
                        if (!conn.waypoints) conn.waypoints = [];
                        conn.waypoints.splice(segmentIdx, 0, { x: hintX, y: hintY });
                        this.updateConnections(paneId);
                    });
                    group.appendChild(hint);
                }
                
                // Render manual waypoints only (not auto-calculated ones)
                manualWaypoints.forEach((wp, idx) => {
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', wp.x);
                    circle.setAttribute('cy', wp.y);
                    circle.setAttribute('r', 8);
                    circle.classList.add('connection-waypoint');
                    circle.style.pointerEvents = 'all';
                    circle.style.cursor = 'move';
                    
                    // Drag waypoint
                    const waypointIdx = idx; // Capture for closure
                    circle.addEventListener('mousedown', e => {
                        e.stopPropagation();
                        e.preventDefault();
                        
                        const onMove = (me) => {
                            me.preventDefault();
                            const rect = els.canvas.getBoundingClientRect();
                            conn.waypoints[waypointIdx].x = (me.clientX - rect.left) / pane.zoom;
                            conn.waypoints[waypointIdx].y = (me.clientY - rect.top) / pane.zoom;
                            this.updateConnections(paneId);
                        };
                        
                        const onUp = () => {
                            document.removeEventListener('mousemove', onMove);
                            document.removeEventListener('mouseup', onUp);
                        };
                        
                        document.addEventListener('mousemove', onMove);
                        document.addEventListener('mouseup', onUp);
                    });
                    
                    // Double-click to remove waypoint
                    circle.addEventListener('dblclick', e => {
                        e.stopPropagation();
                        e.preventDefault();
                        this.saveState('remove-waypoint');
                        conn.waypoints.splice(waypointIdx, 1);
                        this.updateConnections(paneId);
                    });
                    
                    group.appendChild(circle);
                });
                
                els.connectionsSvg.appendChild(group);
            });
        }
        
        // Calculate smart route that avoids blocks using orthogonal routing
        calculateSmartRoute(x1, y1, x2, y2, fromId, toId, blockRects) {
            const padding = 35;
            
            // Get blocks that might be in the way (exclude source and target)
            const obstacles = blockRects.filter(r => r.id !== fromId && r.id !== toId);
            
            if (obstacles.length === 0) return [];
            
            // Check if any block is directly in the path
            // Use a narrower corridor for detection - only blocks truly in the way
            const corridorWidth = 15; // Narrow corridor
            const minX = Math.min(x1, x2) - corridorWidth;
            const maxX = Math.max(x1, x2) + corridorWidth;
            const minY = Math.min(y1, y2);
            const maxY = Math.max(y1, y2);
            
            const blockingObstacles = obstacles.filter(block => {
                // Check if block is in the vertical corridor between points
                const blockInXRange = block.right > minX && block.x < maxX;
                const blockInYRange = block.bottom > minY + 10 && block.y < maxY - 10;
                return blockInXRange && blockInYRange;
            });
            
            // If no real obstacles, use simple curve
            if (blockingObstacles.length === 0) return [];
            
            // Sort by Y position
            blockingObstacles.sort((a, b) => a.y - b.y);
            
            // Determine best side to route around
            // Calculate the leftmost and rightmost boundaries we need to avoid
            let leftBoundary = Infinity;
            let rightBoundary = -Infinity;
            
            for (const block of blockingObstacles) {
                leftBoundary = Math.min(leftBoundary, block.x);
                rightBoundary = Math.max(rightBoundary, block.right);
            }
            
            // Add padding
            const leftRouteX = leftBoundary - padding;
            const rightRouteX = rightBoundary + padding;
            
            // Check if other blocks would obstruct the left or right routes
            let leftClear = true;
            let rightClear = true;
            
            for (const block of obstacles) {
                if (block.right > leftRouteX - 5 && block.x < leftRouteX + 5 && 
                    block.bottom > minY && block.y < maxY) {
                    leftClear = false;
                }
                if (block.right > rightRouteX - 5 && block.x < rightRouteX + 5 && 
                    block.bottom > minY && block.y < maxY) {
                    rightClear = false;
                }
            }
            
            // Choose side - prefer the one closer to the start/end points
            let routeX;
            const distToLeft = Math.abs(x1 - leftRouteX) + Math.abs(x2 - leftRouteX);
            const distToRight = Math.abs(x1 - rightRouteX) + Math.abs(x2 - rightRouteX);
            
            if (leftClear && (!rightClear || distToLeft <= distToRight)) {
                routeX = leftRouteX;
            } else if (rightClear) {
                routeX = rightRouteX;
            } else {
                // Both sides have obstacles, pick the shorter path with extra padding
                routeX = distToLeft < distToRight ? leftRouteX - padding : rightRouteX + padding;
            }
            
            // Build waypoints for orthogonal route
            const waypoints = [];
            
            // Find the Y range we need to go around
            let obstacleTopY = Infinity;
            let obstacleBottomY = -Infinity;
            for (const block of blockingObstacles) {
                obstacleTopY = Math.min(obstacleTopY, block.y);
                obstacleBottomY = Math.max(obstacleBottomY, block.bottom);
            }
            
            // Going downward (normal flow)
            if (y2 > y1) {
                // First waypoint: exit horizontally from start
                const exitY = Math.min(y1 + 40, obstacleTopY - padding);
                waypoints.push({ x: x1, y: exitY }); // Go down a bit first
                waypoints.push({ x: routeX, y: exitY }); // Then horizontal
                
                // Second waypoint: go down past the obstacles
                const passY = obstacleBottomY + padding;
                waypoints.push({ x: routeX, y: passY });
                
                // Third waypoint: turn back toward target
                if (Math.abs(routeX - x2) > 20) {
                    const entryY = Math.max(passY, y2 - 40);
                    waypoints.push({ x: x2, y: entryY });
                }
            } else {
                // Going upward (backwards connection)
                const exitY = Math.max(y1 - 40, obstacleBottomY + padding);
                waypoints.push({ x: x1, y: exitY });
                waypoints.push({ x: routeX, y: exitY });
                
                const passY = obstacleTopY - padding;
                waypoints.push({ x: routeX, y: passY });
                
                if (Math.abs(routeX - x2) > 20) {
                    const entryY = Math.min(passY, y2 + 40);
                    waypoints.push({ x: x2, y: entryY });
                }
            }
            
            return waypoints;
        }
        
        // Check if a bezier curve path intersects a rectangle
        lineIntersectsRect(x1, y1, x2, y2, rx, ry, rx2, ry2) {
            // Sample points along the bezier curve
            for (let t = 0; t <= 1; t += 0.05) {
                const ct = 1 - t;
                const midY1 = y1 + Math.abs(y2 - y1) * 0.5;
                const midY2 = y2 - Math.abs(y2 - y1) * 0.5;
                
                // Cubic bezier control points for vertical flow
                const px = ct*ct*ct*x1 + 3*ct*ct*t*x1 + 3*ct*t*t*x2 + t*t*t*x2;
                const py = ct*ct*ct*y1 + 3*ct*ct*t*midY1 + 3*ct*t*t*midY2 + t*t*t*y2;
                
                if (px >= rx && px <= rx2 && py >= ry && py <= ry2) {
                    return true;
                }
            }
            return false;
        }
        
        // Build smooth SVG path through points with rounded corners
        buildSmoothPath(points) {
            if (points.length < 2) return '';
            
            const radius = 12; // Corner radius
            let path = `M${points[0].x},${points[0].y}`;
            
            for (let i = 1; i < points.length; i++) {
                const p0 = points[i - 1];
                const p1 = points[i];
                const p2 = points[i + 1];
                
                if (p2) {
                    // There's a next point, so we need to handle the corner
                    const dx1 = p1.x - p0.x;
                    const dy1 = p1.y - p0.y;
                    const dx2 = p2.x - p1.x;
                    const dy2 = p2.y - p1.y;
                    
                    const len1 = Math.sqrt(dx1*dx1 + dy1*dy1);
                    const len2 = Math.sqrt(dx2*dx2 + dy2*dy2);
                    
                    // Limit radius to half the segment length
                    const r = Math.min(radius, len1/2, len2/2);
                    
                    // Point before the corner
                    const beforeX = p1.x - (dx1/len1) * r;
                    const beforeY = p1.y - (dy1/len1) * r;
                    
                    // Point after the corner
                    const afterX = p1.x + (dx2/len2) * r;
                    const afterY = p1.y + (dy2/len2) * r;
                    
                    // Line to before corner, then quadratic curve through corner
                    path += ` L${beforeX},${beforeY}`;
                    path += ` Q${p1.x},${p1.y} ${afterX},${afterY}`;
                } else {
                    // Last point, just line to it
                    path += ` L${p1.x},${p1.y}`;
                }
            }
            
            return path;
        }

        drawTempConnection(e, paneId) { this.removeTempConnection(paneId); if (!this.connectingFrom || this.connectingPane !== paneId) return; const pane = this.getPane(paneId); const els = this.getPaneElements(paneId); const fromEl = document.getElementById(this.getDomId(this.connectingFrom.id, paneId)); const port = fromEl?.querySelector(`.port-out[data-index="${this.connectingPortIndex}"]`) || fromEl?.querySelector('.port-out'); if (!port) return; const rect = port.getBoundingClientRect(); const canvasRect = els.canvas.getBoundingClientRect(); const x1 = (rect.left + 7 - canvasRect.left) / pane.zoom; const y1 = (rect.top + 7 - canvasRect.top) / pane.zoom; const x2 = (e.clientX - canvasRect.left) / pane.zoom; const y2 = (e.clientY - canvasRect.top) / pane.zoom; const path = document.createElementNS('http://www.w3.org/2000/svg', 'path'); path.setAttribute('d', `M${x1},${y1} C${x1},${y1 + Math.abs(y2-y1)*0.4} ${x2},${y2 - Math.abs(y2-y1)*0.4} ${x2},${y2}`); path.classList.add('temp-connection'); path.id = `tempConnection_${paneId}`; els.connectionsSvg.appendChild(path); }
        removeTempConnection(paneId) { document.getElementById(`tempConnection_${paneId}`)?.remove(); }

        onCanvasMouseDown(e, paneId) { const els = this.getPaneElements(paneId); if (e.target === els.canvasArea || e.target.closest('.canvas-container')) { const pane = this.getPane(paneId); this.isPanning = true; this.panningPane = paneId; this.panStart = { x: e.clientX - pane.panX, y: e.clientY - pane.panY }; els.canvasArea.style.cursor = 'grabbing'; } }
        onCanvasMouseMove(e, paneId) { if (this.isDragging && this.dragBlock && this.dragPane === paneId) { const pane = this.getPane(paneId); const els = this.getPaneElements(paneId); const rect = els.canvas.getBoundingClientRect(); let x = (e.clientX - rect.left) / pane.zoom - this.dragOffset.x; let y = (e.clientY - rect.top) / pane.zoom - this.dragOffset.y; x = Math.round(x / 24) * 24; y = Math.round(y / 24) * 24; this.dragBlock.x = x; this.dragBlock.y = y; const el = document.getElementById(this.getDomId(this.dragBlock.id, paneId)); if (el) { el.style.left = x + 'px'; el.style.top = y + 'px'; } this.updateConnections(paneId); this.updateMinimap(); } if (this.isPanning && this.panningPane === paneId) { const pane = this.getPane(paneId); pane.panX = e.clientX - this.panStart.x; pane.panY = e.clientY - this.panStart.y; this.applyTransform(paneId); this.updateMinimap(); } if (this.isConnecting && this.connectingPane === paneId) this.drawTempConnection(e, paneId); }
        onCanvasMouseUp(e, paneId) { 
            const els = this.getPaneElements(paneId); 
            // Save state if block was actually moved
            if (this.isDragging && this.dragBlock && this.dragStartPos) {
                if (this.dragBlock.x !== this.dragStartPos.x || this.dragBlock.y !== this.dragStartPos.y) {
                    // Temporarily restore original position for the saveState snapshot
                    const newX = this.dragBlock.x;
                    const newY = this.dragBlock.y;
                    this.dragBlock.x = this.dragStartPos.x;
                    this.dragBlock.y = this.dragStartPos.y;
                    this.saveState('move-block');
                    // Then set to new position
                    this.dragBlock.x = newX;
                    this.dragBlock.y = newY;
                }
            }
            this.isDragging = false; 
            this.dragBlock = null; 
            this.dragStartPos = null;
            if (this.panningPane === paneId) { this.isPanning = false; els.canvasArea.style.cursor = ''; } 
        }
        onCanvasWheel(e, paneId) { 
            e.preventDefault(); 
            const pane = this.getPane(paneId);
            const els = this.getPaneElements(paneId);
            const rect = els.canvasArea.getBoundingClientRect();
            
            // Cursor position relative to canvas area
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Point in canvas coordinates before zoom
            const canvasX = (mouseX - pane.panX) / pane.zoom;
            const canvasY = (mouseY - pane.panY) / pane.zoom;
            
            // New zoom
            const oldZoom = pane.zoom;
            const newZoom = Math.max(0.2, Math.min(2, oldZoom + (e.deltaY > 0 ? -0.08 : 0.08)));
            
            // Adjust pan so cursor stays over same point
            pane.panX = mouseX - canvasX * newZoom;
            pane.panY = mouseY - canvasY * newZoom;
            pane.zoom = newZoom;
            
            this.applyTransform(paneId);
            els.zoomLevel.textContent = Math.round(pane.zoom * 100) + '%';
            this.updateMinimap();
        }
        setZoom(newZoom, paneId) { const pane = this.getPane(paneId); const els = this.getPaneElements(paneId); pane.zoom = Math.max(0.2, Math.min(2, newZoom)); this.applyTransform(paneId); els.zoomLevel.textContent = Math.round(pane.zoom * 100) + '%'; this.updateMinimap(); }
        applyTransform(paneId) { const pane = this.getPane(paneId); const els = this.getPaneElements(paneId); els.canvas.style.transform = `translate(${pane.panX}px, ${pane.panY}px) scale(${pane.zoom})`; }
        zoomToFit(paneId) { const pane = this.getPane(paneId); const els = this.getPaneElements(paneId); const blocks = Array.from(pane.blocks.values()); if (!blocks.length) { pane.zoom = 1; pane.panX = 0; pane.panY = 0; this.applyTransform(paneId); els.zoomLevel.textContent = '100%'; return; } const padding = 50; const minX = Math.min(...blocks.map(b => b.x)); const minY = Math.min(...blocks.map(b => b.y)); const maxX = Math.max(...blocks.map(b => b.x + 260)); const maxY = Math.max(...blocks.map(b => b.y + 120)); const rect = els.canvasArea.getBoundingClientRect(); const contentW = maxX - minX + padding * 2; const contentH = maxY - minY + padding * 2; pane.zoom = Math.max(0.2, Math.min(1, Math.min(rect.width / contentW, rect.height / contentH))); pane.panX = (rect.width - contentW * pane.zoom) / 2 - (minX - padding) * pane.zoom; pane.panY = (rect.height - contentH * pane.zoom) / 2 - (minY - padding) * pane.zoom; this.applyTransform(paneId); els.zoomLevel.textContent = Math.round(pane.zoom * 100) + '%'; this.updateMinimap(); }

        updateBlockList() {
            const list = document.getElementById('blockList');
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            let html = '';
            // Filter out helper blocks from the list (they're not actual process steps)
            const currentBlocks = Array.from(this.current.blocks.values()).filter(b => !b.isHelper && (!searchTerm || b.name.toLowerCase().includes(searchTerm))).sort((a, b) => a.y - b.y);
            if (currentBlocks.length) { html += '<div class="block-list-pane-label">Current</div>'; html += currentBlocks.map(b => this.getBlockListItemHtml(b, 'current')).join(''); }
            const proposedBlocks = Array.from(this.proposed.blocks.values()).filter(b => !b.isHelper && (!searchTerm || b.name.toLowerCase().includes(searchTerm))).sort((a, b) => a.y - b.y);
            if (proposedBlocks.length) { html += '<div class="block-list-pane-label">Proposed</div>'; html += proposedBlocks.map(b => this.getBlockListItemHtml(b, 'proposed')).join(''); }
            if (!html) html = '<div style="text-align:center;padding:16px;color:var(--text-muted);font-size:10px;">No steps found</div>';
            list.innerHTML = html;
            list.querySelectorAll('.block-list-item').forEach(item => {
                item.addEventListener('click', () => { 
                    const paneId = item.dataset.pane; 
                    const block = this.getPane(paneId).blocks.get(item.dataset.id); 
                    if (block) { this.selectBlock(block, paneId); this.panToBlock(block, paneId); } 
                });
                // Drag and drop for reordering
                item.draggable = true;
                item.addEventListener('dragstart', e => {
                    this.draggedBlockItem = { id: item.dataset.id, pane: item.dataset.pane };
                    item.classList.add('dragging');
                });
                item.addEventListener('dragend', () => {
                    item.classList.remove('dragging');
                    document.querySelectorAll('.block-list-item.drag-over').forEach(el => el.classList.remove('drag-over'));
                });
                item.addEventListener('dragover', e => {
                    e.preventDefault();
                    if (this.draggedBlockItem?.pane === item.dataset.pane) {
                        item.classList.add('drag-over');
                    }
                });
                item.addEventListener('dragleave', () => item.classList.remove('drag-over'));
                item.addEventListener('drop', e => {
                    e.preventDefault();
                    item.classList.remove('drag-over');
                    if (!this.draggedBlockItem || this.draggedBlockItem.pane !== item.dataset.pane) return;
                    this.reorderBlocks(this.draggedBlockItem.id, item.dataset.id, item.dataset.pane);
                });
            });
        }
        
        reorderBlocks(draggedId, targetId, paneId) {
            if (draggedId === targetId) return;
            const pane = this.getPane(paneId);
            const draggedBlock = pane.blocks.get(draggedId);
            const targetBlock = pane.blocks.get(targetId);
            if (!draggedBlock || !targetBlock) return;
            
            this.saveState('reorder');
            
            // Get all blocks sorted by Y
            const blocks = Array.from(pane.blocks.values()).sort((a, b) => a.y - b.y);
            const draggedIdx = blocks.findIndex(b => b.id === draggedId);
            const targetIdx = blocks.findIndex(b => b.id === targetId);
            
            // Remove dragged and insert at target position
            blocks.splice(draggedIdx, 1);
            blocks.splice(targetIdx, 0, draggedBlock);
            
            // Reassign Y positions
            const startY = 100;
            const gap = 140;
            blocks.forEach((block, idx) => {
                block.y = startY + idx * gap;
                this.updateBlockElement(block, paneId);
            });
            
            this.updateConnections(paneId);
            this.updateBlockList();
            this.updateMinimap();
        }

        getBlockListItemHtml(block, paneId) {
            let itemClass = 'block-list-item';
            if (this.selectedBlock?.id === block.id && this.activePane === paneId) itemClass += ' selected';
            if (block.issueType === 'error' || block.issueType === 'warning') itemClass += ' has-issue';
            else if (block.changeType === 'fix' || block.fixText) itemClass += ' has-fix';
            return `<div class="${itemClass}" data-id="${block.id}" data-pane="${paneId}"><div class="block-list-item-name">${block.name}</div><div class="block-list-item-meta">${block.owner ? block.owner : ''}${block.stepType ? (block.owner ? '  ' : '') + STEP_TYPES[block.stepType]?.name : ''}</div></div>`;
        }

        filterBlocks(searchTerm) { this.updateBlockList(); }
        panToBlock(block, paneId) { const pane = this.getPane(paneId); const els = this.getPaneElements(paneId); const rect = els.canvasArea.getBoundingClientRect(); pane.panX = rect.width / 2 - (block.x + 130) * pane.zoom; pane.panY = rect.height / 2 - (block.y + 60) * pane.zoom; this.applyTransform(paneId); this.updateMinimap(); }

        updateMinimap() {
            // Minimap removed - no-op
        }

        updateValidation() {
            const list = document.getElementById('validationList');
            const results = this.runValidation();
            if (results.length === 0) { list.innerHTML = '<div class="validation-item success"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 11.08V12a10 10 0 11-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg><span class="validation-item-text">All checks passed</span></div>'; }
            else { list.innerHTML = results.slice(0, 4).map(r => `<div class="validation-item ${r.type}" data-block-id="${r.blockId || ''}" data-pane="${r.pane || ''}"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">${r.type === 'error' ? '<circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/>' : '<path d="M10.29 3.86L1.82 18a2 2 0 001.71 3h16.94a2 2 0 001.71-3L13.71 3.86a2 2 0 00-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/>'}</svg><span class="validation-item-text">${r.message}</span></div>`).join('');
            list.querySelectorAll('.validation-item').forEach(item => item.addEventListener('click', () => { const blockId = item.dataset.blockId; const paneId = item.dataset.pane; if (blockId && paneId) { const block = this.getPane(paneId).blocks.get(blockId); if (block) { this.selectBlock(block, paneId); this.panToBlock(block, paneId); } } })); }
            // Update validation badge
            this.updateValidationBadge();
        }
        
        // Snap value to grid (24px grid)
        snapToGrid(val) {
            const gridSize = 24;
            return Math.round(val / gridSize) * gridSize;
        }
        
        // Snap all blocks in a pane to grid
        snapAllToGrid(paneId) {
            const pane = this.getPane(paneId);
            let snapped = 0;
            pane.blocks.forEach(block => {
                const newX = this.snapToGrid(block.x);
                const newY = this.snapToGrid(block.y);
                if (newX !== block.x || newY !== block.y) {
                    block.x = newX;
                    block.y = newY;
                    snapped++;
                }
                this.updateBlockElement(block, paneId);
            });
            this.updateConnections(paneId);
            this.updateMinimap();
            if (snapped > 0) {
                this.saveState('snap-grid');
                this.toast(`Snapped ${snapped} block${snapped > 1 ? 's' : ''} to grid`, 'success');
            } else {
                this.toast('All blocks already on grid', 'info');
            }
        }

        runValidation() {
            const results = [];
            const currentBlocks = Array.from(this.current.blocks.values());
            const proposedBlocks = Array.from(this.proposed.blocks.values());
            currentBlocks.filter(b => b.issueType).forEach(block => { const hasLink = this.issueFixLinks.some(l => l.issueId === block.id); if (!hasLink) results.push({ type: 'warning', message: `"${block.name}" has no linked fix`, blockId: block.id, pane: 'current' }); });
            ['current', 'proposed'].forEach(paneId => { const pane = this.getPane(paneId); pane.blocks.forEach(block => { const hasIncoming = pane.connections.some(c => c.to === block.id); const hasOutgoing = pane.connections.some(c => c.from === block.id); if (!hasIncoming && !hasOutgoing && pane.blocks.size > 1) results.push({ type: 'warning', message: `"${block.name}" not connected`, blockId: block.id, pane: paneId }); }); });
            proposedBlocks.filter(b => b.changeType === 'fix' && !b.fixText).forEach(block => results.push({ type: 'warning', message: `"${block.name}" fix needs description`, blockId: block.id, pane: 'proposed' }));
            const todoCount = proposedBlocks.filter(b => b.status === 'todo').length;
            if (todoCount > 0) results.push({ type: 'warning', message: `${todoCount} fix(es) still To Do` });
            return results;
        }

        showValidationModal() {
            const results = this.runValidation();
            const body = document.getElementById('validationModalBody');
            const currentBlocks = Array.from(this.current.blocks.values());
            const proposedBlocks = Array.from(this.proposed.blocks.values());
            const issues = currentBlocks.filter(b => b.issueType).length;
            const linkedFixes = this.issueFixLinks.length;
            const issueList = Array.from(this.current.blocks.values()).filter(b => b.issueType);
            body.innerHTML = `<div class="summary-grid" style="margin-bottom:16px;"><div class="summary-stat"><div class="summary-stat-value">${currentBlocks.length}</div><div class="summary-stat-label">Current</div></div><div class="summary-stat"><div class="summary-stat-value">${proposedBlocks.length}</div><div class="summary-stat-label">Proposed</div></div><div class="summary-stat"><div class="summary-stat-value issues">${issues}</div><div class="summary-stat-label">Issues</div></div><div class="summary-stat"><div class="summary-stat-value fixes">${linkedFixes}</div><div class="summary-stat-label">Linked</div></div></div><div class="section-title">Validation Results</div>${results.length === 0 ? '<div style="text-align:center;padding:20px;"><svg viewBox="0 0 24 24" fill="none" stroke="var(--green)" stroke-width="2" width="36" height="36" style="margin-bottom:8px;"><path d="M22 11.08V12a10 10 0 11-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg><div style="font-size:14px;font-weight:600;color:var(--green);">All Checks Passed!</div></div>' : `<div style="display:flex;flex-direction:column;gap:6px;margin-bottom:16px;">${results.map(r => `<div class="validation-item ${r.type}" style="cursor:default;"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">${r.type === 'error' ? '<circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/>' : '<path d="M10.29 3.86L1.82 18a2 2 0 001.71 3h16.94a2 2 0 001.71-3L13.71 3.86a2 2 0 00-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/>'}</svg><span class="validation-item-text">${r.message}</span></div>`).join('')}</div>`}<div class="section-divider"><div class="section-title">Issue  Fix Traceability</div>${issueList.length === 0 ? '<div style="font-size:11px;color:var(--text-muted);">No issues marked</div>' : issueList.map(issue => { const link = this.issueFixLinks.find(l => l.issueId === issue.id); const fix = link ? this.proposed.blocks.get(link.fixId) : null; return `<div style="display:flex;align-items:center;gap:10px;padding:8px;background:var(--bg-tertiary);border-radius:5px;margin-bottom:6px;"><div style="flex:1;"><div style="font-size:11px;font-weight:500;color:${issue.issueType === 'error' ? 'var(--red)' : 'var(--orange)'};"> ${issue.name}</div><div style="font-size:10px;color:var(--text-muted);margin-top:2px;">${issue.issueText || 'No description'}</div></div><div style="color:var(--text-muted);"></div><div style="flex:1;">${fix ? `<div style="font-size:11px;font-weight:500;color:var(--green);"> ${fix.name}</div><div style="font-size:10px;color:var(--text-muted);margin-top:2px;">${fix.fixText || 'No description'}</div>` : '<div style="font-size:11px;color:var(--text-muted);font-style:italic;">No fix linked</div>'}</div></div>`; }).join('')}</div>`;
            this.showModal('validationModal');
        }

        showExportModal() { if (!this.currentFlowId) { this.toast('No analysis to export', 'error'); return; } this.showModal('exportModal'); }
        
        showHelpModal() { this.showModal('helpModal'); }
        
        switchHelpTab(tab) {
            document.querySelectorAll('.help-tab').forEach(t => t.classList.toggle('active', t.dataset.help === tab));
            document.querySelectorAll('.help-panel').forEach(p => p.classList.remove('active'));
            document.getElementById('help' + tab.charAt(0).toUpperCase() + tab.slice(1))?.classList.add('active');
        }
        
        copyAiPrompt() {
            const promptText = document.getElementById('aiPromptText')?.textContent;
            if (promptText) {
                navigator.clipboard.writeText(promptText).then(() => {
                    this.toast('Flow AI prompt copied to clipboard!', 'success');
                }).catch(() => {
                    this.toast('Failed to copy', 'error');
                });
            }
        }
        
        copyBriefPrompt() {
            const promptText = document.getElementById('briefPromptText')?.textContent;
            if (promptText) {
                navigator.clipboard.writeText(promptText).then(() => {
                    this.toast('Brief AI prompt copied to clipboard!', 'success');
                }).catch(() => {
                    this.toast('Failed to copy', 'error');
                });
            }
        }

        doExport(type) {
            const flow = this.flows[this.currentFlowId];
            this.hideModal('exportModal');
            if (type === 'json') this.exportJSON();
            else if (type === 'report') this.exportReport();
            else if (type === 'summary') this.exportSummary();
            else if (type === 'pdf-current') this.exportPDF('current');
            else if (type === 'pdf-proposed') this.exportPDF('proposed');
            else if (type === 'pdf-comparison') this.exportPDF('comparison');
            else if (type === 'png-current') this.exportFlowPNG('current');
            else if (type === 'png-proposed') this.exportFlowPNG('proposed');
            else if (type === 'png-both') this.exportFlowPNG('both');
        }

        exportPDF(mode) {
            const { jsPDF } = window.jspdf;
            const flow = this.currentFlowIsDrive ? this.driveFlows[this.currentFlowId] : this.flows[this.currentFlowId];
            const currentBlocks = Array.from(this.current.blocks.values());
            const proposedBlocks = Array.from(this.proposed.blocks.values());
            
            // Create PDF - A4 landscape for better flow visualization
            const isComparison = mode === 'comparison';
            const pdf = new jsPDF({
                orientation: isComparison ? 'landscape' : 'portrait',
                unit: 'mm',
                format: 'a4'
            });
            
            const pageWidth = pdf.internal.pageSize.getWidth();
            const pageHeight = pdf.internal.pageSize.getHeight();
            const margin = 15;
            const contentWidth = pageWidth - (margin * 2);
            
            // Colors
            const colors = {
                primary: [59, 130, 246],
                green: [34, 197, 94],
                orange: [249, 115, 22],
                red: [239, 68, 68],
                cyan: [6, 182, 212],
                purple: [168, 85, 247],
                gray: [100, 116, 139],
                lightGray: [241, 245, 249],
                dark: [26, 26, 46],
                white: [255, 255, 255]
            };
            
            // Environment colors
            const envColors = {
                exhibitor: colors.green,
                organizer: colors.primary,
                ea: colors.orange,
                valverde: colors.purple,
                other: colors.gray
            };
            
            // Helper functions
            const setColor = (color, type = 'fill') => {
                if (type === 'fill') pdf.setFillColor(...color);
                else if (type === 'draw') pdf.setDrawColor(...color);
                else if (type === 'text') pdf.setTextColor(...color);
            };
            
            const drawRoundedRect = (x, y, w, h, r, style = 'F') => {
                pdf.roundedRect(x, y, w, h, r, r, style);
            };
            
            let yPos = margin;
            
            // Header background
            const headerHeight = flow.description ? 32 : 25;
            setColor([248, 250, 252], 'fill');
            pdf.rect(0, 0, pageWidth, headerHeight + margin, 'F');
            
            // Title
            pdf.setFontSize(18);
            pdf.setFont('helvetica', 'bold');
            setColor(colors.dark, 'text');
            pdf.text(flow.name || 'Process Flow', margin, yPos + 6);
            
            // Environment badge (top right)
            const envText = (flow.environment || 'other').toUpperCase();
            const envColor = envColors[flow.environment] || colors.gray;
            pdf.setFontSize(8);
            const envWidth = pdf.getTextWidth(envText) + 6;
            setColor(envColor, 'fill');
            pdf.roundedRect(pageWidth - margin - envWidth, yPos - 2, envWidth, 10, 2, 2, 'F');
            setColor(colors.white, 'text');
            pdf.text(envText, pageWidth - margin - envWidth + 3, yPos + 4);
            
            yPos += 10;
            
            // Subtitle based on mode
            pdf.setFontSize(11);
            pdf.setFont('helvetica', 'normal');
            setColor(colors.gray, 'text');
            const subtitle = mode === 'current' ? 'Current State (AS-IS)' : 
                           mode === 'proposed' ? 'Proposed State (TO-BE)' : 
                           'Current vs Proposed Comparison';
            pdf.text(subtitle, margin, yPos);
            
            // Date (right aligned)
            const dateText = `Generated: ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}`;
            pdf.setFontSize(9);
            const dateWidth = pdf.getTextWidth(dateText);
            pdf.text(dateText, pageWidth - margin - dateWidth, yPos);
            
            // Description if present
            if (flow.description) {
                yPos += 6;
                pdf.setFontSize(9);
                pdf.setFont('helvetica', 'italic');
                setColor(colors.gray, 'text');
                const descLines = pdf.splitTextToSize(flow.description, contentWidth);
                pdf.text(descLines.slice(0, 2), margin, yPos); // Max 2 lines
                yPos += Math.min(descLines.length, 2) * 4;
            }
            
            yPos += 6;
            
            // Divider line
            const lineColor = mode === 'current' ? colors.orange : mode === 'proposed' ? colors.green : colors.primary;
            setColor(lineColor, 'draw');
            pdf.setLineWidth(0.8);
            pdf.line(margin, yPos, pageWidth - margin, yPos);
            yPos += 8;
            
            if (isComparison) {
                // Side by side comparison with aligned steps
                const colWidth = (contentWidth - 10) / 2;
                
                // Summary stats
                this.drawPDFSummaryStats(pdf, margin, yPos, contentWidth, colors, currentBlocks, proposedBlocks);
                yPos += 35;
                
                // Column headers
                pdf.setFontSize(12);
                pdf.setFont('helvetica', 'bold');
                setColor(colors.orange, 'text');
                pdf.text('CURRENT STATE', margin, yPos);
                setColor(colors.green, 'text');
                pdf.text('PROPOSED STATE', margin + colWidth + 10, yPos);
                yPos += 8;
                
                // Draw aligned comparison
                yPos = this.drawPDFComparisonAligned(pdf, margin, yPos, colWidth, colors, currentBlocks, proposedBlocks);
                
                // Change summary on new page if needed
                if (yPos > pageHeight - 60) {
                    pdf.addPage();
                    yPos = margin;
                }
                
                this.drawPDFChangeSummary(pdf, margin, yPos, contentWidth, colors, currentBlocks, proposedBlocks);
                
            } else {
                // Single flow export
                const blocks = mode === 'current' ? currentBlocks : proposedBlocks;
                const connections = mode === 'current' ? this.current.connections : this.proposed.connections;
                
                // Summary stats for single flow
                this.drawPDFSingleStats(pdf, margin, yPos, contentWidth, colors, blocks, mode);
                yPos += 25;
                
                // Flow blocks
                yPos = this.drawPDFFlowBlocks(pdf, margin, yPos, contentWidth, colors, blocks, connections, mode);
                
                // Block details table
                if (yPos > pageHeight - 40) {
                    pdf.addPage();
                    yPos = margin;
                }
                
                this.drawPDFBlockDetails(pdf, margin, yPos, contentWidth, colors, blocks, mode);
            }
            
            // Save
            const timestamp = new Date().toISOString().slice(0, 10);
            const filename = `${(flow.name || 'flow').replace(/\s+/g, '_')}_${mode}_${timestamp}.pdf`;
            pdf.save(filename);
            this.toast('PDF exported', 'success');
        }
        
        drawPDFSummaryStats(pdf, x, y, width, colors, currentBlocks, proposedBlocks) {
            const issues = currentBlocks.filter(b => b.issueType);
            const fixes = proposedBlocks.filter(b => b.changeType === 'fix');
            const newSteps = proposedBlocks.filter(b => b.changeType === 'new');
            const modified = proposedBlocks.filter(b => b.changeType === 'modified');
            
            const stats = [
                { label: 'Current Steps', value: currentBlocks.length, color: colors.gray },
                { label: 'Issues', value: issues.filter(b => b.issueType === 'error').length, color: colors.red },
                { label: 'Warnings', value: issues.filter(b => b.issueType === 'warning').length, color: colors.orange },
                { label: 'Fixes', value: fixes.length, color: colors.green },
                { label: 'New Steps', value: newSteps.length, color: colors.primary },
                { label: 'Modified', value: modified.length, color: colors.gray }
            ];
            
            const boxWidth = (width - 25) / 6;
            stats.forEach((stat, i) => {
                const bx = x + (i * (boxWidth + 5));
                pdf.setFillColor(245, 247, 250);
                pdf.roundedRect(bx, y, boxWidth, 25, 2, 2, 'F');
                
                pdf.setFontSize(16);
                pdf.setFont('helvetica', 'bold');
                pdf.setTextColor(...stat.color);
                pdf.text(String(stat.value), bx + boxWidth/2, y + 12, { align: 'center' });
                
                pdf.setFontSize(7);
                pdf.setFont('helvetica', 'normal');
                pdf.setTextColor(...colors.gray);
                pdf.text(stat.label, bx + boxWidth/2, y + 20, { align: 'center' });
            });
        }
        
        drawPDFSingleStats(pdf, x, y, width, colors, blocks, mode) {
            const isProposed = mode === 'proposed';
            let stats;
            
            if (isProposed) {
                stats = [
                    { label: 'Total Steps', value: blocks.length, color: colors.primary },
                    { label: 'Fixes', value: blocks.filter(b => b.changeType === 'fix').length, color: colors.green },
                    { label: 'New', value: blocks.filter(b => b.changeType === 'new').length, color: colors.primary },
                    { label: 'Modified', value: blocks.filter(b => b.changeType === 'modified').length, color: colors.orange }
                ];
            } else {
                stats = [
                    { label: 'Total Steps', value: blocks.length, color: colors.primary },
                    { label: 'Errors', value: blocks.filter(b => b.issueType === 'error').length, color: colors.red },
                    { label: 'Warnings', value: blocks.filter(b => b.issueType === 'warning').length, color: colors.orange },
                    { label: 'OK', value: blocks.filter(b => !b.issueType).length, color: colors.green }
                ];
            }
            
            const boxWidth = (width - 15) / 4;
            stats.forEach((stat, i) => {
                const bx = x + (i * (boxWidth + 5));
                pdf.setFillColor(245, 247, 250);
                pdf.roundedRect(bx, y, boxWidth, 18, 2, 2, 'F');
                
                pdf.setFontSize(14);
                pdf.setFont('helvetica', 'bold');
                pdf.setTextColor(...stat.color);
                pdf.text(String(stat.value), bx + 8, y + 11);
                
                pdf.setFontSize(8);
                pdf.setFont('helvetica', 'normal');
                pdf.setTextColor(...colors.gray);
                pdf.text(stat.label, bx + 22, y + 11);
            });
        }
        
        drawPDFFlowBlocks(pdf, x, y, width, colors, blocks, connections, mode) {
            const pageHeight = pdf.internal.pageSize.getHeight();
            const blockHeight = 20;
            const blockGap = 4;
            const indentWidth = 12;
            
            // Build connection graph
            const children = new Map();
            const parents = new Map();
            const connectionLabels = new Map(); // from-to -> label
            
            blocks.forEach(b => {
                children.set(b.id, []);
                parents.set(b.id, []);
            });
            
            connections.forEach(conn => {
                if (children.has(conn.from) && parents.has(conn.to)) {
                    children.get(conn.from).push(conn.to);
                    parents.get(conn.to).push(conn.from);
                    if (conn.label) {
                        connectionLabels.set(`${conn.from}->${conn.to}`, conn.label);
                    }
                }
            });
            
            // Find root nodes (no parents)
            const blockMap = new Map(blocks.map(b => [b.id, b]));
            let roots = blocks.filter(b => parents.get(b.id).length === 0);
            if (roots.length === 0 && blocks.length > 0) {
                // No clear root - use block with smallest Y
                roots = [blocks.reduce((a, b) => (a.y || 0) < (b.y || 0) ? a : b)];
            }
            
            // Step type labels
            const stepTypes = {
                action: 'ACT', decision: 'DEC', api: 'API', email: 'EML', 
                form: 'FRM', data: 'DAT', delay: 'DLY', webhook: 'WHK'
            };
            
            let currentY = y;
            let stepNumber = 0;
            const visited = new Set();
            const drawnBlocks = []; // Track what we've drawn for the details table
            
            // Recursive function to draw a block and its descendants
            const drawBlock = (blockId, depth, pathLabel) => {
                if (visited.has(blockId)) return;
                visited.add(blockId);
                
                const block = blockMap.get(blockId);
                if (!block) return;
                
                stepNumber++;
                drawnBlocks.push({ ...block, stepNumber, depth, pathLabel });
                
                // Check if we need a new page
                if (currentY + blockHeight > pageHeight - 15) {
                    pdf.addPage();
                    currentY = 15;
                }
                
                const indent = depth * indentWidth;
                const blockWidth = width - indent;
                const blockX = x + indent;
                
                // Determine block color based on type
                let bgColor = [255, 255, 255];
                let borderColor = colors.gray;
                
                if (mode === 'current') {
                    if (block.issueType === 'error') {
                        bgColor = [254, 242, 242];
                        borderColor = colors.red;
                    } else if (block.issueType === 'warning') {
                        bgColor = [255, 247, 237];
                        borderColor = colors.orange;
                    }
                } else if (mode === 'proposed') {
                    if (block.changeType === 'fix') {
                        bgColor = [240, 253, 244];
                        borderColor = colors.green;
                    } else if (block.changeType === 'new') {
                        bgColor = [239, 246, 255];
                        borderColor = colors.primary;
                    } else if (block.changeType === 'modified') {
                        bgColor = [255, 247, 237];
                        borderColor = colors.orange;
                    }
                }
                
                // Draw path label (e.g., "YES", "NO") if this is a branch
                if (pathLabel && depth > 0) {
                    pdf.setFontSize(7);
                    pdf.setFont('helvetica', 'bold');
                    pdf.setTextColor(...colors.gray);
                    pdf.text(pathLabel, blockX - 2, currentY + blockHeight/2, { align: 'right' });
                }
                
                // Draw indent lines for tree structure
                if (depth > 0) {
                    pdf.setDrawColor(200, 200, 200);
                    pdf.setLineWidth(0.3);
                    // Vertical line
                    pdf.line(blockX - 6, currentY - 2, blockX - 6, currentY + blockHeight/2);
                    // Horizontal line to block
                    pdf.line(blockX - 6, currentY + blockHeight/2, blockX - 2, currentY + blockHeight/2);
                }
                
                // Draw block background
                pdf.setFillColor(...bgColor);
                pdf.setDrawColor(...borderColor);
                pdf.setLineWidth(0.4);
                pdf.roundedRect(blockX, currentY, blockWidth, blockHeight, 2, 2, 'FD');
                
                // Step number circle
                pdf.setFillColor(...borderColor);
                pdf.circle(blockX + 6, currentY + blockHeight/2, 4, 'F');
                pdf.setFontSize(7);
                pdf.setFont('helvetica', 'bold');
                pdf.setTextColor(255, 255, 255);
                pdf.text(String(stepNumber), blockX + 6, currentY + blockHeight/2 + 1.5, { align: 'center' });
                
                // Step type indicator
                const typeLabel = stepTypes[block.stepType] || '';
                if (typeLabel) {
                    pdf.setFontSize(5);
                    pdf.setFont('helvetica', 'bold');
                    pdf.setTextColor(...colors.gray);
                    pdf.text(typeLabel, blockX + 12, currentY + blockHeight/2 + 1);
                }
                
                // Block name
                pdf.setFontSize(9);
                pdf.setFont('helvetica', 'bold');
                pdf.setTextColor(...colors.dark);
                const nameMaxWidth = blockWidth - 55;
                const nameX = typeLabel ? blockX + 24 : blockX + 14;
                let name = block.name || 'Untitled';
                if (pdf.getTextWidth(name) > nameMaxWidth) {
                    while (pdf.getTextWidth(name + '...') > nameMaxWidth && name.length > 0) {
                        name = name.slice(0, -1);
                    }
                    name += '...';
                }
                pdf.text(name, nameX, currentY + 7);
                
                // Description
                if (block.description) {
                    pdf.setFontSize(7);
                    pdf.setFont('helvetica', 'normal');
                    pdf.setTextColor(...colors.gray);
                    let desc = block.description;
                    if (pdf.getTextWidth(desc) > nameMaxWidth) {
                        while (pdf.getTextWidth(desc + '...') > nameMaxWidth && desc.length > 0) {
                            desc = desc.slice(0, -1);
                        }
                        desc += '...';
                    }
                    pdf.text(desc, nameX, currentY + 14);
                }
                
                // Branch indicator for decision blocks
                const childIds = children.get(blockId) || [];
                if (childIds.length > 1) {
                    pdf.setFillColor(...colors.orange);
                    pdf.roundedRect(blockX + blockWidth - 30, currentY + 3, 26, 6, 1, 1, 'F');
                    pdf.setFontSize(5);
                    pdf.setFont('helvetica', 'bold');
                    pdf.setTextColor(255, 255, 255);
                    pdf.text(`${childIds.length} PATHS`, blockX + blockWidth - 17, currentY + 7, { align: 'center' });
                }
                
                // Issue/Change badge
                let badge = '';
                let badgeColor = colors.gray;
                if (mode === 'current' && block.issueType) {
                    badge = block.issueType.toUpperCase();
                    badgeColor = block.issueType === 'error' ? colors.red : colors.orange;
                } else if (mode === 'proposed' && block.changeType) {
                    badge = block.changeType.toUpperCase();
                    badgeColor = block.changeType === 'fix' ? colors.green : 
                                block.changeType === 'new' ? colors.primary : colors.orange;
                }
                
                if (badge && childIds.length <= 1) {
                    const badgeWidth = pdf.getTextWidth(badge) + 4;
                    pdf.setFillColor(...badgeColor);
                    pdf.roundedRect(blockX + blockWidth - badgeWidth - 4, currentY + 3, badgeWidth, 6, 1, 1, 'F');
                    pdf.setFontSize(5);
                    pdf.setFont('helvetica', 'bold');
                    pdf.setTextColor(255, 255, 255);
                    pdf.text(badge, blockX + blockWidth - badgeWidth/2 - 4, currentY + 7, { align: 'center' });
                }
                
                currentY += blockHeight + blockGap;
                
                // Draw children (handle forks)
                if (childIds.length === 1) {
                    // Single path - draw arrow
                    const arrowY = currentY - blockGap + 1;
                    pdf.setDrawColor(...colors.gray);
                    pdf.setLineWidth(0.3);
                    pdf.line(blockX + blockWidth/2, arrowY, blockX + blockWidth/2, arrowY + blockGap - 2);
                    pdf.setFillColor(...colors.gray);
                    pdf.triangle(
                        blockX + blockWidth/2, arrowY + blockGap - 1,
                        blockX + blockWidth/2 - 1.5, arrowY + blockGap - 3,
                        blockX + blockWidth/2 + 1.5, arrowY + blockGap - 3,
                        'F'
                    );
                    drawBlock(childIds[0], depth, null);
                } else if (childIds.length > 1) {
                    // Multiple paths - draw each with label
                    childIds.forEach((childId, idx) => {
                        const label = connectionLabels.get(`${blockId}->${childId}`) || `Path ${idx + 1}`;
                        drawBlock(childId, depth + 1, label.toUpperCase());
                    });
                }
            };
            
            // Draw all roots
            roots.forEach(root => {
                drawBlock(root.id, 0, null);
            });
            
            // Draw any unvisited blocks (disconnected)
            blocks.forEach(block => {
                if (!visited.has(block.id)) {
                    if (currentY > pageHeight - 30) {
                        pdf.addPage();
                        currentY = 15;
                    }
                    // Add separator for disconnected blocks
                    pdf.setFontSize(8);
                    pdf.setFont('helvetica', 'italic');
                    pdf.setTextColor(...colors.gray);
                    pdf.text('(Disconnected steps)', x, currentY);
                    currentY += 6;
                    drawBlock(block.id, 0, null);
                }
            });
            
            return currentY;
        }
        
        drawPDFComparisonAligned(pdf, x, y, colWidth, colors, currentBlocks, proposedBlocks) {
            const pageHeight = pdf.internal.pageSize.getHeight();
            const blockHeight = 18;
            const blockGap = 6;
            const rowHeight = blockHeight + blockGap;
            
            // Sort blocks by y position
            const sortedCurrent = [...currentBlocks].sort((a, b) => (a.y || 0) - (b.y || 0));
            const sortedProposed = [...proposedBlocks].sort((a, b) => (a.y || 0) - (b.y || 0));
            
            // Create matched pairs using multiple strategies
            const pairs = [];
            const usedCurrent = new Set();
            const usedProposed = new Set();
            
            // Strategy 1: Match by issue-fix links
            this.issueFixLinks.forEach(link => {
                const currentBlock = currentBlocks.find(b => b.id === link.issueId);
                const proposedBlock = proposedBlocks.find(b => b.id === link.fixId);
                if (currentBlock && proposedBlock) {
                    pairs.push({ current: currentBlock, proposed: proposedBlock, matchType: 'linked' });
                    usedCurrent.add(currentBlock.id);
                    usedProposed.add(proposedBlock.id);
                }
            });
            
            // Strategy 2: Match by exact name
            sortedCurrent.forEach(cb => {
                if (usedCurrent.has(cb.id)) return;
                const match = sortedProposed.find(pb => 
                    !usedProposed.has(pb.id) && 
                    pb.name?.toLowerCase().trim() === cb.name?.toLowerCase().trim()
                );
                if (match) {
                    pairs.push({ current: cb, proposed: match, matchType: 'name' });
                    usedCurrent.add(cb.id);
                    usedProposed.add(match.id);
                }
            });
            
            // Strategy 3: Match by position order (remaining unmatched)
            const remainingCurrent = sortedCurrent.filter(b => !usedCurrent.has(b.id));
            const remainingProposed = sortedProposed.filter(b => !usedProposed.has(b.id));
            
            // Interleave remaining blocks
            const maxRemaining = Math.max(remainingCurrent.length, remainingProposed.length);
            for (let i = 0; i < maxRemaining; i++) {
                pairs.push({
                    current: remainingCurrent[i] || null,
                    proposed: remainingProposed[i] || null,
                    matchType: 'position'
                });
            }
            
            // Sort pairs by the y position of current block (or proposed if current is null)
            pairs.sort((a, b) => {
                const aY = a.current?.y ?? a.proposed?.y ?? 0;
                const bY = b.current?.y ?? b.proposed?.y ?? 0;
                return aY - bY;
            });
            
            // Step type labels
            const stepTypes = {
                action: 'ACT', decision: 'DEC', api: 'API', email: 'EML', 
                form: 'FRM', data: 'DAT', delay: 'DLY', webhook: 'WHK'
            };
            
            let currentY = y;
            let currentStepNum = 0;
            let proposedStepNum = 0;
            
            // Draw each pair side by side
            pairs.forEach((pair, rowIdx) => {
                // Check page break
                if (currentY + blockHeight > pageHeight - 15) {
                    pdf.addPage();
                    currentY = 15;
                    
                    // Redraw headers on new page
                    pdf.setFontSize(10);
                    pdf.setFont('helvetica', 'bold');
                    pdf.setTextColor(...colors.orange);
                    pdf.text('CURRENT STATE (cont.)', x, currentY);
                    pdf.setTextColor(...colors.green);
                    pdf.text('PROPOSED STATE (cont.)', x + colWidth + 10, currentY);
                    currentY += 8;
                }
                
                // Draw current block (left column)
                if (pair.current) {
                    currentStepNum++;
                    this.drawPDFSingleBlock(pdf, x, currentY, colWidth, blockHeight, colors, pair.current, currentStepNum, 'current', stepTypes);
                } else {
                    // Empty placeholder with dashed border
                    pdf.setDrawColor(...colors.gray);
                    pdf.setLineDashPattern([2, 2], 0);
                    pdf.setLineWidth(0.3);
                    pdf.roundedRect(x, currentY, colWidth, blockHeight, 2, 2, 'D');
                    pdf.setLineDashPattern([], 0);
                    
                    pdf.setFontSize(8);
                    pdf.setFont('helvetica', 'italic');
                    pdf.setTextColor(...colors.gray);
                    pdf.text('(no corresponding step)', x + colWidth/2, currentY + blockHeight/2 + 2, { align: 'center' });
                }
                
                // Draw proposed block (right column)
                const rightX = x + colWidth + 10;
                if (pair.proposed) {
                    proposedStepNum++;
                    this.drawPDFSingleBlock(pdf, rightX, currentY, colWidth, blockHeight, colors, pair.proposed, proposedStepNum, 'proposed', stepTypes);
                } else {
                    // Empty placeholder with dashed border
                    pdf.setDrawColor(...colors.gray);
                    pdf.setLineDashPattern([2, 2], 0);
                    pdf.setLineWidth(0.3);
                    pdf.roundedRect(rightX, currentY, colWidth, blockHeight, 2, 2, 'D');
                    pdf.setLineDashPattern([], 0);
                    
                    pdf.setFontSize(8);
                    pdf.setFont('helvetica', 'italic');
                    pdf.setTextColor(...colors.gray);
                    pdf.text('(no corresponding step)', rightX + colWidth/2, currentY + blockHeight/2 + 2, { align: 'center' });
                }
                
                // Draw connector line between matched blocks
                if (pair.current && pair.proposed && pair.matchType === 'linked') {
                    pdf.setDrawColor(...colors.green);
                    pdf.setLineWidth(0.4);
                    pdf.setLineDashPattern([1, 1], 0);
                    pdf.line(x + colWidth + 1, currentY + blockHeight/2, rightX - 1, currentY + blockHeight/2);
                    pdf.setLineDashPattern([], 0);
                }
                
                currentY += rowHeight;
            });
            
            return currentY;
        }
        
        drawPDFSingleBlock(pdf, x, y, width, height, colors, block, stepNum, mode, stepTypes) {
            // Determine block color based on type
            let bgColor = [255, 255, 255];
            let borderColor = colors.gray;
            
            if (mode === 'current') {
                if (block.issueType === 'error') {
                    bgColor = [254, 242, 242];
                    borderColor = colors.red;
                } else if (block.issueType === 'warning') {
                    bgColor = [255, 247, 237];
                    borderColor = colors.orange;
                }
            } else if (mode === 'proposed') {
                if (block.changeType === 'fix') {
                    bgColor = [240, 253, 244];
                    borderColor = colors.green;
                } else if (block.changeType === 'new') {
                    bgColor = [239, 246, 255];
                    borderColor = colors.primary;
                } else if (block.changeType === 'modified') {
                    bgColor = [255, 247, 237];
                    borderColor = colors.orange;
                }
            }
            
            // Draw block background
            pdf.setFillColor(...bgColor);
            pdf.setDrawColor(...borderColor);
            pdf.setLineWidth(0.4);
            pdf.roundedRect(x, y, width, height, 2, 2, 'FD');
            
            // Step number
            pdf.setFillColor(...borderColor);
            pdf.circle(x + 6, y + height/2, 4, 'F');
            pdf.setFontSize(7);
            pdf.setFont('helvetica', 'bold');
            pdf.setTextColor(255, 255, 255);
            pdf.text(String(stepNum), x + 6, y + height/2 + 1.5, { align: 'center' });
            
            // Step type indicator
            const typeLabel = stepTypes[block.stepType] || '';
            if (typeLabel) {
                pdf.setFontSize(5);
                pdf.setFont('helvetica', 'bold');
                pdf.setTextColor(...colors.gray);
                pdf.text(typeLabel, x + 12, y + height/2 + 1);
            }
            
            // Block name
            pdf.setFontSize(9);
            pdf.setFont('helvetica', 'bold');
            pdf.setTextColor(...colors.dark);
            const nameMaxWidth = width - 50;
            const nameX = typeLabel ? x + 24 : x + 14;
            let name = block.name || 'Untitled';
            if (pdf.getTextWidth(name) > nameMaxWidth) {
                while (pdf.getTextWidth(name + '...') > nameMaxWidth && name.length > 0) {
                    name = name.slice(0, -1);
                }
                name += '...';
            }
            pdf.text(name, nameX, y + 7);
            
            // Description
            if (block.description) {
                pdf.setFontSize(7);
                pdf.setFont('helvetica', 'normal');
                pdf.setTextColor(...colors.gray);
                let desc = block.description;
                if (pdf.getTextWidth(desc) > nameMaxWidth) {
                    while (pdf.getTextWidth(desc + '...') > nameMaxWidth && desc.length > 0) {
                        desc = desc.slice(0, -1);
                    }
                    desc += '...';
                }
                pdf.text(desc, nameX, y + 13);
            }
            
            // Issue/Change badge
            let badge = '';
            let badgeColor = colors.gray;
            if (mode === 'current' && block.issueType) {
                badge = block.issueType.toUpperCase();
                badgeColor = block.issueType === 'error' ? colors.red : colors.orange;
            } else if (mode === 'proposed' && block.changeType) {
                badge = block.changeType.toUpperCase();
                badgeColor = block.changeType === 'fix' ? colors.green : 
                            block.changeType === 'new' ? colors.primary : colors.orange;
            }
            
            if (badge) {
                const badgeWidth = pdf.getTextWidth(badge) + 4;
                pdf.setFillColor(...badgeColor);
                pdf.roundedRect(x + width - badgeWidth - 4, y + 3, badgeWidth, 6, 1, 1, 'F');
                pdf.setFontSize(5);
                pdf.setFont('helvetica', 'bold');
                pdf.setTextColor(255, 255, 255);
                pdf.text(badge, x + width - badgeWidth/2 - 4, y + 7, { align: 'center' });
            }
        }
        
        drawPDFBlockDetails(pdf, x, y, width, colors, blocks, mode) {
            const pageHeight = pdf.internal.pageSize.getHeight();
            
            // Section header
            pdf.setFontSize(12);
            pdf.setFont('helvetica', 'bold');
            pdf.setTextColor(...colors.primary);
            pdf.text('STEP DETAILS', x, y);
            y += 8;
            
            // Sort blocks
            const sortedBlocks = [...blocks].sort((a, b) => (a.y || 0) - (b.y || 0));
            
            sortedBlocks.forEach((block, idx) => {
                // Check page break
                if (y + 30 > pageHeight - 15) {
                    pdf.addPage();
                    y = 15;
                }
                
                // Block header
                pdf.setFillColor(245, 247, 250);
                pdf.roundedRect(x, y, width, 8, 1, 1, 'F');
                pdf.setFontSize(9);
                pdf.setFont('helvetica', 'bold');
                pdf.setTextColor(...colors.dark);
                pdf.text(`${idx + 1}. ${block.name || 'Untitled'}`, x + 3, y + 5.5);
                y += 10;
                
                // Details
                const details = [];
                if (block.description) details.push(['Description', block.description]);
                if (block.stepType) details.push(['Type', block.stepType.charAt(0).toUpperCase() + block.stepType.slice(1)]);
                if (mode === 'current' && block.issueText) details.push(['Issue', block.issueText]);
                if (mode === 'proposed' && block.fixText) details.push(['Fix', block.fixText]);
                if (block.owner) details.push(['Owner', block.owner]);
                if (block.systems) details.push(['Systems', block.systems]);
                if (block.timeEstimate) details.push(['Time', block.timeEstimate]);
                
                details.forEach(([label, value]) => {
                    if (y + 6 > pageHeight - 15) {
                        pdf.addPage();
                        y = 15;
                    }
                    
                    pdf.setFontSize(7);
                    pdf.setFont('helvetica', 'bold');
                    pdf.setTextColor(...colors.gray);
                    pdf.text(label + ':', x + 3, y + 4);
                    
                    pdf.setFont('helvetica', 'normal');
                    pdf.setTextColor(...colors.dark);
                    
                    // Word wrap long values
                    const maxWidth = width - 30;
                    const valueX = x + 28;
                    let text = value || '-';
                    const lines = pdf.splitTextToSize(text, maxWidth);
                    lines.forEach((line, lineIdx) => {
                        pdf.text(line, valueX, y + 4 + (lineIdx * 4));
                    });
                    y += Math.max(6, lines.length * 4 + 2);
                });
                
                y += 4;
            });
            
            return y;
        }
        
        drawPDFChangeSummary(pdf, x, y, width, colors, currentBlocks, proposedBlocks) {
            const pageHeight = pdf.internal.pageSize.getHeight();
            
            // Section header
            pdf.setFontSize(12);
            pdf.setFont('helvetica', 'bold');
            pdf.setTextColor(...colors.primary);
            pdf.text('CHANGE SUMMARY', x, y);
            y += 8;
            
            // Issues and their fixes
            const issues = currentBlocks.filter(b => b.issueType);
            const fixes = proposedBlocks.filter(b => b.changeType === 'fix');
            
            if (issues.length > 0) {
                pdf.setFontSize(10);
                pdf.setFont('helvetica', 'bold');
                pdf.setTextColor(...colors.red);
                pdf.text('Issues Identified:', x, y);
                y += 6;
                
                issues.forEach((issue, idx) => {
                    if (y + 10 > pageHeight - 15) {
                        pdf.addPage();
                        y = 15;
                    }
                    
                    pdf.setFillColor(254, 242, 242);
                    pdf.roundedRect(x, y, width, 10, 1, 1, 'F');
                    
                    pdf.setFontSize(8);
                    pdf.setFont('helvetica', 'bold');
                    pdf.setTextColor(...colors.dark);
                    pdf.text(` ${issue.name}`, x + 3, y + 4);
                    
                    if (issue.issueText) {
                        pdf.setFont('helvetica', 'normal');
                        pdf.setTextColor(...colors.gray);
                        const truncated = issue.issueText.length > 80 ? issue.issueText.slice(0, 77) + '...' : issue.issueText;
                        pdf.text(truncated, x + 5, y + 8);
                    }
                    
                    y += 12;
                });
                
                y += 4;
            }
            
            if (fixes.length > 0) {
                pdf.setFontSize(10);
                pdf.setFont('helvetica', 'bold');
                pdf.setTextColor(...colors.green);
                pdf.text('Proposed Fixes:', x, y);
                y += 6;
                
                fixes.forEach((fix, idx) => {
                    if (y + 10 > pageHeight - 15) {
                        pdf.addPage();
                        y = 15;
                    }
                    
                    pdf.setFillColor(240, 253, 244);
                    pdf.roundedRect(x, y, width, 10, 1, 1, 'F');
                    
                    pdf.setFontSize(8);
                    pdf.setFont('helvetica', 'bold');
                    pdf.setTextColor(...colors.dark);
                    pdf.text(` ${fix.name}`, x + 3, y + 4);
                    
                    if (fix.fixText) {
                        pdf.setFont('helvetica', 'normal');
                        pdf.setTextColor(...colors.gray);
                        const truncated = fix.fixText.length > 80 ? fix.fixText.slice(0, 77) + '...' : fix.fixText;
                        pdf.text(truncated, x + 5, y + 8);
                    }
                    
                    y += 12;
                });
            }
            
            // Traceability section
            if (this.issueFixLinks.length > 0) {
                y += 6;
                if (y + 20 > pageHeight - 15) {
                    pdf.addPage();
                    y = 15;
                }
                
                pdf.setFontSize(10);
                pdf.setFont('helvetica', 'bold');
                pdf.setTextColor(...colors.primary);
                pdf.text('Issue-Fix Traceability:', x, y);
                y += 6;
                
                this.issueFixLinks.forEach(link => {
                    if (y + 8 > pageHeight - 15) {
                        pdf.addPage();
                        y = 15;
                    }
                    
                    const issue = this.current.blocks.get(link.issueId);
                    const fix = this.proposed.blocks.get(link.fixId);
                    
                    if (issue && fix) {
                        pdf.setFontSize(7);
                        pdf.setFont('helvetica', 'normal');
                        pdf.setTextColor(...colors.dark);
                        pdf.text(`${issue.name}  -->  ${fix.name}`, x + 3, y + 4);
                        y += 6;
                    }
                });
            }
            
            return y;
        }
        
        async exportFlowPNG(mode) {
            const flow = this.currentFlowIsDrive ? this.driveFlows[this.currentFlowId] : this.flows[this.currentFlowId];
            const timestamp = new Date().toISOString().slice(0, 10);
            const baseName = (flow.name || 'flow').replace(/\s+/g, '_');
            
            // Use html2canvas to capture the flow canvas
            if (!window.html2canvas) {
                // Dynamically load html2canvas if not present
                await new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
                    script.onload = resolve;
                    script.onerror = reject;
                    document.head.appendChild(script);
                });
            }
            
            const capturePane = async (paneId, label) => {
                const canvas = document.getElementById(paneId === 'current' ? 'currentCanvas' : 'proposedCanvas');
                const blocksContainer = document.getElementById(paneId === 'current' ? 'currentBlocksContainer' : 'proposedBlocksContainer');
                const connectionsSvg = document.getElementById(paneId === 'current' ? 'currentConnectionsSvg' : 'proposedConnectionsSvg');
                const pane = this.getPane(paneId);
                
                if (!canvas || pane.blocks.size === 0) {
                    return null;
                }
                
                // Calculate bounds of all blocks and connections
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                pane.blocks.forEach(block => {
                    minX = Math.min(minX, block.x);
                    minY = Math.min(minY, block.y);
                    maxX = Math.max(maxX, block.x + 280); // Block width + margin
                    maxY = Math.max(maxY, block.y + 180); // Block height + margin
                });
                
                // Also consider connection waypoints
                pane.connections.forEach(conn => {
                    if (conn.waypoints) {
                        conn.waypoints.forEach(wp => {
                            minX = Math.min(minX, wp.x - 20);
                            maxX = Math.max(maxX, wp.x + 20);
                            minY = Math.min(minY, wp.y - 20);
                            maxY = Math.max(maxY, wp.y + 20);
                        });
                    }
                });
                
                // Add padding
                const padding = 60;
                minX = Math.max(0, minX - padding);
                minY = Math.max(0, minY - padding);
                maxX += padding;
                maxY += padding;
                
                const width = maxX - minX;
                const height = maxY - minY;
                
                // Create wrapper
                const wrapper = document.createElement('div');
                wrapper.style.cssText = `position:fixed;left:-9999px;width:${width}px;height:${height}px;background:#1a1a2e;overflow:hidden;`;
                
                // Clone and position SVG connections
                const svgClone = connectionsSvg.cloneNode(true);
                svgClone.style.cssText = `position:absolute;left:0;top:0;width:${width}px;height:${height}px;transform:translate(${-minX}px,${-minY}px);pointer-events:none;`;
                svgClone.setAttribute('width', width);
                svgClone.setAttribute('height', height);
                wrapper.appendChild(svgClone);
                
                // Clone and position blocks
                const blocksClone = blocksContainer.cloneNode(true);
                blocksClone.style.cssText = `position:absolute;left:0;top:0;width:${width}px;height:${height}px;transform:translate(${-minX}px,${-minY}px);`;
                wrapper.appendChild(blocksClone);
                
                // Add title header
                const header = document.createElement('div');
                header.style.cssText = `position:absolute;top:0;left:0;right:0;height:40px;background:linear-gradient(180deg,rgba(26,26,46,0.95) 0%,rgba(26,26,46,0) 100%);padding:10px 15px;z-index:1000;`;
                
                const title = document.createElement('div');
                title.style.cssText = 'color:#fff;font-size:14px;font-weight:600;font-family:system-ui;';
                title.textContent = `${flow.name} - ${label}`;
                header.appendChild(title);
                
                const dateEl = document.createElement('div');
                dateEl.style.cssText = 'position:absolute;top:10px;right:15px;color:#64748b;font-size:10px;font-family:system-ui;';
                dateEl.textContent = new Date().toLocaleString();
                header.appendChild(dateEl);
                
                wrapper.appendChild(header);
                document.body.appendChild(wrapper);
                
                try {
                    const resultCanvas = await html2canvas(wrapper, {
                        backgroundColor: '#1a1a2e',
                        scale: 2,
                        useCORS: true,
                        logging: false,
                        width: width,
                        height: height,
                        onclone: (clonedDoc) => {
                            // Ensure SVG paths are visible
                            const paths = clonedDoc.querySelectorAll('path.connection');
                            paths.forEach(path => {
                                path.style.stroke = '#475569';
                                path.style.strokeWidth = '2';
                                path.style.fill = 'none';
                            });
                        }
                    });
                    
                    document.body.removeChild(wrapper);
                    return resultCanvas;
                } catch (err) {
                    console.error('Canvas capture error:', err);
                    document.body.removeChild(wrapper);
                    return null;
                }
            };
            
            this.toast('Generating PNG...', 'info');
            
            if (mode === 'both') {
                const currentCanvas = await capturePane('current', 'Current State (AS-IS)');
                const proposedCanvas = await capturePane('proposed', 'Proposed State (TO-BE)');
                
                if (!currentCanvas && !proposedCanvas) {
                    this.toast('No flows to export', 'error');
                    return;
                }
                
                const combinedCanvas = document.createElement('canvas');
                const ctx = combinedCanvas.getContext('2d');
                
                const cw = currentCanvas ? currentCanvas.width : 0;
                const ch = currentCanvas ? currentCanvas.height : 0;
                const pw = proposedCanvas ? proposedCanvas.width : 0;
                const ph = proposedCanvas ? proposedCanvas.height : 0;
                
                const gap = 60;
                combinedCanvas.width = cw + pw + gap;
                combinedCanvas.height = Math.max(ch, ph);
                
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, combinedCanvas.width, combinedCanvas.height);
                
                if (currentCanvas) ctx.drawImage(currentCanvas, 0, 0);
                if (proposedCanvas) ctx.drawImage(proposedCanvas, cw + gap, 0);
                
                // Add divider line
                ctx.strokeStyle = '#374151';
                ctx.lineWidth = 2;
                ctx.setLineDash([8, 4]);
                ctx.beginPath();
                ctx.moveTo(cw + gap/2, 30);
                ctx.lineTo(cw + gap/2, combinedCanvas.height - 30);
                ctx.stroke();
                
                combinedCanvas.toBlob(blob => {
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = `${baseName}_comparison_${timestamp}.png`;
                    a.click();
                    this.toast('PNG exported', 'success');
                }, 'image/png');
                
            } else {
                const resultCanvas = await capturePane(mode, mode === 'current' ? 'Current State (AS-IS)' : 'Proposed State (TO-BE)');
                
                if (!resultCanvas) {
                    this.toast(`No blocks in ${mode} pane to export`, 'error');
                    return;
                }
                
                resultCanvas.toBlob(blob => {
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = `${baseName}_${mode}_${timestamp}.png`;
                    a.click();
                    this.toast('PNG exported', 'success');
                }, 'image/png');
            }
        }

        exportJSON() {
            const flow = this.currentFlowIsDrive ? this.driveFlows[this.currentFlowId] : this.flows[this.currentFlowId];
            const data = { ...flow, current: { blocks: Array.from(this.current.blocks.values()), connections: this.current.connections }, proposed: { blocks: Array.from(this.proposed.blocks.values()), connections: this.proposed.connections }, issueFixLinks: this.issueFixLinks, exportedAt: new Date().toISOString() };
            // Remove drive-specific fields from export
            delete data.driveFileId;
            delete data.isDrive;
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const now = new Date();
            const timestamp = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')}_${String(now.getHours()).padStart(2,'0')}${String(now.getMinutes()).padStart(2,'0')}`;
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = (flow.name || 'analysis').replace(/\s+/g, '_') + '_' + timestamp + '.json'; a.click();
            this.toast('JSON exported', 'success');
        }

        exportReport() {
            const flow = this.currentFlowIsDrive ? this.driveFlows[this.currentFlowId] : this.flows[this.currentFlowId];
            const currentBlocks = Array.from(this.current.blocks.values());
            const proposedBlocks = Array.from(this.proposed.blocks.values());
            const issues = currentBlocks.filter(b => b.issueType);
            const html = `<!DOCTYPE html><html><head><title>${flow.name} - Report</title><style>body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;max-width:800px;margin:0 auto;padding:30px;color:#1a1a2e;}h1{border-bottom:3px solid #3b82f6;padding-bottom:10px;}h2{color:#3b82f6;margin-top:24px;}.summary{display:grid;grid-template-columns:repeat(4,1fr);gap:12px;margin:20px 0;}.stat{background:#f8fafc;padding:16px;border-radius:6px;text-align:center;}.stat-value{font-size:28px;font-weight:700;}.stat-value.issues{color:#ef4444;}.stat-value.warnings{color:#f97316;}.stat-value.fixes{color:#22c55e;}.stat-label{font-size:11px;color:#64748b;text-transform:uppercase;}.card{background:#fef2f2;border-left:3px solid #ef4444;padding:12px;margin:8px 0;border-radius:0 6px 6px 0;}.card.fix{background:#f0fdf4;border-left-color:#22c55e;}.card-title{font-weight:600;margin-bottom:3px;}.card-desc{color:#64748b;font-size:13px;}.trace{display:flex;align-items:center;gap:16px;padding:10px;background:#f8fafc;border-radius:6px;margin:6px 0;}.meta{font-size:11px;color:#94a3b8;margin-top:30px;border-top:1px solid #e2e8f0;padding-top:12px;}</style></head><body><h1>${flow.name}</h1><p>${flow.description || 'Process analysis report'}</p><div class="summary"><div class="stat"><div class="stat-value">${currentBlocks.length}</div><div class="stat-label">Current</div></div><div class="stat"><div class="stat-value issues">${issues.filter(b=>b.issueType==='error').length}</div><div class="stat-label">Issues</div></div><div class="stat"><div class="stat-value warnings">${issues.filter(b=>b.issueType==='warning').length}</div><div class="stat-label">Warnings</div></div><div class="stat"><div class="stat-value fixes">${proposedBlocks.filter(b=>b.changeType==='fix'||b.fixText).length}</div><div class="stat-label">Fixes</div></div></div><h2>Issues Identified</h2>${issues.map(b=>`<div class="card"><div class="card-title">${b.name}</div><div class="card-desc">${b.issueText||b.description||'No description'}</div></div>`).join('')||'<p>No issues</p>'}<h2>Proposed Fixes</h2>${proposedBlocks.filter(b=>b.changeType==='fix'||b.fixText).map(b=>`<div class="card fix"><div class="card-title">${b.name}</div><div class="card-desc">${b.fixText||b.description||'No description'}</div></div>`).join('')||'<p>No fixes</p>'}<h2>Traceability</h2>${issues.map(issue=>{const link=this.issueFixLinks.find(l=>l.issueId===issue.id);const fix=link?this.proposed.blocks.get(link.fixId):null;return`<div class="trace"><div style="flex:1;"><strong>Issue:</strong> ${issue.name}</div><div></div><div style="flex:1;"><strong>Fix:</strong> ${fix?fix.name:'Not linked'}</div></div>`;}).join('')}<div class="meta">Generated ${new Date().toLocaleString()} | FlowBuilder Pro</div></body></html>`;
            const blob = new Blob([html], { type: 'text/html' });
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = (flow.name || 'report').replace(/\s+/g, '_') + '_report.html'; a.click();
            this.toast('Report exported', 'success');
        }

        exportSummary() {
            const flow = this.currentFlowIsDrive ? this.driveFlows[this.currentFlowId] : this.flows[this.currentFlowId];
            const currentBlocks = Array.from(this.current.blocks.values());
            const proposedBlocks = Array.from(this.proposed.blocks.values());
            const issues = currentBlocks.filter(b => b.issueType);
            const fixes = proposedBlocks.filter(b => b.changeType === 'fix' || b.fixText);
            const html = `<!DOCTYPE html><html><head><title>${flow.name} - Summary</title><style>body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;max-width:600px;margin:0 auto;padding:30px;color:#1a1a2e;}h1{font-size:24px;margin-bottom:6px;}.subtitle{color:#64748b;margin-bottom:24px;}.highlight{background:linear-gradient(135deg,#3b82f6,#8b5cf6);color:white;padding:20px;border-radius:10px;margin:20px 0;}.highlight h2{margin:0 0 12px 0;font-size:16px;}.highlight-grid{display:grid;grid-template-columns:1fr 1fr;gap:12px;}.highlight-stat{text-align:center;}.highlight-value{font-size:32px;font-weight:700;}.highlight-label{font-size:11px;opacity:0.8;}.section{margin:24px 0;}.section h3{font-size:14px;color:#3b82f6;margin-bottom:10px;}ul{padding-left:18px;}li{margin:6px 0;}.footer{margin-top:30px;padding-top:16px;border-top:1px solid #e2e8f0;font-size:11px;color:#94a3b8;}</style></head><body><h1>${flow.name}</h1><p class="subtitle">Executive Summary</p><div class="highlight"><h2>Key Metrics</h2><div class="highlight-grid"><div class="highlight-stat"><div class="highlight-value">${issues.length}</div><div class="highlight-label">Issues Found</div></div><div class="highlight-stat"><div class="highlight-value">${fixes.length}</div><div class="highlight-label">Fixes Proposed</div></div></div></div><div class="section"><h3>Overview</h3><p>${flow.description||'This analysis documents the current process and proposes improvements.'}</p><p>Current: <strong>${currentBlocks.length} steps</strong>. Issues: <strong>${issues.length}</strong>.</p></div><div class="section"><h3>Top Issues</h3><ul>${issues.slice(0,5).map(b=>`<li><strong>${b.name}</strong>: ${b.issueText||'Issue identified'}</li>`).join('')||'<li>No issues</li>'}</ul></div><div class="section"><h3>Recommended Actions</h3><ul>${fixes.slice(0,5).map(b=>`<li><strong>${b.name}</strong>: ${b.fixText||'Implement fix'}</li>`).join('')||'<li>No actions</li>'}</ul></div><div class="footer">Generated ${new Date().toLocaleString()} | FlowBuilder Pro</div></body></html>`;
            const blob = new Blob([html], { type: 'text/html' });
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = (flow.name || 'summary').replace(/\s+/g, '_') + '_summary.html'; a.click();
            this.toast('Summary exported', 'success');
        }

        showModal(id) { document.getElementById(id).classList.add('show'); }
        hideModal(id) { document.getElementById(id).classList.remove('show'); }
        
        // Dashboard Methods
        async showDashboard() {
            // End current editing session
            if (this.currentFlowId) {
                await this.endEditingSession(this.currentFlowId);
            }
            
            document.getElementById('dashboardScreen').classList.add('show');
            document.getElementById('mainApp').style.display = 'none';
            document.getElementById('flowEnvSelector').style.display = 'none';
            document.getElementById('flowStatusSelector').style.display = 'none';
            // Clear search
            this.dashboardSearchTerm = '';
            const searchInput = document.getElementById('dashboardSearch');
            if (searchInput) searchInput.value = '';
            
            // Load editing sessions before rendering
            await this.loadEditingSessions();
            this.renderDashboard();
        }
        
        hideDashboard() {
            document.getElementById('dashboardScreen').classList.remove('show');
            document.getElementById('mainApp').style.display = 'flex';
        }
        
        updateFlowStatusBadge() {
            const selector = document.getElementById('flowStatusSelector');
            if (!selector) return;
            
            // Remove all status classes
            selector.classList.remove('draft', 'documenting', 'ready-dev', 'in-dev', 'ready-review', 'approved');
            
            // Add current status class
            const status = selector.value || 'draft';
            selector.classList.add(status);
        }
        
        renderDashboard() {
            this.renderDashboardMetrics();
            this.renderFlowMap();
            this.renderBriefsSection(); // Must be after renderFlowMap since it prepends
        }
        
        renderBriefsSection() {
            const allBriefs = Object.values(this.briefs);
            const searchTerm = this.dashboardSearchTerm || '';
            
            // Filter briefs by search term
            const briefs = searchTerm 
                ? allBriefs.filter(b => 
                    (b.title || '').toLowerCase().includes(searchTerm) ||
                    (b.problem || '').toLowerCase().includes(searchTerm)
                  )
                : allBriefs;
            
            // Sort by updated date
            briefs.sort((a, b) => new Date(b.updatedAt || 0) - new Date(a.updatedAt || 0));
            
            const statusColors = {
                draft: 'draft',
                agreed: 'agreed', 
                'in-progress': 'in-progress',
                validating: 'validating',
                complete: 'complete'
            };
            
            let html = `
                <div class="dashboard-section" id="briefsSection">
                    <div class="dashboard-section-header">
                        <div class="dashboard-section-title">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>
                            Project Briefs
                        </div>
                        <span class="dashboard-section-count">${allBriefs.length}</span>
                    </div>
                    <div class="flow-map">
            `;
            
            // Add "New Brief" card
            if (!searchTerm) {
                html += `
                    <div class="brief-card add-new" id="newBriefCard">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="12" y1="5" x2="12" y2="19"/>
                            <line x1="5" y1="12" x2="19" y2="12"/>
                        </svg>
                        <span>New Brief</span>
                    </div>
                `;
            }
            
            if (briefs.length === 0 && !searchTerm) {
                html += `<div class="env-empty" style="grid-column: span 2;">No briefs yet. Create one to document project agreements.</div>`;
            } else {
                briefs.forEach(brief => {
                    const linkedFlows = (brief.linkedFlows || []).map(fid => this.driveFlows[fid]).filter(f => f);
                    const criteria = brief.criteria || [];
                    const checkedCriteria = criteria.filter(c => c.checked).length;
                    const progress = criteria.length > 0 ? Math.round((checkedCriteria / criteria.length) * 100) : 0;
                    const participants = brief.participants || [];
                    
                    html += `
                        <div class="brief-card" data-brief-id="${brief.id}">
                            <div class="brief-card-header">
                                <div class="brief-card-name">${this.escapeHtml(brief.title || 'Untitled Brief')}</div>
                                <div class="brief-card-status ${statusColors[brief.status] || 'draft'}">${brief.status || 'draft'}</div>
                            </div>
                            <div class="brief-card-problem">${this.escapeHtml(brief.problem || 'No problem statement')}</div>
                            <div class="brief-card-meta">
                                <div class="brief-card-meta-item">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 21v-2a4 4 0 00-4-4H5a4 4 0 00-4 4v2"/><circle cx="9" cy="7" r="4"/></svg>
                                    ${participants.length} participant${participants.length !== 1 ? 's' : ''}
                                </div>
                                <div class="brief-card-meta-item">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 11.08V12a10 10 0 11-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>
                                    ${checkedCriteria}/${criteria.length} criteria
                                </div>
                            </div>
                            ${linkedFlows.length > 0 ? `
                                <div class="brief-card-flows">
                                    <div class="brief-card-flows-label">Linked Flows</div>
                                    <div class="brief-card-flow-links">
                                        ${linkedFlows.slice(0, 3).map(f => `<span class="brief-card-flow-link">${this.escapeHtml(f.name || 'Untitled')}</span>`).join('')}
                                        ${linkedFlows.length > 3 ? `<span class="brief-card-flow-link">+${linkedFlows.length - 3} more</span>` : ''}
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                    `;
                });
            }
            
            html += `</div></div>`;
            
            // Prepend briefs section to flowMapContainer
            const container = document.getElementById('flowMapContainer');
            container.insertAdjacentHTML('afterbegin', html);
            
            // Bind brief events
            document.getElementById('newBriefCard')?.addEventListener('click', () => this.showBriefModal());
            document.querySelectorAll('.brief-card[data-brief-id]').forEach(card => {
                card.addEventListener('click', () => this.showBriefModal(card.dataset.briefId));
            });
        }
        
        renderDashboardMetrics() {
            const flows = Object.values(this.driveFlows);
            let totalSteps = 0;
            let totalIssues = 0;
            let totalFixes = 0;
            let totalWarnings = 0;
            
            const envCounts = { exhibitor: 0, organizer: 0, ea: 0, valverde: 0, other: 0 };
            
            flows.forEach(flow => {
                const currentBlocks = flow.current?.blocks || [];
                const proposedBlocks = flow.proposed?.blocks || [];
                totalSteps += currentBlocks.length + proposedBlocks.length;
                totalIssues += currentBlocks.filter(b => b.issueType === 'error').length;
                totalWarnings += currentBlocks.filter(b => b.issueType === 'warning').length;
                totalFixes += proposedBlocks.filter(b => b.changeType === 'fix').length;
                
                const env = flow.environment || 'other';
                if (envCounts[env] !== undefined) envCounts[env]++;
                else envCounts.other++;
            });
            
            const metricsHtml = `
                <div class="metric-card accent">
                    <div class="metric-value blue">${flows.length}</div>
                    <div class="metric-label">Total Flows</div>
                    <div class="metric-sublabel">
                         ${envCounts.exhibitor}   ${envCounts.organizer}   ${envCounts.ea}   ${envCounts.valverde}   ${envCounts.other}
                    </div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">${totalSteps}</div>
                    <div class="metric-label">Total Steps</div>
                    <div class="metric-sublabel">Current + Proposed</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value red">${totalIssues}</div>
                    <div class="metric-label">Issues</div>
                    <div class="metric-sublabel">Errors identified</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value orange">${totalWarnings}</div>
                    <div class="metric-label">Warnings</div>
                    <div class="metric-sublabel">Potential problems</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value green">${totalFixes}</div>
                    <div class="metric-label">Fixes</div>
                    <div class="metric-sublabel">Proposed solutions</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value purple">${totalIssues > 0 ? Math.round((totalFixes / totalIssues) * 100) : 100}%</div>
                    <div class="metric-label">Coverage</div>
                    <div class="metric-sublabel">Issues with fixes</div>
                </div>
            `;
            
            document.getElementById('metricsGrid').innerHTML = metricsHtml;
        }
        
        renderFlowMap() {
            const allFlows = Object.values(this.driveFlows);
            const searchTerm = this.dashboardSearchTerm || '';
            
            // Filter flows by search term
            const flows = searchTerm 
                ? allFlows.filter(f => 
                    (f.name || '').toLowerCase().includes(searchTerm) ||
                    (f.description || '').toLowerCase().includes(searchTerm)
                  )
                : allFlows;
            
            const environments = [
                { id: 'exhibitor', name: 'Exhibitor Portal', badge: 'exhibitor', icon: '' },
                { id: 'organizer', name: 'Organizer CRM', badge: 'organizer', icon: '' },
                { id: 'ea', name: 'EA Exhibitions', badge: 'ea', icon: '' },
                { id: 'valverde', name: 'Valverde', badge: 'valverde', icon: '' },
                { id: 'other', name: 'Other / General', badge: 'other', icon: '' }
            ];
            
            let html = '';
            
            if (searchTerm && flows.length === 0) {
                html = `<div class="env-empty" style="margin-top:20px;">No flows matching "${this.escapeHtml(searchTerm)}"</div>`;
            } else {
                environments.forEach(env => {
                    const envFlows = flows.filter(f => (f.environment || 'other') === env.id);
                    
                    // Skip empty environments when searching
                    if (searchTerm && envFlows.length === 0) return;
                    
                    html += `
                        <div class="env-section">
                            <div class="env-header">
                                <div class="env-badge ${env.badge}">${env.icon} ${env.name}</div>
                                <div class="env-count">${envFlows.length} flow${envFlows.length !== 1 ? 's' : ''}</div>
                            </div>
                            <div class="flow-map">
                    `;
                    
                    // Add "New Flow" card for this environment (only when not searching)
                    if (!searchTerm) {
                        html += `
                            <div class="flow-card add-new" data-env="${env.id}">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <line x1="12" y1="5" x2="12" y2="19"/>
                                    <line x1="5" y1="12" x2="19" y2="12"/>
                                </svg>
                                <span>New ${env.name} Flow</span>
                            </div>
                        `;
                    }
                    
                    if (envFlows.length === 0 && !searchTerm) {
                        html += `<div class="env-empty" style="grid-column: span 2;">No flows yet in this environment</div>`;
                    } else {
                        envFlows.sort((a, b) => new Date(b.updatedAt || 0) - new Date(a.updatedAt || 0));
                        
                        envFlows.forEach(flow => {
                            const currentBlocks = flow.current?.blocks || [];
                            const proposedBlocks = flow.proposed?.blocks || [];
                            const issues = currentBlocks.filter(b => b.issueType).length;
                            const fixes = proposedBlocks.filter(b => b.changeType === 'fix').length;
                            const updatedDate = flow.updatedAt ? new Date(flow.updatedAt).toLocaleDateString() : 'Unknown';
                            
                            // Highlight search matches
                            let displayName = this.escapeHtml(flow.name || 'Untitled');
                            let displayDesc = this.escapeHtml(flow.description || 'No description');
                            if (searchTerm) {
                                const regex = new RegExp(`(${searchTerm})`, 'gi');
                                displayName = displayName.replace(regex, '<mark style="background:var(--accent-bg);color:var(--accent);padding:0 2px;border-radius:2px;">$1</mark>');
                                displayDesc = displayDesc.replace(regex, '<mark style="background:var(--accent-bg);color:var(--accent);padding:0 2px;border-radius:2px;">$1</mark>');
                            }
                            
                            const flowStatusLabels = {
                                'draft': ' Draft',
                                'documenting': ' Documenting',
                                'ready-dev': ' Ready for Dev',
                                'in-dev': ' In Development',
                                'ready-review': ' Ready for Review',
                                'approved': ' Approved'
                            };
                            const flowStatus = flow.flowStatus || 'draft';
                            const flowStatusLabel = flowStatusLabels[flowStatus] || flowStatusLabels['draft'];
                            
                            // Check if someone is editing this flow
                            const editingSession = this.getActiveSession(flow.id);
                            const isBeingEdited = !!editingSession;
                            const editingIndicatorHtml = editingSession ? `
                                <div class="flow-card-editing-indicator">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>
                                    <span class="editing-user">${this.escapeHtml(editingSession.userName)}</span>
                                    <span class="editing-time"> ${this.formatTimeAgo(editingSession.lastActivity)}</span>
                                </div>
                            ` : '';
                            
                            html += `
                                <div class="flow-card ${isBeingEdited ? 'flow-card-editing' : ''}" data-flow-id="${flow.id}">
                                    <div class="flow-card-actions">
                                        <button class="flow-card-action" data-action="duplicate" title="Duplicate"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="12" height="12"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"/></svg></button>
                                        <button class="flow-card-action danger" data-action="delete" title="Delete"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="12" height="12"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg></button>
                                    </div>
                                    <div class="flow-card-header">
                                        <div class="flow-card-name">${displayName}</div>
                                    </div>
                                    <div class="flow-card-desc">${displayDesc}</div>
                                    <div class="flow-card-stats">
                                        <div class="flow-card-stat">
                                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/></svg>
                                            ${currentBlocks.length} steps
                                        </div>
                                        ${issues > 0 ? `<div class="flow-card-stat issues">
                                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/></svg>
                                            ${issues} issues
                                        </div>` : ''}
                                        ${fixes > 0 ? `<div class="flow-card-stat fixes">
                                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 11.08V12a10 10 0 11-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>
                                            ${fixes} fixes
                                        </div>` : ''}
                                    </div>
                                    <div class="flow-card-date">
                                        <span class="flow-card-status ${flowStatus}">${flowStatusLabel}</span>
                                        <span style="float:right;">Updated: ${updatedDate}</span>
                                    </div>
                                    ${editingIndicatorHtml}
                                </div>
                            `;
                        });
                    }
                    
                    html += `
                            </div>
                        </div>
                    `;
                });
            }
            
            document.getElementById('flowMapContainer').innerHTML = html;
            
            // Bind click events
            document.querySelectorAll('.flow-card[data-flow-id]').forEach(card => {
                card.addEventListener('click', e => {
                    // Check if action button was clicked
                    const actionBtn = e.target.closest('[data-action]');
                    if (actionBtn) {
                        e.stopPropagation();
                        const flowId = card.dataset.flowId;
                        const action = actionBtn.dataset.action;
                        if (action === 'duplicate') this.duplicateFlowById(flowId);
                        else if (action === 'delete') this.deleteFlowFromDashboard(flowId);
                        return;
                    }
                    
                    const flowId = card.dataset.flowId;
                    // Check for editing conflicts before opening
                    this.checkAndOpenFlow(flowId);
                });
            });
            
            document.querySelectorAll('.flow-card.add-new').forEach(card => {
                card.addEventListener('click', () => {
                    const env = card.dataset.env;
                    document.getElementById('newFlowEnv').value = env;
                    this.showModal('flowModal');
                });
            });
        }
        
        escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // ===== FLOW SETTINGS =====
        showFlowSettingsModal() {
            if (!this.currentFlowId) return;
            const flow = this.driveFlows[this.currentFlowId];
            if (!flow) return;
            
            document.getElementById('flowSettingsName').value = flow.name || '';
            document.getElementById('flowSettingsDesc').value = flow.description || '';
            document.getElementById('flowSettingsEnv').value = flow.environment || 'other';
            document.getElementById('flowSettingsCreated').textContent = flow.createdAt ? new Date(flow.createdAt).toLocaleString() : '-';
            document.getElementById('flowSettingsUpdated').textContent = flow.updatedAt ? new Date(flow.updatedAt).toLocaleString() : '-';
            document.getElementById('flowSettingsId').textContent = flow.id || '-';
            document.getElementById('flowSettingsStatus').value = flow.flowStatus || 'draft';
            
            this.renderCrossFlowLinks();
            this.showModal('flowSettingsModal');
        }
        
        saveFlowSettings() {
            if (!this.currentFlowId) return;
            const flow = this.driveFlows[this.currentFlowId];
            if (!flow) return;
            
            flow.name = document.getElementById('flowSettingsName').value.trim() || 'Untitled';
            flow.description = document.getElementById('flowSettingsDesc').value.trim();
            flow.environment = document.getElementById('flowSettingsEnv').value;
            flow.flowStatus = document.getElementById('flowSettingsStatus').value;
            flow.updatedAt = new Date().toISOString();
            
            this.saveToDrive(flow);
            this.updateFlowSelector();
            this.updateFlowStatusBadge();
            document.getElementById('flowEnvSelector').value = flow.environment;
            this.hideModal('flowSettingsModal');
            this.toast('Settings saved', 'success');
        }
        
        deleteCurrentFlow() {
            if (!this.currentFlowId) return;
            if (!confirm('Delete this flow permanently?')) return;
            this.deleteFlow(this.currentFlowId, true);
            this.hideModal('flowSettingsModal');
            this.showDashboard();
        }
        
        // ===== DUPLICATE FLOW =====
        async duplicateFlow() {
            if (!this.currentFlowId) return;
            await this.duplicateFlowById(this.currentFlowId);
        }
        
        async duplicateFlowById(flowId) {
            const flow = this.driveFlows[flowId];
            if (!flow) return;
            
            const id = 'flow_' + Date.now();
            const newFlow = JSON.parse(JSON.stringify(flow));
            newFlow.id = id;
            newFlow.name = (flow.name || 'Untitled') + ' (copy)';
            newFlow.createdAt = new Date().toISOString();
            newFlow.updatedAt = new Date().toISOString();
            delete newFlow.driveFileId;
            
            this.driveFlows[id] = newFlow;
            await this.saveToDrive(newFlow);
            this.renderDashboard();
            this.toast('Flow duplicated', 'success');
        }
        
        deleteFlowFromDashboard(flowId) {
            const flow = this.driveFlows[flowId];
            if (!flow) return;
            if (!confirm(`Delete "${flow.name}"?`)) return;
            this.deleteFlow(flowId, true);
            this.renderDashboard();
        }
        
        // ===== BLOCK SEARCH =====
        searchBlocks(term) {
            this.blockSearchTerm = term.toLowerCase();
            this.blockSearchResults = [];
            this.blockSearchIndex = -1;
            
            // Clear previous highlights
            document.querySelectorAll('.block.search-highlight').forEach(el => el.classList.remove('search-highlight'));
            
            if (!term) return;
            
            // Find matching blocks in both panes
            ['current', 'proposed'].forEach(paneId => {
                const pane = this.getPane(paneId);
                pane.blocks.forEach(block => {
                    const nameMatch = (block.name || '').toLowerCase().includes(term);
                    const descMatch = (block.description || '').toLowerCase().includes(term);
                    if (nameMatch || descMatch) {
                        this.blockSearchResults.push({ block, paneId });
                    }
                });
            });
            
            if (this.blockSearchResults.length > 0) {
                this.jumpToNextSearchResult();
            }
        }
        
        jumpToNextSearchResult() {
            if (this.blockSearchResults.length === 0) return;
            
            this.blockSearchIndex = (this.blockSearchIndex + 1) % this.blockSearchResults.length;
            const result = this.blockSearchResults[this.blockSearchIndex];
            
            // Clear previous highlights
            document.querySelectorAll('.block.search-highlight').forEach(el => el.classList.remove('search-highlight'));
            
            // Highlight and scroll to block
            const blockEl = document.getElementById(result.block.id);
            if (blockEl) {
                blockEl.classList.add('search-highlight');
                this.selectBlock(result.block.id, result.paneId);
                this.centerOnBlock(result.block, result.paneId);
            }
            
            this.toast(`Result ${this.blockSearchIndex + 1} of ${this.blockSearchResults.length}`, 'info');
        }
        
        centerOnBlock(block, paneId) {
            const pane = this.getPane(paneId);
            const els = this.getPaneElements(paneId);
            const rect = els.canvasArea.getBoundingClientRect();
            
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            
            pane.panX = centerX - (block.x + 100) * pane.zoom;
            pane.panY = centerY - (block.y + 50) * pane.zoom;
            
            this.updateCanvasTransform(paneId);
        }
        
        // ===== MULTI-SELECT =====
        clearMultiSelect() {
            const paneId = this.multiSelectPane;
            this.multiSelectedBlocks.forEach(id => {
                const el = document.getElementById(this.getDomId(id, paneId));
                if (el) el.classList.remove('multi-selected');
            });
            this.multiSelectedBlocks.clear();
        }
        
        toggleMultiSelect(blockId, paneId) {
            const el = document.getElementById(this.getDomId(blockId, paneId));
            if (!el) return;
            
            if (this.multiSelectedBlocks.has(blockId)) {
                this.multiSelectedBlocks.delete(blockId);
                el.classList.remove('multi-selected');
            } else {
                this.multiSelectedBlocks.add(blockId);
                this.multiSelectPane = paneId;
                el.classList.add('multi-selected');
            }
        }
        
        selectAllBlocks() {
            const paneId = this.activePane;
            const pane = this.getPane(paneId);
            
            this.clearMultiSelect();
            pane.blocks.forEach(block => {
                this.multiSelectedBlocks.add(block.id);
                const el = document.getElementById(this.getDomId(block.id, paneId));
                if (el) el.classList.add('multi-selected');
            });
            this.multiSelectPane = paneId;
            this.toast(`Selected ${this.multiSelectedBlocks.size} blocks`, 'info');
        }
        
        deleteMultiSelected() {
            if (this.multiSelectedBlocks.size === 0) return;
            if (!confirm(`Delete ${this.multiSelectedBlocks.size} selected blocks?`)) return;
            
            this.saveState('delete-multiple');
            const paneId = this.multiSelectPane;
            const pane = this.getPane(paneId);
            const els = this.getPaneElements(paneId);
            
            this.multiSelectedBlocks.forEach(blockId => {
                const el = document.getElementById(this.getDomId(blockId, paneId));
                if (el) el.remove();
                pane.blocks.delete(blockId);
                pane.connections = pane.connections.filter(c => c.from !== blockId && c.to !== blockId);
            });
            
            this.clearMultiSelect();
            this.updateConnections(paneId);
            this.updateBlockList();
            this.updateMinimap();
            this.renderPanel();
            this.toast('Blocks deleted', 'success');
        }
        
        // ===== CROSS-FLOW LINKS =====
        renderCrossFlowLinks() {
            const container = document.getElementById('crossFlowLinksContainer');
            if (!container) return;
            
            const flow = this.driveFlows[this.currentFlowId];
            const links = flow?.crossFlowLinks || [];
            
            if (links.length === 0) {
                container.innerHTML = '<div style="font-size:11px;color:var(--text-muted);padding:8px 0;">No linked flows</div>';
                return;
            }
            
            container.innerHTML = links.map((link, idx) => {
                const linkedFlow = this.driveFlows[link.flowId];
                const name = linkedFlow?.name || 'Unknown Flow';
                const env = linkedFlow?.environment || 'other';
                const envColors = { exhibitor: '', organizer: '', ea: '', valverde: '', other: '' };
                const typeLabels = { 'triggers': '', 'triggered-by': '', 'related': '', 'subprocess': '' };
                return `
                    <div class="crossflow-link" data-idx="${idx}">
                        <span class="crossflow-link-icon">${typeLabels[link.type] || ''}</span>
                        <span>${envColors[env] || ''}</span>
                        <span class="crossflow-link-name" data-flow-id="${link.flowId}">${this.escapeHtml(name)}</span>
                        <button class="crossflow-link-remove" data-action="remove"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="12" height="12"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button>
                    </div>
                `;
            }).join('');
            
            container.querySelectorAll('.crossflow-link').forEach(el => {
                el.querySelector('[data-action="remove"]')?.addEventListener('click', e => {
                    e.stopPropagation();
                    this.removeCrossFlowLink(parseInt(el.dataset.idx));
                });
                el.querySelector('.crossflow-link-name')?.addEventListener('click', () => {
                    const flowId = el.querySelector('.crossflow-link-name').dataset.flowId;
                    if (flowId && this.driveFlows[flowId]) {
                        this.hideModal('flowSettingsModal');
                        this.loadFlow(flowId, true);
                    }
                });
            });
        }
        
        showCrossflowModal() {
            // Populate the select with available flows
            const select = document.getElementById('crossflowSelect');
            const flows = Object.values(this.driveFlows).filter(f => f.id !== this.currentFlowId);
            const envColors = { exhibitor: '', organizer: '', ea: '', valverde: '', other: '' };
            
            select.innerHTML = flows.length === 0 
                ? '<option value="">No other flows available</option>'
                : flows.map(f => `<option value="${f.id}">${envColors[f.environment || 'other']} ${this.escapeHtml(f.name || 'Untitled')}</option>`).join('');
            
            document.getElementById('crossflowType').value = 'related';
            this.showModal('crossflowModal');
        }
        
        addCrossFlowLink() {
            const flowId = document.getElementById('crossflowSelect').value;
            const type = document.getElementById('crossflowType').value;
            
            if (!flowId) {
                this.toast('Please select a flow', 'error');
                return;
            }
            
            const flow = this.driveFlows[this.currentFlowId];
            if (!flow) return;
            
            if (!flow.crossFlowLinks) flow.crossFlowLinks = [];
            if (flow.crossFlowLinks.some(l => l.flowId === flowId)) {
                this.toast('Flow already linked', 'error');
                return;
            }
            
            flow.crossFlowLinks.push({ flowId, type });
            this.renderCrossFlowLinks();
            this.hideModal('crossflowModal');
            this.toast('Flow linked', 'success');
        }
        
        removeCrossFlowLink(idx) {
            const flow = this.driveFlows[this.currentFlowId];
            if (!flow?.crossFlowLinks) return;
            flow.crossFlowLinks.splice(idx, 1);
            this.renderCrossFlowLinks();
        }
        
        // ===== AUTO-LAYOUT =====
        autoLayout(paneId) {
            const pane = this.getPane(paneId);
            if (pane.blocks.size === 0) return;
            
            this.saveState('auto-layout');
            
            const blocks = Array.from(pane.blocks.values()).filter(b => !b.isHelper);
            const helpers = Array.from(pane.blocks.values()).filter(b => b.isHelper);
            
            if (blocks.length === 0) return;
            
            // ========================================
            // BULLETPROOF AUTO-LAYOUT ALGORITHM
            // ========================================
            
            // Layout constants
            const BLOCK_WIDTH = 260;
            const BLOCK_HEIGHT = 140;
            const H_GAP = 80;           // Horizontal gap between blocks
            const V_GAP = 100;          // Vertical gap between levels
            const START_X = 80;
            const START_Y = 60;
            
            // ----------------------------------------
            // STEP 1: Build directed graph
            // ----------------------------------------
            const graph = {
                children: new Map(),    // id -> [child ids]
                parents: new Map(),     // id -> [parent ids]
                blocks: new Map()       // id -> block reference
            };
            
            blocks.forEach(b => {
                graph.children.set(b.id, []);
                graph.parents.set(b.id, []);
                graph.blocks.set(b.id, b);
            });
            
            // Build edges from connections
            pane.connections.forEach(conn => {
                const from = conn.from;
                const to = conn.to;
                // Only process if both blocks exist and aren't helpers
                if (graph.blocks.has(from) && graph.blocks.has(to)) {
                    const childList = graph.children.get(from);
                    const parentList = graph.parents.get(to);
                    if (!childList.includes(to)) childList.push(to);
                    if (!parentList.includes(from)) parentList.push(from);
                }
            });
            
            // ----------------------------------------
            // STEP 2: Assign levels using longest path
            // ----------------------------------------
            // Each node's level = max(parent levels) + 1
            // This ensures proper layering for DAGs
            
            const blockLevel = new Map();
            
            // Find roots (blocks with no parents)
            const roots = blocks.filter(b => graph.parents.get(b.id).length === 0);
            
            // If no roots found (cycle), pick one arbitrarily
            if (roots.length === 0 && blocks.length > 0) {
                roots.push(blocks[0]);
            }
            
            // Initialize all levels to -1 (unassigned)
            blocks.forEach(b => blockLevel.set(b.id, -1));
            
            // BFS from roots, but ensure each node is placed at its MAXIMUM depth
            // (the longest path from any root to this node)
            function assignLevels() {
                // Initialize roots at level 0
                roots.forEach(r => blockLevel.set(r.id, 0));
                
                // Process queue: we may visit nodes multiple times
                // as we discover longer paths to them
                const queue = [...roots.map(r => r.id)];
                const processed = new Set();
                let iterations = 0;
                const maxIterations = blocks.length * blocks.length + 100;
                
                while (queue.length > 0 && iterations < maxIterations) {
                    iterations++;
                    const nodeId = queue.shift();
                    const nodeLevel = blockLevel.get(nodeId);
                    
                    // Process all children
                    const children = graph.children.get(nodeId) || [];
                    for (const childId of children) {
                        const currentChildLevel = blockLevel.get(childId);
                        const newLevel = nodeLevel + 1;
                        
                        // Update child level if we found a longer path
                        if (newLevel > currentChildLevel) {
                            blockLevel.set(childId, newLevel);
                            // Re-queue to propagate to its children
                            queue.push(childId);
                        }
                    }
                }
                
                // Handle any disconnected blocks (assign to level 0)
                blocks.forEach(b => {
                    if (blockLevel.get(b.id) === -1) {
                        blockLevel.set(b.id, 0);
                    }
                });
            }
            
            assignLevels();
            
            // Find max level
            let maxLevel = 0;
            blocks.forEach(b => {
                maxLevel = Math.max(maxLevel, blockLevel.get(b.id));
            });
            
            // ----------------------------------------
            // STEP 3: Group blocks by level
            // ----------------------------------------
            const levelGroups = new Map();
            for (let i = 0; i <= maxLevel; i++) {
                levelGroups.set(i, []);
            }
            blocks.forEach(b => {
                levelGroups.get(blockLevel.get(b.id)).push(b);
            });
            
            // ----------------------------------------
            // STEP 4: Order blocks within each level
            // ----------------------------------------
            // Goal: minimize edge crossings by ordering children
            // based on their parents' positions
            
            // First, order level 0 (roots) by their subtree size
            function countDescendants(nodeId, visited = new Set()) {
                if (visited.has(nodeId)) return 0;
                visited.add(nodeId);
                let count = 1;
                const children = graph.children.get(nodeId) || [];
                for (const childId of children) {
                    count += countDescendants(childId, visited);
                }
                return count;
            }
            
            // Sort roots by descendant count (largest subtrees first for better spread)
            const level0 = levelGroups.get(0);
            level0.sort((a, b) => countDescendants(b.id) - countDescendants(a.id));
            
            // Assign initial positions to level 0
            const blockPosition = new Map(); // id -> position index in its level
            level0.forEach((b, idx) => blockPosition.set(b.id, idx));
            
            // For subsequent levels, sort by average parent position
            for (let lvl = 1; lvl <= maxLevel; lvl++) {
                const levelBlocks = levelGroups.get(lvl);
                
                // Calculate "barycenter" for each block (average position of parents)
                levelBlocks.forEach(block => {
                    const parentIds = graph.parents.get(block.id) || [];
                    let sum = 0;
                    let count = 0;
                    
                    parentIds.forEach(pid => {
                        const pos = blockPosition.get(pid);
                        if (pos !== undefined) {
                            sum += pos;
                            count++;
                        }
                    });
                    
                    // Store barycenter for sorting
                    block._barycenter = count > 0 ? sum / count : 9999;
                });
                
                // Sort by barycenter
                levelBlocks.sort((a, b) => a._barycenter - b._barycenter);
                
                // Assign positions in this level
                levelBlocks.forEach((b, idx) => blockPosition.set(b.id, idx));
                
                // Clean up temp property
                levelBlocks.forEach(b => delete b._barycenter);
            }
            
            // ----------------------------------------
            // STEP 5: Calculate X positions
            // ----------------------------------------
            // Center each level, and try to align children under parents
            
            // First pass: assign basic grid positions
            const blockX = new Map();
            const blockY = new Map();
            
            // Find the widest level
            let maxWidth = 0;
            for (let lvl = 0; lvl <= maxLevel; lvl++) {
                const w = levelGroups.get(lvl).length;
                maxWidth = Math.max(maxWidth, w);
            }
            
            // Position each level
            for (let lvl = 0; lvl <= maxLevel; lvl++) {
                const levelBlocks = levelGroups.get(lvl);
                const levelWidth = levelBlocks.length;
                
                // Center this level relative to the widest level
                const totalLevelWidth = levelWidth * BLOCK_WIDTH + (levelWidth - 1) * H_GAP;
                const maxTotalWidth = maxWidth * BLOCK_WIDTH + (maxWidth - 1) * H_GAP;
                const offsetX = START_X + (maxTotalWidth - totalLevelWidth) / 2;
                
                const y = START_Y + lvl * (BLOCK_HEIGHT + V_GAP);
                
                levelBlocks.forEach((block, idx) => {
                    const x = offsetX + idx * (BLOCK_WIDTH + H_GAP);
                    blockX.set(block.id, x);
                    blockY.set(block.id, y);
                });
            }
            
            // ----------------------------------------
            // STEP 6: Apply positions to blocks
            // ----------------------------------------
            blocks.forEach(block => {
                block.x = this.snapToGrid(blockX.get(block.id));
                block.y = this.snapToGrid(blockY.get(block.id));
            });
            
            // ----------------------------------------
            // STEP 7: Position helpers off to the side
            // ----------------------------------------
            if (helpers.length > 0) {
                let maxX = START_X;
                blocks.forEach(b => {
                    maxX = Math.max(maxX, b.x + BLOCK_WIDTH);
                });
                
                helpers.forEach((h, i) => {
                    h.x = this.snapToGrid(maxX + 120);
                    h.y = this.snapToGrid(START_Y + i * (BLOCK_HEIGHT + 20));
                });
            }
            
            // ----------------------------------------
            // STEP 8: Clear all waypoints for clean curves
            // ----------------------------------------
            pane.connections.forEach(conn => {
                conn.waypoints = [];
            });
            
            // ----------------------------------------
            // STEP 9: Update display
            // ----------------------------------------
            // Temporarily show pane if hidden (needed for accurate DOM measurements in updateConnections)
            const split = document.getElementById('canvasSplit');
            const wasViewingCurrent = split.classList.contains('view-current');
            const wasViewingProposed = split.classList.contains('view-proposed');
            const needsTemporaryShow = (paneId === 'proposed' && wasViewingCurrent) || 
                                       (paneId === 'current' && wasViewingProposed);
            
            if (needsTemporaryShow) {
                split.classList.remove('view-current', 'view-proposed');
            }
            
            [...blocks, ...helpers].forEach(b => this.updateBlockElement(b, paneId));
            this.updateConnections(paneId);
            this.updateMinimap();
            this.zoomToFit(paneId);
            
            // Restore original view mode
            if (needsTemporaryShow) {
                if (wasViewingCurrent) split.classList.add('view-current');
                else if (wasViewingProposed) split.classList.add('view-proposed');
            }
            
            this.toast('Auto-layout applied', 'success');
        }
        
        // Keep old methods for compatibility but simplify
        calculateAutoLayoutWaypoints(pane, blockLevel, blockWidth, blockHeight, gapY) {
            // Simplified - just clear waypoints for smooth bezier curves
            pane.connections.forEach(conn => {
                conn.waypoints = [];
            });
        }
        
        findClearRouteX(pane, fromBlock, toBlock, blockLevel, fromLevel, toLevel, blockWidth, padding) {
            // Simplified routing
            return Math.max(fromBlock.x, toBlock.x) + blockWidth + padding;
        }
        
        optimizeBlockPositions(pane, levels, blockWidth, gapX, startX, totalWidth) {
            // Simplified - no-op for now
        }
        
        // ===== ATTACHMENTS =====
        showAttachmentUpload(blockId, paneId) {
            this.pendingAttachmentBlockId = blockId;
            this.pendingAttachmentPane = paneId;
            document.getElementById('attachmentFileInput').click();
        }
        
        handleAttachmentUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const blockId = this.pendingAttachmentBlockId;
            const paneId = this.pendingAttachmentPane;
            const pane = this.getPane(paneId);
            const block = pane?.blocks.get(blockId);
            if (!block) return;
            
            const reader = new FileReader();
            reader.onload = (evt) => {
                if (!block.attachments) block.attachments = [];
                block.attachments.push({
                    id: 'att_' + Date.now(),
                    name: file.name,
                    type: file.type,
                    data: evt.target.result
                });
                this.renderPanelContent();
                this.updateBlockElement(block, paneId);
                this.toast('Attachment added', 'success');
            };
            reader.readAsDataURL(file);
            e.target.value = '';
        }
        
        removeAttachment(blockId, paneId, attachmentId) {
            const pane = this.getPane(paneId);
            const block = pane?.blocks.get(blockId);
            if (!block?.attachments) return;
            
            block.attachments = block.attachments.filter(a => a.id !== attachmentId);
            this.renderPanelContent();
            this.updateBlockElement(block, paneId);
        }
        
        // ===== PROJECT BRIEFS =====
        showBriefModal(briefId = null) {
            this.currentBriefId = briefId;
            
            if (briefId && this.briefs[briefId]) {
                // Edit existing brief
                this.editingBrief = { ...this.briefs[briefId] };
                document.getElementById('briefModalTitle').textContent = 'Edit Project Brief';
                document.getElementById('deleteBriefBtn').style.display = 'block';
            } else {
                // New brief
                this.editingBrief = {
                    id: 'brief_' + Date.now(),
                    title: '',
                    status: 'draft',
                    problem: '',
                    solution: '',
                    notes: '',
                    participants: [],
                    criteria: [],
                    linkedFlows: [],
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                };
                document.getElementById('briefModalTitle').textContent = 'New Project Brief';
                document.getElementById('deleteBriefBtn').style.display = 'none';
            }
            
            // Populate form
            document.getElementById('briefTitle').value = this.editingBrief.title || '';
            document.getElementById('briefStatus').value = this.editingBrief.status || 'draft';
            document.getElementById('briefProblem').value = this.editingBrief.problem || '';
            document.getElementById('briefSolution').value = this.editingBrief.solution || '';
            document.getElementById('briefNotes').value = this.editingBrief.notes || '';
            
            this.renderBriefParticipants();
            this.renderBriefCriteria();
            this.renderBriefLinkedFlows();
            
            this.showModal('briefModal');
        }
        
        renderBriefParticipants() {
            const container = document.getElementById('briefParticipants');
            const participants = this.editingBrief?.participants || [];
            
            container.innerHTML = participants.map((p, idx) => `
                <div class="brief-participant">
                    <span>${this.escapeHtml(p.name)}</span>
                    <span class="brief-participant-role">(${p.role})</span>
                    <span class="brief-participant-remove" data-idx="${idx}"></span>
                </div>
            `).join('');
            
            container.querySelectorAll('.brief-participant-remove').forEach(btn => {
                btn.addEventListener('click', () => {
                    this.editingBrief.participants.splice(parseInt(btn.dataset.idx), 1);
                    this.renderBriefParticipants();
                });
            });
        }
        
        addBriefParticipant() {
            const nameInput = document.getElementById('briefNewParticipant');
            const roleSelect = document.getElementById('briefParticipantRole');
            const name = nameInput.value.trim();
            
            if (!name) return;
            
            if (!this.editingBrief.participants) this.editingBrief.participants = [];
            this.editingBrief.participants.push({ name, role: roleSelect.value });
            
            nameInput.value = '';
            this.renderBriefParticipants();
        }
        
        renderBriefCriteria() {
            const container = document.getElementById('briefCriteria');
            const criteria = this.editingBrief?.criteria || [];
            
            container.innerHTML = criteria.map((c, idx) => `
                <div class="brief-criteria-item">
                    <div class="brief-criteria-checkbox ${c.checked ? 'checked' : ''}" data-idx="${idx}">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><polyline points="20 6 9 17 4 12"/></svg>
                    </div>
                    <span class="brief-criteria-text ${c.checked ? 'checked' : ''}">${this.escapeHtml(c.text)}</span>
                    <span class="brief-criteria-remove" data-idx="${idx}"></span>
                </div>
            `).join('');
            
            container.querySelectorAll('.brief-criteria-checkbox').forEach(cb => {
                cb.addEventListener('click', () => {
                    const idx = parseInt(cb.dataset.idx);
                    this.editingBrief.criteria[idx].checked = !this.editingBrief.criteria[idx].checked;
                    this.renderBriefCriteria();
                });
            });
            
            container.querySelectorAll('.brief-criteria-remove').forEach(btn => {
                btn.addEventListener('click', () => {
                    this.editingBrief.criteria.splice(parseInt(btn.dataset.idx), 1);
                    this.renderBriefCriteria();
                });
            });
        }
        
        addBriefCriteria() {
            const input = document.getElementById('briefNewCriteria');
            const text = input.value.trim();
            
            if (!text) return;
            
            if (!this.editingBrief.criteria) this.editingBrief.criteria = [];
            this.editingBrief.criteria.push({ text, checked: false });
            
            input.value = '';
            this.renderBriefCriteria();
        }
        
        renderBriefLinkedFlows() {
            const container = document.getElementById('briefLinkedFlows');
            const linkedFlows = (this.editingBrief?.linkedFlows || []).map(fid => this.driveFlows[fid]).filter(f => f);
            
            const envColors = {
                exhibitor: 'var(--green)',
                organizer: 'var(--accent)',
                ea: 'var(--orange)',
                valverde: 'var(--purple)',
                other: 'var(--text-muted)'
            };
            
            container.innerHTML = linkedFlows.map(f => `
                <div class="brief-linked-flow" data-flow-id="${f.id}">
                    <div class="brief-linked-flow-dot" style="background:${envColors[f.environment] || envColors.other}"></div>
                    <span class="brief-linked-flow-name">${this.escapeHtml(f.name || 'Untitled')}</span>
                    <span class="brief-linked-flow-unlink" data-flow-id="${f.id}">Unlink</span>
                </div>
            `).join('');
            
            if (linkedFlows.length === 0) {
                container.innerHTML = '<div style="font-size:11px;color:var(--text-muted);padding:8px;">No flows linked yet</div>';
            }
            
            container.querySelectorAll('.brief-linked-flow-name').forEach(el => {
                el.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const flowId = el.closest('.brief-linked-flow').dataset.flowId;
                    this.hideModal('briefModal');
                    this.loadFlow(flowId, true);
                    this.hideDashboard();
                });
            });
            
            container.querySelectorAll('.brief-linked-flow-unlink').forEach(el => {
                el.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const flowId = el.dataset.flowId;
                    this.editingBrief.linkedFlows = this.editingBrief.linkedFlows.filter(id => id !== flowId);
                    this.renderBriefLinkedFlows();
                });
            });
        }
        
        showLinkFlowModal() {
            const container = document.getElementById('linkFlowList');
            const alreadyLinked = this.editingBrief?.linkedFlows || [];
            const availableFlows = Object.values(this.driveFlows).filter(f => !alreadyLinked.includes(f.id));
            
            if (availableFlows.length === 0) {
                container.innerHTML = '<div style="padding:20px;text-align:center;color:var(--text-muted);">No flows available to link</div>';
            } else {
                container.innerHTML = availableFlows.map(f => `
                    <div class="flow-list-item" data-flow-id="${f.id}" style="cursor:pointer;">
                        <div class="flow-list-name">${this.escapeHtml(f.name || 'Untitled')}</div>
                        <div class="flow-list-meta">${(f.current?.blocks?.length || 0)} steps</div>
                    </div>
                `).join('');
                
                container.querySelectorAll('.flow-list-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const flowId = item.dataset.flowId;
                        if (!this.editingBrief.linkedFlows) this.editingBrief.linkedFlows = [];
                        this.editingBrief.linkedFlows.push(flowId);
                        this.hideModal('linkFlowModal');
                        this.renderBriefLinkedFlows();
                    });
                });
            }
            
            this.showModal('linkFlowModal');
        }
        
        async saveBrief() {
            if (!this.editingBrief) {
                console.error('No editingBrief to save');
                return;
            }
            
            // Update from form
            this.editingBrief.title = document.getElementById('briefTitle').value.trim() || 'Untitled Brief';
            this.editingBrief.status = document.getElementById('briefStatus').value;
            this.editingBrief.problem = document.getElementById('briefProblem').value.trim();
            this.editingBrief.solution = document.getElementById('briefSolution').value.trim();
            this.editingBrief.notes = document.getElementById('briefNotes').value.trim();
            this.editingBrief.updatedAt = new Date().toISOString();
            
            // Deep copy the brief to store
            this.briefs[this.editingBrief.id] = JSON.parse(JSON.stringify(this.editingBrief));
            
            // Save briefs to Drive
            const success = await this.saveBriefsToDrive();
            
            this.hideModal('briefModal');
            this.renderDashboard();
            
            if (success) {
                this.toast('Brief saved to Drive', 'success');
            }
        }
        
        async deleteBrief() {
            if (!this.currentBriefId || !this.briefs[this.currentBriefId]) return;
            
            if (!confirm('Delete this brief? This cannot be undone.')) return;
            
            delete this.briefs[this.currentBriefId];
            const success = await this.saveBriefsToDrive();
            
            this.hideModal('briefModal');
            this.renderDashboard();
            if (success) {
                this.toast('Brief deleted', 'success');
            }
        }
        
        async saveBriefsToDrive() {
            if (!this.googleUser) {
                this.toast('Sign in to save briefs', 'error');
                return false;
            }
            
            const tokenObj = gapi.client.getToken();
            if (!tokenObj || !tokenObj.access_token) {
                this.showSessionExpiredModal();
                return false;
            }
            const token = tokenObj.access_token;

            try {
                await this.ensureDriveFolder();
                
                if (!this.briefs) this.briefs = {};

                const content = JSON.stringify(this.briefs, null, 2);

                const searchResponse = await gapi.client.drive.files.list({
                    q: `name='briefs.json' and '${this.driveFolderId}' in parents and trashed=false`,
                    fields: 'files(id)'
                });
                
                const existingFileId = searchResponse.result.files?.[0]?.id;
                
                if (existingFileId) {
                    const resp = await fetch(`https://www.googleapis.com/upload/drive/v3/files/${existingFileId}?uploadType=media&supportsAllDrives=true`, {
                        method: 'PATCH',
                        headers: {
                            'Authorization': 'Bearer ' + token,
                            'Content-Type': 'application/json'
                        },
                        body: content
                    });
                    if (!resp.ok) throw new Error('Update failed: ' + resp.status);
                } else {
                    const metadata = {
                        name: 'briefs.json',
                        mimeType: 'application/json',
                        parents: [this.driveFolderId]
                    };
                    
                    const form = new FormData();
                    form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
                    form.append('file', new Blob([content], { type: 'application/json' }));
                    
                    const resp = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=id&supportsAllDrives=true', {
                        method: 'POST',
                        headers: { 'Authorization': 'Bearer ' + token },
                        body: form
                    });
                    if (!resp.ok) throw new Error('Create failed: ' + resp.status);
                }
                return true;
            } catch (e) {
                console.error('Failed to save briefs:', e);
                this.toast('Failed to save briefs: ' + (e.message || 'Unknown error'), 'error');
                return false;
            }
        }
        
        async loadBriefsFromDrive() {
            if (!this.googleUser || !this.driveFolderId) {
                this.briefs = {};
                return;
            }
            
            try {
                const searchResponse = await gapi.client.drive.files.list({
                    q: `name='briefs.json' and '${this.driveFolderId}' in parents and trashed=false`,
                    fields: 'files(id)'
                });
                
                const file = searchResponse.result.files?.[0];
                if (!file) {
                    this.briefs = {};
                    return;
                }
                
                const response = await gapi.client.drive.files.get({
                    fileId: file.id,
                    alt: 'media'
                });
                
                this.briefs = JSON.parse(response.body) || {};
            } catch (e) {
                console.error('Failed to load briefs:', e);
                this.briefs = {};
            }
        }
        
        // Import brief from JSON file
        importBrief(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = async (evt) => {
                try {
                    const content = evt.target.result;
                    let data = JSON.parse(content);
                    
                    // Handle array of briefs
                    if (Array.isArray(data)) {
                        if (data.length === 0) {
                            this.toast('File contains no briefs', 'error');
                            return;
                        }
                        // Import all briefs in array
                        let imported = 0;
                        for (const brief of data) {
                            if (this.validateAndImportBrief(brief)) {
                                imported++;
                            }
                        }
                        if (imported > 0) {
                            await this.saveBriefsToDrive();
                            this.toast(`Imported ${imported} brief${imported > 1 ? 's' : ''}`, 'success');
                            this.renderBriefsList();
                            this.hideModal('briefModal');
                        }
                        return;
                    }
                    
                    // Single brief
                    if (this.validateAndImportBrief(data)) {
                        await this.saveBriefsToDrive();
                        this.toast('Brief imported successfully', 'success');
                        this.renderBriefsList();
                        // Load the imported brief into the modal
                        this.showBriefModal(data.id);
                    }
                    
                } catch (err) {
                    console.error('Brief import error:', err);
                    this.toast('Invalid brief format: ' + err.message, 'error');
                }
            };
            reader.readAsText(file);
            e.target.value = ''; // Reset input
        }
        
        validateAndImportBrief(data) {
            // Validate required fields
            if (!data.title && !data.problem && !data.solution) {
                this.toast('Brief must have at least a title, problem, or solution', 'error');
                return false;
            }
            
            // Generate ID if missing
            if (!data.id) {
                data.id = 'brief_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
            }
            
            // Check for duplicate ID
            if (this.briefs[data.id]) {
                // Generate new ID to avoid overwrite
                const originalId = data.id;
                data.id = 'brief_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
                console.log(`Brief ID ${originalId} already exists, assigned new ID: ${data.id}`);
            }
            
            // Normalize the brief structure
            const normalizedBrief = {
                id: data.id,
                title: data.title || 'Imported Brief',
                status: data.status || 'draft',
                problem: data.problem || '',
                solution: data.solution || '',
                notes: data.notes || '',
                participants: Array.isArray(data.participants) ? data.participants.map(p => ({
                    name: p.name || 'Unknown',
                    role: p.role || 'stakeholder'
                })) : [],
                criteria: Array.isArray(data.criteria) ? data.criteria.map(c => ({
                    text: typeof c === 'string' ? c : (c.text || ''),
                    checked: typeof c === 'object' ? !!c.checked : false
                })) : [],
                linkedFlows: Array.isArray(data.linkedFlows) ? data.linkedFlows : [],
                createdAt: data.createdAt || new Date().toISOString(),
                updatedAt: new Date().toISOString()
            };
            
            // Add to briefs
            this.briefs[normalizedBrief.id] = normalizedBrief;
            
            return true;
        }
        
        getBriefForFlow(flowId) {
            return Object.values(this.briefs).find(b => (b.linkedFlows || []).includes(flowId));
        }
        
        // ===== EDITING SESSIONS (Collaboration) =====
        
        async saveEditingSessions() {
            if (!this.googleUser || !this.driveFolderId) return;
            
            try {
                const content = JSON.stringify(this.editingSessions, null, 2);
                const token = gapi.client.getToken()?.access_token;
                if (!token) return;
                
                const searchResponse = await gapi.client.drive.files.list({
                    q: `name='_sessions.json' and '${this.driveFolderId}' in parents and trashed=false`,
                    fields: 'files(id)'
                });
                
                const existingFileId = searchResponse.result.files?.[0]?.id;
                
                if (existingFileId) {
                    await fetch(`https://www.googleapis.com/upload/drive/v3/files/${existingFileId}?uploadType=media&supportsAllDrives=true`, {
                        method: 'PATCH',
                        headers: { 'Authorization': 'Bearer ' + token, 'Content-Type': 'application/json' },
                        body: content
                    });
                } else {
                    const metadata = { name: '_sessions.json', mimeType: 'application/json', parents: [this.driveFolderId] };
                    const form = new FormData();
                    form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
                    form.append('file', new Blob([content], { type: 'application/json' }));
                    await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=id&supportsAllDrives=true', {
                        method: 'POST',
                        headers: { 'Authorization': 'Bearer ' + token },
                        body: form
                    });
                }
            } catch (e) {
                console.error('Failed to save sessions:', e);
            }
        }
        
        async loadEditingSessions() {
            if (!this.googleUser || !this.driveFolderId) {
                this.editingSessions = {};
                return;
            }
            
            try {
                const searchResponse = await gapi.client.drive.files.list({
                    q: `name='_sessions.json' and '${this.driveFolderId}' in parents and trashed=false`,
                    fields: 'files(id)'
                });
                
                const file = searchResponse.result.files?.[0];
                if (!file) {
                    this.editingSessions = {};
                    return;
                }
                
                const response = await gapi.client.drive.files.get({ fileId: file.id, alt: 'media' });
                this.editingSessions = JSON.parse(response.body) || {};
                
                // Clean up expired sessions
                this.cleanupExpiredSessions();
            } catch (e) {
                console.error('Failed to load sessions:', e);
                this.editingSessions = {};
            }
        }
        
        cleanupExpiredSessions() {
            const now = Date.now();
            const expiryMs = this.sessionExpiryMinutes * 60 * 1000;
            let changed = false;
            
            Object.keys(this.editingSessions).forEach(flowId => {
                const session = this.editingSessions[flowId];
                if (now - session.lastActivity > expiryMs) {
                    delete this.editingSessions[flowId];
                    changed = true;
                }
            });
            
            if (changed) {
                this.saveEditingSessions();
            }
        }
        
        getUserDisplayName() {
            return this.googleUser?.name || this.googleUser?.email || 'Someone';
        }
        
        async startEditingSession(flowId) {
            if (!flowId) return;
            
            await this.loadEditingSessions();
            
            this.editingSessions[flowId] = {
                userName: this.getUserDisplayName(),
                userEmail: this.googleUser?.email,
                lastActivity: Date.now(),
                startedAt: Date.now()
            };
            
            await this.saveEditingSessions();
            
            // Update session every 60 seconds
            this.stopEditingSession(); // Clear any existing interval
            this.sessionUpdateInterval = setInterval(() => {
                this.updateEditingSession(flowId);
            }, 60000);
        }
        
        async updateEditingSession(flowId) {
            if (!flowId || !this.editingSessions[flowId]) return;
            
            this.editingSessions[flowId].lastActivity = Date.now();
            await this.saveEditingSessions();
        }
        
        stopEditingSession() {
            if (this.sessionUpdateInterval) {
                clearInterval(this.sessionUpdateInterval);
                this.sessionUpdateInterval = null;
            }
        }
        
        async endEditingSession(flowId) {
            this.stopEditingSession();
            
            if (!flowId) return;
            
            await this.loadEditingSessions();
            
            // Only delete if it's our session
            const session = this.editingSessions[flowId];
            if (session && session.userEmail === this.googleUser?.email) {
                delete this.editingSessions[flowId];
                await this.saveEditingSessions();
            }
        }
        
        getActiveSession(flowId) {
            if (!flowId) return null;
            
            const session = this.editingSessions[flowId];
            if (!session) return null;
            
            // Check if expired
            const now = Date.now();
            const expiryMs = this.sessionExpiryMinutes * 60 * 1000;
            if (now - session.lastActivity > expiryMs) {
                return null;
            }
            
            // Check if it's our own session
            if (session.userEmail === this.googleUser?.email) {
                return null; // Don't warn about our own session
            }
            
            return session;
        }
        
        formatTimeAgo(timestamp) {
            const seconds = Math.floor((Date.now() - timestamp) / 1000);
            if (seconds < 60) return 'just now';
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return `${minutes} minute${minutes !== 1 ? 's' : ''} ago`;
            const hours = Math.floor(minutes / 60);
            return `${hours} hour${hours !== 1 ? 's' : ''} ago`;
        }
        
        // Called when clicking a flow card - check for conflicts first
        async checkAndOpenFlow(flowId) {
            this.pendingFlowId = flowId;
            
            await this.loadEditingSessions();
            const activeSession = this.getActiveSession(flowId);
            
            if (activeSession) {
                // Show warning modal
                document.getElementById('conflictUserName').textContent = activeSession.userName;
                document.getElementById('conflictLastActivity').textContent = this.formatTimeAgo(activeSession.lastActivity);
                this.showModal('editingConflictModal');
            } else {
                // No conflict, open directly
                this.confirmOpenFlow();
            }
        }
        
        async confirmOpenFlow() {
            this.hideModal('editingConflictModal');
            
            const flowId = this.pendingFlowId;
            if (!flowId) return;
            
            // End any previous session
            if (this.currentFlowId) {
                await this.endEditingSession(this.currentFlowId);
            }
            
            // Load the flow
            this.loadFlow(flowId, true);
            this.hideDashboard();
            
            // Start editing session
            await this.startEditingSession(flowId);
            
            // Track when we loaded for conflict detection on save
            this.flowLoadedAt = Date.now();
        }
        
        // Check for save conflicts
        async checkSaveConflict() {
            if (!this.currentFlowId || !this.currentFlowIsDrive) return false;
            
            const flow = this.driveFlows[this.currentFlowId];
            if (!flow || !flow.driveFileId) return false;
            
            try {
                // Get file metadata to check last modified time
                const response = await gapi.client.drive.files.get({
                    fileId: flow.driveFileId,
                    fields: 'modifiedTime'
                });
                
                const serverModifiedTime = new Date(response.result.modifiedTime).getTime();
                
                // If file was modified after we loaded it, there's a conflict
                if (this.flowLoadedAt && serverModifiedTime > this.flowLoadedAt) {
                    // Load sessions to find who modified it
                    await this.loadEditingSessions();
                    
                    // Find the other user
                    const session = this.editingSessions[this.currentFlowId];
                    const otherUser = session?.userName || 'someone else';
                    
                    document.getElementById('saveConflictUser').textContent = otherUser;
                    document.getElementById('saveConflictTime').textContent = this.formatTimeAgo(serverModifiedTime);
                    
                    this.showModal('saveConflictModal');
                    return true;
                }
            } catch (e) {
                console.error('Error checking save conflict:', e);
            }
            
            return false;
        }
        
        async reloadConflictedFlow() {
            this.hideModal('saveConflictModal');
            
            if (!this.currentFlowId) return;
            
            // Reload from Drive
            await this.loadDriveFlows();
            this.loadFlow(this.currentFlowId, true);
            this.flowLoadedAt = Date.now();
            this.toast('Flow reloaded', 'success');
        }
        
        async overwriteConflictedFlow() {
            this.hideModal('saveConflictModal');
            
            // Force save
            await this.saveCurrentFlowForce();
        }
        
        async saveCurrentFlowForce() {
            // Same as saveCurrentFlow but skips conflict check
            if (!this.currentFlowId) { this.showFlowModal(); return; }
            
            this.showSaveOverlay('Preparing to save...');
            
            try {
                this.addToHistory();
                
                const isDrive = this.currentFlowIsDrive;
                const flow = isDrive ? this.driveFlows[this.currentFlowId] : this.flows[this.currentFlowId];
                
                // Deep copy blocks and connections
                const currentBlocks = Array.from(this.current.blocks.values()).map(b => JSON.parse(JSON.stringify(b)));
                const currentConnections = JSON.parse(JSON.stringify(this.current.connections));
                const proposedBlocks = Array.from(this.proposed.blocks.values()).map(b => JSON.parse(JSON.stringify(b)));
                const proposedConnections = JSON.parse(JSON.stringify(this.proposed.connections));
                
                flow.current = { blocks: currentBlocks, connections: currentConnections };
                flow.proposed = { blocks: proposedBlocks, connections: proposedConnections };
                flow.issueFixLinks = JSON.parse(JSON.stringify(this.issueFixLinks));
                flow.updatedAt = new Date().toISOString();
                
                if (isDrive) {
                    await this.saveToDrive(flow);
                } else {
                    localStorage.setItem('flowbuilder_flows', JSON.stringify(this.flows));
                    this.toast('Flow saved locally', 'success');
                }
                
                this.flowLoadedAt = Date.now();
            } catch (e) {
                console.error('Force save failed:', e);
                this.toast('Save failed: ' + e.message, 'error');
            } finally {
                this.hideSaveOverlay();
            }
        }
        
        updateBriefReference() {
            const container = document.getElementById('briefReference');
            if (!container) return;
            
            const brief = this.getBriefForFlow(this.currentFlowId);
            
            if (!brief) {
                container.style.display = 'none';
                container.innerHTML = '';
                return;
            }
            
            const criteria = brief.criteria || [];
            const checkedCount = criteria.filter(c => c.checked).length;
            const progress = criteria.length > 0 ? Math.round((checkedCount / criteria.length) * 100) : 0;
            const statusLabels = {
                'draft': 'Draft',
                'agreed': 'Agreed',
                'in-progress': 'In Progress',
                'validating': 'Validating',
                'complete': 'Complete'
            };
            
            // Truncate problem/solution for display
            const problemPreview = (brief.problem || '').substring(0, 150) + ((brief.problem || '').length > 150 ? '...' : '');
            const solutionPreview = (brief.solution || '').substring(0, 200) + ((brief.solution || '').length > 200 ? '...' : '');
            
            container.style.display = 'block';
            container.innerHTML = `
                <div class="brief-reference">
                    <div class="brief-reference-header">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/></svg>
                        Project Brief
                    </div>
                    <div class="brief-reference-name" id="briefRefName">${this.escapeHtml(brief.title || 'Untitled Brief')}</div>
                    <span class="brief-reference-status ${brief.status || 'draft'}">${statusLabels[brief.status] || 'Draft'}</span>
                    
                    ${brief.problem ? `
                    <div class="brief-reference-section">
                        <div class="brief-reference-section-title">Problem</div>
                        <div class="brief-reference-section-content">${this.escapeHtml(problemPreview)}</div>
                    </div>
                    ` : ''}
                    
                    ${brief.solution ? `
                    <div class="brief-reference-section">
                        <div class="brief-reference-section-title">Agreed Solution</div>
                        <div class="brief-reference-section-content brief-reference-solution">${this.escapeHtml(solutionPreview)}</div>
                    </div>
                    ` : ''}
                    
                    ${criteria.length > 0 ? `
                    <div class="brief-reference-section">
                        <div class="brief-reference-section-title">Acceptance Criteria</div>
                        <div class="brief-reference-criteria">${checkedCount}/${criteria.length} met</div>
                        <div class="brief-reference-progress"><div class="brief-reference-progress-bar" style="width:${progress}%"></div></div>
                        <div class="brief-criteria-mini" id="briefCriteriaMini">
                            ${criteria.map((c, idx) => `
                                <div class="brief-criteria-mini-item">
                                    <div class="brief-criteria-mini-check ${c.checked ? 'checked' : ''}" data-idx="${idx}">
                                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><polyline points="20 6 9 17 4 12"/></svg>
                                    </div>
                                    <span class="brief-criteria-mini-text ${c.checked ? 'checked' : ''}">${this.escapeHtml(c.text)}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    ` : ''}
                    
                    <div class="brief-reference-edit">
                        <span class="brief-reference-edit-btn" id="briefRefEditBtn">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>
                            Open Full Brief
                        </span>
                    </div>
                </div>
            `;
            
            // Bind click to open brief modal
            document.getElementById('briefRefName')?.addEventListener('click', () => {
                this.showBriefModal(brief.id);
            });
            document.getElementById('briefRefEditBtn')?.addEventListener('click', () => {
                this.showBriefModal(brief.id);
            });
            
            // Bind criteria checkbox toggles
            container.querySelectorAll('.brief-criteria-mini-check').forEach(cb => {
                cb.addEventListener('click', async () => {
                    const idx = parseInt(cb.dataset.idx);
                    brief.criteria[idx].checked = !brief.criteria[idx].checked;
                    brief.updatedAt = new Date().toISOString();
                    this.briefs[brief.id] = brief;
                    await this.saveBriefsToDrive();
                    this.updateBriefReference();
                });
            });
        }
        
        showImageViewer(dataUrl) {
            document.getElementById('imageViewerImg').src = dataUrl;
            document.getElementById('imageViewer').classList.add('show');
        }
    }

    new FlowBuilder();
    </script>
</body>
</html>
